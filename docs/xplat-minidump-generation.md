# クロスプラットフォームミニダンプ

::: info 原文
この章の原文は [Cross-platform Minidumps](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/xplat-minidump-generation.md) です。
:::

## はじめに

Windows、Linux、およびその他の非 Windows プラットフォームにおけるダンプ (dump) 生成にはいくつかの課題があります。ダンプは非常に大きくなる可能性があり、ダンプのデフォルトの名前や保存場所はサポートされているすべてのプラットフォームで一貫していません。フルコアダンプ (full core dump) のサイズは「coredump*filter」ファイル/フラグによってある程度制御できますが、最小の設定でも依然として大きすぎる場合があり、デバッグに必要なすべてのマネージド状態 (managed state) が含まれていない可能性があります。デフォルトでは、一部のプラットフォームは \_core* という名前を使用し、プログラムが起動されたカレントディレクトリにコアダンプを配置します。他のプラットフォームでは名前に _pid_ を追加します。コア名と保存場所の構成にはスーパーユーザー権限が必要です。一貫性のためにスーパーユーザー権限を要求するのは満足のいく選択肢ではありません。

::: tip 💡 初心者向け補足
ダンプ (dump) とは、プログラムがクラッシュした際にメモリの内容をファイルに保存したものです。Java でいうところのヒープダンプやスレッドダンプに近い概念です。このファイルを後からデバッガで開くことで、クラッシュ時のプログラムの状態を調査できます。「ミニダンプ (minidump)」は、すべてのメモリではなく、デバッグに必要な最小限の情報だけを含むダンプです。
:::

私たちの目標は、サポートされている任意の Linux プラットフォーム上で、WER（Windows エラー報告）のクラッシュダンプと同等のコアダンプを生成することです。少なくとも以下を実現したいと考えています：

- 最小サイズのミニダンプの自動生成。ダンプに含まれる情報の品質と量は、従来の Windows ミニダンプに含まれる情報と同等であること。
- ユーザーによる簡単な構成（_su_ ではなく！）。

現時点での解決策は、ランタイムの PAL レイヤーで未処理の例外 (unhandled exception) をインターセプトし、coreclr 自身が「ミニ」コアダンプの生成をトリガーすることです。

## 設計

Breakpad やその派生（例：SQL チームの内部 MS バージョンである _msbreakpad_ など）のような既存の技術を検討しました。Breakpad は Windows ミニダンプを生成しますが、Windbg などの既存のツールとは互換性がありません。Msbreakpad はさらに互換性がありません。ミニダンプから Linux コアへの変換ユーティリティがありますが、余分な手順に思えます。_Breakpad_ はシグナルハンドラ (signal handler) 内でプロセス内 (in-process) にミニダンプを生成することができます。「非同期」シグナルハンドラ（SIGSEGV など）で許可される API に制限し、同様に制約された C++ ランタイムの小さなサブセットを持っています。さらに、「マネージド」状態のメモリ領域のセットを追加する必要があり、これには _DAC_ の（\*）メモリ列挙インターフェイスのロードと使用が必要です。非同期シグナルハンドラではモジュールのロードは許可されていませんが、fork/execve は許可されているため、_DAC_ をロードし、メモリ領域のリストを列挙し、ダンプを書き込むユーティリティを起動するのが唯一の合理的な選択肢です。これにより、ダンプをサーバーにアップロードすることも可能になります。

::: tip 💡 初心者向け補足
_DAC_（Data Access Component）は、coreclr ランタイムの一部を特別にビルドしたもので、マネージド状態（スタック、変数、GC 状態のヒープなど）をプロセス外から検査できるようにするものです。Java でいえば、JVM の内部状態を外部ツールから読み取るための仕組みに相当します。シグナルハンドラ（SIGSEGV などのクラッシュシグナルを受け取る関数）内では安全に呼べる API が限られているため、fork で子プロセスを生成し、そこで DAC をロードしてダンプを書き出す設計になっています。
:::

\* _DAC_ は coreclr ランタイムの一部を特別にビルドしたもので、ランタイムのマネージド状態（スタック、変数、GC 状態のヒープ）をコンテキスト外から検査できるようにします。提供される多くのインターフェイスの一つが [ICLRDataEnumMemoryRegions](https://github.com/dotnet/runtime/blob/main/src/coreclr/debug/daccess/dacimpl.h) で、ミニダンプが実りあるデバッグ体験を実現するために必要なすべてのマネージド状態を列挙します。

_Breakpad_ は生成ユーティリティ内でコンテキスト外で使用することもできましたが、ほとんどのシナリオでは _lldb_ のようなプラットフォームツールの使用が必要になるため、ネイティブの Linux コア形式に変換しなければならない Windows 風のミニダンプ形式に価値はないと判断しました。また、Google の _Breakpad_ や SQL の _msbreakpad_ ソースリポジトリへの coreclr ビルド依存関係が追加されます。唯一の利点は、Breakpad のミニダンプはメモリ領域がバイト粒度であるのに対し、Linux コアのメモリ領域はページ粒度である必要があるため、若干小さくなる可能性があることです。

## 実装の詳細

### Linux

コアダンプ生成は、未処理のマネージド例外 (unhandled managed exception) や SIGSEGV、SIGILL、SIGFPE などの非同期シグナルにより、coreclr がプロセスをアボート（[PROCAbort()](https://github.com/dotnet/runtime/blob/main/src/coreclr/pal/src/include/pal/process.h) 経由）しようとするたびにトリガーされます。_createdump_ ユーティリティは libcoreclr.so と同じディレクトリに配置されており、fork/execve で起動されます。子プロセスの _createdump_ には ptrace の権限と、クラッシュしたプロセスの各種特殊 /proc ファイルへのアクセス権が与えられ、クラッシュしたプロセスは _createdump_ が完了するまで待機します。

_createdump_ ユーティリティは、ptrace を使用してターゲットプロセスのすべてのスレッドを列挙し、サスペンドすることから始まります。プロセスとスレッドの情報（ステータス、レジスタなど）が収集されます。auxv エントリと _DSO_ 情報が列挙されます。_DSO_ はターゲットによってロードされた共有モジュール (shared module) を記述するメモリ内データ構造です。このメモリは、ロードされた共有モジュールを列挙しそのシンボルにアクセスするために、gdb や lldb がダンプ内で必要とします。モジュールのメモリマッピングは /proc/$pid/maps から収集されます。プログラムや共有モジュールのメモリ領域はダンプのメモリ領域に明示的には追加されません。_DAC_ がロードされ、Windows と同様にメモリ領域列挙インターフェイスを使用してメモリ領域リストが構築されます。スレッドスタックと IP 周辺の 1 ページ分のコードが追加されます。バイトサイズの領域はページ単位に切り上げられ、連続した領域に結合されます。

/proc/$pid/maps からのすべてのメモリマッピングは、実際にはメモリがダンプに含まれていなくても PT_LOAD セクションに含まれます。これらのファイルオフセット/サイズは 0 です。

すべてのプロセスクラッシュ情報が収集された後、ELF コアダンプが書き込まれます。メインの ELF ヘッダーが作成・書き込みされます。PT_LOAD ノートセクションがダンプ内の各メモリ領域ごとに 1 エントリずつ書き込まれます。プロセス情報、auxv データ、NT*FILE エントリがコアに書き込まれます。NT_FILE エントリは /proc/$pid/maps からのモジュールメモリマッピングから構築されます。次にスレッドの状態とレジスタが書き込まれます。最後に、\_DAC* などによって上記で収集されたすべてのメモリ領域がターゲットプロセスから読み取られ、コアダンプに書き込まれます。ターゲットプロセスのすべてのスレッドが再開され、_createdump_ は終了します。

::: tip 💡 初心者向け補足
ELF（Executable and Linkable Format）は Linux で使われる実行ファイルやコアダンプの標準的なファイル形式です。コアダンプには PT*LOAD セクション（メモリ領域の内容）やノートセクション（スレッド情報やレジスタの値など）が含まれます。\_createdump* は ptrace というシステムコールを使って、対象プロセスのメモリやレジスタを外部から読み取ります。これは Java の jmap や jstack が JVM の内部状態を取得するのと似た仕組みです。
:::

**深刻なメモリ破壊**

シグナル/アボートハンドラに制御が到達でき、ユーティリティの fork/execve が成功しさえすれば、_DAC_ のメモリ列挙インターフェイスはある程度の破壊を処理できます。ただし、結果として得られるダンプには有用なマネージド状態が十分に含まれていない可能性があります。このケースを検出してフルコアダンプを書き込むことを検討することもできます。

**スタックオーバーフロー例外**

深刻なメモリ破壊のケースと同様に、シグナルハンドラ（`SIGSEGV`）が制御を取得できれば、ほとんどのスタックオーバーフローのケースを検出でき、コアダンプをトリガーします。ただし、これが発生せず OS がプロセスを単純に終了してしまうケースも多くあります。ランタイムの初期バージョン（2.1.x 以前）には、スタックオーバーフロー時に _createdump_ が起動されないバグがあります。

### FreeBSD/OpenBSD/NetBSD

クラッシュ情報の収集にはいくつかの違いがありますが、これらのプラットフォームは依然として ELF 形式のコアダンプを使用するため、ユーティリティのその部分はあまり異ならないはずです。Linux で _createdump_ に ptrace の使用権限と /proc へのアクセス権限を付与するために使用されるメカニズムは、これらのプラットフォームには存在しません。

### macOS

.NET 5.0 では、createdump は macOS でのダンプ生成をサポートしていましたが、MachO ダンプ形式の代わりに ELF コアダンプを生成していました。これは、生成側の MachO ダンプライターと診断ツール側（dotnet-dump および CLRMD）の MachO リーダーの開発の時間的制約によるものでした。これは、5.0 ランタイムで動作するアプリから取得したダンプでは gdb や lldb のようなネイティブデバッガが動作しないことを意味しますが、dotnet-dump ツールを使用すればマネージド状態を分析できます。この動作のため、以下の「構成/ポリシー」セクションの環境変数に加えて、追加の環境変数（COMPlus_DbgEnableElfDumpOnMacOS=1）を設定する必要がありました。

.NET 6.0 からは、ネイティブの Mach-O コアファイルが生成されるようになり、変数 COMPlus_DbgEnableElfDumpOnMacOS は非推奨となりました。

### Windows

.NET 5.0 以降、createdump と以下の構成環境変数は Windows でもサポートされています。Windows の MiniDumpWriteDump API を使用して実装されています。これにより、すべてのプラットフォームで一貫したクラッシュ/未処理例外のダンプが可能になります。

## 構成/ポリシー

注意: Docker コンテナ内でのコアダンプ生成には ptrace ケーパビリティが必要です（--cap-add=SYS_PTRACE または --privileged の run/exec オプション）。

すべての構成やポリシーは環境変数で設定され、_createdump_ ユーティリティにオプションとして渡されます。

サポートされている環境変数：

- `DOTNET_DbgEnableMiniDump`: 「1」に設定すると、このコアダンプ生成が有効になります。デフォルトではダンプは生成されません。
- `DOTNET_DbgMiniDumpType`: 以下を参照。デフォルトは「2」（MiniDumpWithPrivateReadWriteMemory）。
- `DOTNET_DbgMiniDumpName`: 設定された場合、ダンプのパスとファイル名を作成するテンプレートとして使用されます。ダンプ名のフォーマット方法については「ダンプ名のフォーマット」を参照してください。デフォルトは _/tmp/coredump.%p_ です。
- `DOTNET_DbgCreateDumpToolPath`: **（NativeAOT のみ）** 設定された場合、createdump ツールが配置されているディレクトリパスを指定します。ランタイムはこのディレクトリ内の createdump バイナリを探します。これは、createdump がランタイムに同梱されておらず、独自のダンプ生成ツールを「持ち込む」必要があるシナリオで有用です。この環境変数は NativeAOT アプリケーションでのみサポートされ、それ以外では無視されます。
- `DOTNET_CreateDumpDiagnostics`: 「1」に設定すると、_createdump_ ユーティリティの診断メッセージ（TRACE マクロ）が有効になります。
- `DOTNET_CreateDumpVerboseDiagnostics`: 「1」に設定すると、_createdump_ ユーティリティの詳細な診断メッセージ（TRACE_VERBOSE マクロ）が有効になります。
- `DOTNET_CreateDumpLogToFile`: 設定された場合、_createdump_ の診断メッセージを書き込むファイルのパスです。
- `DOTNET_EnableCrashReport`: .NET 6.0 以降で「1」に設定すると、createdump はクラッシュしたアプリケーションのスレッドとスタックフレームに関する情報を含む JSON 形式のクラッシュレポートも生成します。クラッシュレポート名は、ダンプのパス/名前に _.crashreport.json_ を付加したものです。
- `DOTNET_EnableCrashReportOnly`: .NET 7.0 以降で、DOTNET_EnableCrashReport と同じですが、コアダンプは生成されません。

DOTNET_DbgMiniDumpType の値：

| 値  |                 ミニダンプ列挙値                 | 説明                                                                                                                                                                                                             |
| --- | :----------------------------------------------: | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1   |                  MiniDumpNormal                  | プロセス内のすべての既存スレッドのスタックトレースをキャプチャするために必要な情報のみを含みます。GC ヒープメモリと情報は限定的です。                                                                            |
| 2   | MiniDumpWithPrivateReadWriteMemory（デフォルト） | GC ヒープと、プロセス内のすべての既存スレッドのスタックトレースをキャプチャするために必要な情報を含みます。                                                                                                      |
| 3   |               MiniDumpFilterTriage               | プロセス内のすべての既存スレッドのスタックトレースをキャプチャするために必要な情報のみを含みます。GC ヒープメモリと情報は限定的です。                                                                            |
| 4   |              MiniDumpWithFullMemory              | プロセス内のすべてのアクセス可能なメモリを含みます。生のメモリデータは末尾に含まれるため、初期構造は生のメモリ情報なしに直接マッピングできます。このオプションは非常に大きなファイルを生成する可能性があります。 |

（上記のミニダンプ列挙値の意味については、MSDN の[ミニダンプ列挙値](<https://msdn.microsoft.com/en-us/library/windows/desktop/ms680519(v=vs.85).aspx>)を参照してください）

**コマンドラインの使用法**

createdump ユーティリティは、任意の .NET Core プロセスに対してコマンドラインから実行することもできます。ダンプの種類は以下のコマンドスイッチで制御できます。デフォルトは、必要なメモリとマネージド状態の大部分を含む「ミニダンプ」です。ptrace（CAP_SYS_PTRACE）の管理者権限がない限り、sudo または su で実行する必要があります。これは lldb やその他のネイティブデバッガでアタッチする場合と同じです。

```
createdump [options] pid
-f, --name - ダンプのパスとファイル名。デフォルトは '/tmp/coredump.%p'。以下の指定子は対応する値に置換されます：
   %p  ダンプされるプロセスの PID
   %e  プロセスの実行ファイル名
   %h  gethostname() が返すホスト名
   %t  ダンプの時刻。エポック（1970-01-01 00:00:00 +0000 (UTC)）からの秒数で表現
-n, --normal - ミニダンプを作成
-h, --withheap - ヒープ付きミニダンプを作成（デフォルト）
-t, --triage - トリアージミニダンプを作成
-u, --full - フルコアダンプを作成
-d, --diag - 診断メッセージを有効化
-v, --verbose - 詳細な診断メッセージを有効化
-l, --logtofile - 診断メッセージを記録するファイルのパスと名前
--crashreport - クラッシュレポートファイルを書き込み（ダンプファイルパス + .crashreport.json）
--crashreportonly - クラッシュレポートファイルのみを書き込み（ダンプなし）
--crashthread <id> - クラッシュしたスレッドのスレッド ID
--signal <code> - クラッシュのシグナルコード
--singlefile - シングルファイルアプリのチェックを有効化
```

**ダンプ名のフォーマット**

.NET 5.0 以降、コアパターン（[core](https://man7.org/linux/man-pages/man5/core.5.html) を参照）のダンプ名フォーマットの以下のサブセットがサポートされています：

    %%  単一の % 文字
    %d  ダンプされるプロセスの PID（createdump の後方互換性のため）
    %p  ダンプされるプロセスの PID
    %e  プロセスの実行ファイル名
    %h  gethostname() が返すホスト名
    %t  ダンプの時刻。エポック（1970-01-01 00:00:00 +0000 (UTC)）からの秒数で表現

**カスタム createdump ツールの使用（NativeAOT のみ）**

NativeAOT ランタイムが createdump ツールを同梱していないシナリオでは、`DOTNET_DbgCreateDumpToolPath` 環境変数を使用してカスタムディレクトリパスを指定できます：

```bash
export DOTNET_DbgEnableMiniDump=1
export DOTNET_DbgCreateDumpToolPath=/path/to/directory
./myapp
```

ランタイムは指定されたディレクトリ内の `createdump` バイナリを探します。これにより、独自のダンプ生成ツールを「持ち込む」ことができます。この環境変数は NativeAOT アプリケーションでのみサポートされ、それ以外では無視されることに注意してください。

## テスト

テスト計画は、（まだ非公開の）debuggertests リポジトリの SOS テストを変更して、生成されたコアミニダンプをトリガーし使用することです。Linux 上でのマネージドコアダンプのデバッグは、ELF コアダンプリーダーが実装されるまで _mdbg_ ではサポートされないため、（Linux 上で _lldb_ を使用する）SOS テストのみが変更されます。
