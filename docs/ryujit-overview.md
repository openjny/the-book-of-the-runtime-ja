# RyuJIT 概要

::: info 原文
この章の原文は [RyuJIT Overview](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/jit/ryujit-overview.md) です。
:::

## はじめに

RyuJIT は .NET ランタイムの JIT (Just-In-Time) コンパイラのコードネームです。.NET Framework の x86 用 JIT (jit32) から進化し、.NET がサポートするすべてのアーキテクチャとプラットフォームに対応しています。

RyuJIT の主な設計目標は以下の通りです：

- 以前の JIT との高い互換性を維持する
- コード最適化、レジスタ割り当て、コード生成を通じて良好なランタイムパフォーマンスを実現する
- 線形次数の最適化・変換を中心とし、良好なスループットを確保する
- さまざまなターゲットとシナリオをサポートするアーキテクチャを設計する

::: tip 💡 初心者向け補足
JIT コンパイラとは、プログラムの実行時に中間言語 (IL) をCPU が直接実行できるネイティブコード（機械語）に変換するコンパイラです。「Just-In-Time（ちょうどその時に）」という名前の通り、コードが実際に必要になったタイミングでコンパイルを行います。
:::

## 実行環境と外部インターフェース

RyuJIT は .NET ランタイムに対して JIT コンパイルと AOT (Ahead-of-Time) コンパイルの両方のサービスを提供します。ランタイム自体は EE (Execution Engine)、VM (Virtual Machine)、または CLR (Common Language Runtime) と呼ばれます。

RyuJIT は JIT/EE インターフェースの JIT 側を実装しています：

- **`ICorJitCompiler`** – JIT コンパイラが実装するインターフェースです。主要なメソッドは以下の通りです：
  - `compileMethod` – JIT のメインエントリポイント。EE から `ICorJitInfo` オブジェクト、IL、メソッドヘッダーなどの情報を受け取り、コードへのポインタ、サイズ、GC/EH/デバッグ情報を返します。
  - `getVersionIdentifier` – JIT/EE インターフェースのバージョン管理メカニズム。
- **`ICorJitInfo`** – EE が実装するインターフェースです。メタデータトークンの検索、型シグネチャの走査、フィールドやvtableのオフセット計算、メソッドエントリポイントの検索など、多くのメソッドが定義されています。

::: tip 💡 初心者向け補足
JIT コンパイラは単独で動作するのではなく、ランタイム (EE) と密接に連携しています。EE は型情報やメソッドの情報を提供し、JIT はその情報を使ってネイティブコードを生成します。このインターフェースを通じた役割分担により、それぞれの責任範囲が明確になっています。
:::

## 内部表現 (IR)

### Compiler オブジェクト

`Compiler` オブジェクトは JIT の主要なデータ構造です。`ICorJitCompiler::compileMethod()` はメソッドごとに呼び出され、新しい `Compiler` オブジェクトを作成します。そのため、JIT は `Compiler` の状態にアクセスする際にスレッド同期を気にする必要がありません。

### IR の概要

RyuJIT は関数を `BasicBlock` の双方向リンクリストとして表現します。各 `BasicBlock` には後続ブロックへの明示的なエッジがあり、非例外制御フローを定義します。

コンパイルの初期段階では、各 `BasicBlock` には**HIR (High-level Intermediate Representation)** と呼ばれる高レベルな文・木構造の形式でノードが含まれます。バックエンドの最初のフェーズ（合理化フェーズ）で、HIR は **LIR (Low-level Intermediate Representation)** と呼ばれる線形順序のノード指向形式に変換されます。

- **HIR** - 文 (`Statement`) の双方向リンクリストで構成。各文は式ツリーを参照。ツリー順序で実行される。
- **LIR** - `GenTree` ノードの双方向リンクリストで構成。リストの順序で実行される。

::: tip 💡 初心者向け補足
コンパイラが内部的にプログラムを表現するためのデータ構造を「中間表現 (IR)」と呼びます。RyuJIT では、最初は人間にわかりやすい木構造 (HIR) でプログラムを表現し、最適化を経て、最終的に機械に近い線形表現 (LIR) に変換します。これは「高い抽象度から低い抽象度へ段階的に変換する」という、多くのコンパイラに共通するアプローチです。
:::

### GenTree ノード

各操作は `GenTree` ノードとして表現され、オペコード (`GT_xxx`)、ゼロ個以上の子・オペランドノード、およびそのノードのセマンティクスを表現するための追加フィールドを持ちます。すべてのノードには型、値番号、アサーション、レジスタ割り当てなどの情報が含まれます。

### ローカル変数記述子

`LclVarDsc` は複数回定義・使用される可能性のある一時変数の情報を表します。ユーザーのローカル変数、引数、JIT が作成する一時変数を表現するために使用されます。ローカル変数は「追跡対象 (`lvTracked`)」にすることができ、その場合はデータフロー解析に参加し、レジスタ割り当ての候補となります。

## RyuJIT のフェーズ

RyuJIT のコンパイルは以下の主要なフェーズで構成されています：

| **フェーズ** | **説明** |
| --- | --- |
| プロファイル取り込み | PGO 情報を基本ブロックに取り込む |
| インポート | IL から `GenTree` ノードを作成し、`Statement` と `BasicBlock` にリンク。インライン候補を特定 |
| インライン化 | インラインメソッドの IR をフローグラフに取り込む |
| オブジェクトスタック割り当て | エスケープ解析を行い、可能な場合はオブジェクトをスタックに割り当て |
| 構造体プロモーション | 一部の構造体のフィールドに対して個別の `LclVarDsc` を作成 |
| ローカル変形 | ローカルアクセスの簡略化、アドレス公開ローカルの検出 |
| グローバル変形 | 局所的な変換と単純な最適化を実行 |
| QMARK 除去 | `GT_QMARK` ノードを制御フローに変換 |
| ループ検出 | 自然ループを検出し正規化 |
| ループ反転 | 自然ループを "do...while" 形式に変換 |
| ループクローン | 一部のループを追加バージョンとしてクローン |
| ループ展開 | 自然ループを展開 |
| SSA と値番号付け | 生存解析、SSA 構築、値番号計算を実行 |
| ループ不変コード移動 (LICM) | ループ不変な式をループ外に移動 |
| コピー伝播 | 値番号に基づくコピー伝播 |
| 冗長分岐最適化 | 分岐の最適化 |
| 共通部分式除去 (CSE) | 値番号に基づく冗長な部分式の除去 |
| アサーション伝播 | 非 null 性などのプロパティに基づく変換 |
| 範囲解析 | 値番号とアサーションに基づく配列インデックス範囲チェックの除去 |
| 帰納変数最適化 | スカラー進化解析に基づくループ内の帰納変数の最適化 |
| 合理化 | HIR から LIR への変換。`GT_COMMA` ノードの除去 |
| ローワリング | レジスタ割り当て用にノードを変換。ターゲット固有の最適化 |
| レジスタ割り当て | レジスタの割り当て、スピル一時変数の計算 |
| コード生成 | フレームレイアウトの決定。各 `BasicBlock` のコード生成。プロローグ・エピローグの生成。EH、GC、デバッグ情報の出力 |

::: tip 💡 初心者向け補足
JIT コンパイラの仕事は「IL を受け取って機械語を出力する」ことですが、その間に多くの最適化フェーズがあります。例えば：
- **インライン化**: 小さなメソッドの呼び出しをメソッド本体のコードで置き換え、関数呼び出しのオーバーヘッドを除去します
- **CSE (共通部分式除去)**: 同じ計算が複数回行われている場合、1回だけ計算して結果を再利用します
- **レジスタ割り当て**: 変数をメモリではなく CPU レジスタに配置し、高速なアクセスを実現します
- **ループ最適化**: ループの実行を効率化する様々な手法（不変コードの移動、ループ展開など）を適用します
:::

### インポートフェーズ

インポートは IL 命令を1つずつ読み取り、メソッドの IR を作成するフェーズです。このプロセスでは、ネストされた複数の式を持つ IR を生成する必要がある場合があります。`GT_COMMA` ノード（実行順序の保証）や `GT_QMARK`/`GT_COLON` ノード（条件式）が使用されます。

### インライン化

`fgInline` フェーズでは、各呼び出しサイトがインライン化の候補かどうかを判定します。候補メソッドの IL に対して状態マシンを実行し、ネイティブコードサイズを推定します。ヒューリスティクスに基づいてインライン化が有益と判断された場合、別の `Compiler` オブジェクトが作成され、候補メソッドのツリーがインポートされます。

### SSA と値番号付け

SSA (Static Single Assignment) 形式は従来の方法で構築されます。SSA 名はローカル変数参照に記録されます。値番号付けはローカル変数の SSA を利用しますが、式ツリーの値番号付けも行います。型安全性を活用して、同じフィールドへの書き込みでない限り、ヒープ書き込みでフィールド参照の値番号を無効化しません。

### 合理化 (Rationalization)

合理化フェーズでは、フローグラフの順序がツリー順序から線形順序に変更されます。すべての `GT_COMMA` ノードが除去されます。この時点で IR は LIR に変換されます。

### ローワリング (Lowering)

ローワリングフェーズでは、IR ノードがレジスタ割り当てに適した形に変換されます。ターゲット固有の最適化もこのフェーズで行われます。例えば、アドレッシングモードの形成や、特定の命令パターンへの変換が行われます。

### レジスタ割り当て

RyuJIT は LSRA (Linear Scan Register Allocation) を使用しています。各ノードにレジスタが割り当てられ、レジスタが不足する場合はスピル（一時的にメモリに退避）が行われます。

::: tip 💡 初心者向け補足
CPU には少数の「レジスタ」と呼ばれる超高速のメモリがあります。変数をレジスタに置くとメモリアクセスよりはるかに高速ですが、レジスタの数は限られています。レジスタ割り当てとは、「どの変数をいつレジスタに置くか」を決定する重要な最適化です。レジスタに収まりきらない変数は「スピル」としてスタックに退避されます。
:::

### コード生成

コード生成フェーズでは、最終的なネイティブコードが生成されます。各 `BasicBlock` を走査し、LIR のノードに対応するマシン命令を出力します。このフェーズではフレームレイアウトの決定、プロローグ・エピローグコードの生成、EH (例外処理)、GC、デバッグ情報の出力も行います。
