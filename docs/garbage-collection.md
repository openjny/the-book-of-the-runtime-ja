# ガベージコレクション

::: info 原文
この章の原文は [Garbage Collection Design](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/garbage-collection.md) です。
:::

著者: Maoni Stephens ([@maoni0](https://github.com/maoni0)) - 2015

注: ガベージコレクション全般については _The Garbage Collection Handbook_ を、CLR GC に特化した知識については _Pro .NET Memory Management_ を参照してください。いずれも本ドキュメント末尾のリソースセクションで紹介しています。

::: tip 💡 初心者向け補足
ガベージコレクション (GC) とは、プログラムが使用しなくなったメモリを自動的に回収する仕組みです。C/C++ ではプログラマが手動でメモリを解放しますが、.NET では GC がこれを自動的に行うため、メモリリークやダングリングポインタなどの問題を大幅に減らすことができます。
:::

## コンポーネントアーキテクチャ

GC に属する 2 つのコンポーネントは、**アロケータ (allocator)** と**コレクタ (collector)** です。アロケータはメモリの取得を担当し、適切なタイミングでコレクタをトリガーします。コレクタはガベージ、すなわちプログラムで使用されなくなったオブジェクトのメモリを回収します。

コレクタが呼び出される方法は他にもあります。たとえば、`GC.Collect` を手動で呼び出す方法や、ファイナライザスレッドがメモリ不足の非同期通知を受け取った場合（これによりコレクタがトリガーされます）などです。

## アロケータの設計

アロケータは、実行エンジン (Execution Engine, EE) のアロケーションヘルパーから以下の情報とともに呼び出されます：

- 要求されたサイズ
- スレッドのアロケーションコンテキスト
- ファイナライズ可能なオブジェクトかどうかなどを示すフラグ

GC はオブジェクトの種類によって特別な扱いをしません。オブジェクトのサイズを取得するために EE に問い合わせます。

サイズに基づいて、GC はオブジェクトを 2 つのカテゴリに分類します：**小さなオブジェクト** (85,000 バイト未満) と**大きなオブジェクト** (85,000 バイト以上) です。原則として、小さなオブジェクトと大きなオブジェクトは同じように扱うことができますが、大きなオブジェクトのコンパクションはコストが高いため、GC はこの区別を行います。

::: tip 💡 初心者向け補足
85,000 バイト (約 85KB) という閾値は、.NET GC がオブジェクトを「小さなオブジェクトヒープ (SOH: Small Object Heap)」と「大きなオブジェクトヒープ (LOH: Large Object Heap)」のどちらに配置するかを決める境界です。大きなオブジェクトはメモリ内で移動 (コンパクション) するコストが非常に高いため、別のヒープで管理されます。
:::

GC がアロケータにメモリを渡す際、**アロケーションコンテキスト (allocation context)** の単位で行います。アロケーションコンテキストのサイズは**アロケーションクォンタム (allocation quantum)** によって定義されます。

- **アロケーションコンテキスト** は、特定のヒープセグメントの中の小さな領域で、それぞれ特定のスレッド専用として割り当てられます。シングルプロセッサ (論理プロセッサが 1 つ) のマシンでは、単一のコンテキストが使用され、これが第 0 世代 (gen0) のアロケーションコンテキストとなります。
- **アロケーションクォンタム** は、アロケータがアロケーションコンテキスト内でオブジェクトの割り当てを行うためにメモリを追加で必要とするたびに確保するメモリのサイズです。通常は 8K バイトで、マネージドオブジェクトの平均サイズは約 35 バイトであるため、1 つのアロケーションクォンタムで多数のオブジェクトの割り当てが可能です。

大きなオブジェクトはアロケーションコンテキストやクォンタムを使用しません。1 つの大きなオブジェクト自体が、これらの小さなメモリ領域よりも大きくなりえます。また、これらの領域の利点 (後述) は小さなオブジェクトに特有のものです。大きなオブジェクトはヒープセグメントに直接割り当てられます。

アロケータは以下の目標を達成するように設計されています：

- **適切なタイミングでの GC トリガー:** アロケータは、アロケーション予算 (コレクタが設定した閾値) を超えた場合、または特定のセグメントにそれ以上割り当てられなくなった場合に GC をトリガーします。アロケーション予算とマネージドセグメントについては後述します。
- **オブジェクトの局所性の維持:** 同じヒープセグメント上で一緒に割り当てられたオブジェクトは、互いに近い仮想アドレスに格納されます。
- **効率的なキャッシュ利用:** アロケータはオブジェクト単位ではなく、_アロケーションクォンタム_ 単位でメモリを割り当てます。そのメモリはゼロクリアされ、CPU キャッシュをウォームアップします。これは、そのメモリにすぐにオブジェクトが割り当てられるためです。アロケーションクォンタムは通常 8K バイトです。
- **効率的なロック:** アロケーションコンテキストとクォンタムのスレッドアフィニティ (スレッド親和性) により、特定のアロケーションクォンタムに書き込むスレッドは常に 1 つだけであることが保証されます。その結果、現在のアロケーションコンテキストが使い果たされていない限り、オブジェクトの割り当てにロックは不要です。
- **メモリの整合性:** GC は新しく割り当てられたオブジェクトのメモリを常にゼロクリアし、オブジェクト参照がランダムなメモリを指すことを防ぎます。
- **ヒープのクローラビリティの維持:** アロケータは各アロケーションクォンタムの残りのメモリをフリーオブジェクトにします。たとえば、アロケーションクォンタムに 30 バイト残っていて、次のオブジェクトが 40 バイトの場合、アロケータは 30 バイトをフリーオブジェクトにし、新しいアロケーションクォンタムを取得します。

::: tip 💡 初心者向け補足
「スレッドアフィニティ」とは、各スレッドが専用のメモリ領域 (アロケーションコンテキスト) を持つ仕組みです。これにより、複数のスレッドが同時にオブジェクトを割り当てても、ロック (排他制御) なしで安全に動作できます。マルチスレッド環境での高いパフォーマンスの鍵となっています。
:::

### アロケーション API

```
Object* GCHeap::Alloc(size_t size, DWORD flags);
Object* GCHeap::Alloc(alloc_context* acontext, size_t size, DWORD flags);
```

上記の関数は小さなオブジェクトと大きなオブジェクトの両方の割り当てに使用できます。LOH (Large Object Heap) に直接割り当てる関数もあります：

```
Object* GCHeap::AllocLHeap(size_t size, DWORD flags);
```

## コレクタの設計

### GC の目標

GC は、メモリを極めて効率的に管理し、「マネージドコード」を書く人がほとんど意識する必要がないことを目指しています。効率的とは以下を意味します：

- GC は十分な頻度で発生し、マネージドヒープに大量の未使用のまま割り当てられたオブジェクト (ガベージ) が含まれることを避け、不必要なメモリの使用を防ぐべきです。
- GC は可能な限り低い頻度で発生し、有用な CPU 時間の消費を避けるべきです。ただし、頻繁な GC はメモリ使用量の削減につながります。
- GC は生産的であるべきです。GC が少量のメモリしか回収しない場合、GC (およびそれに伴う CPU サイクル) は無駄になります。
- 個々の GC は高速であるべきです。多くのワークロードには低レイテンシの要件があります。
- マネージドコードの開発者は、GC について多くを知らなくても良好なメモリ利用率 (ワークロードに対して相対的に) を達成できるべきです。
- GC は、異なるメモリ使用パターンを満たすように自己調整するべきです。

::: tip 💡 初心者向け補足
GC の設計はトレードオフの連続です。GC を頻繁に実行すればメモリの無駄は減りますが、CPU 時間を消費します。逆に GC を減らせば CPU は節約できますが、メモリの無駄が増えます。CLR の GC はこのバランスを自動的に調整し、アプリケーションの特性に応じた最適な動作を目指しています。
:::

### マネージドヒープの論理的な表現

CLR GC は**世代別コレクタ (generational collector)** です。これは、オブジェクトが論理的に世代 (generation) に分類されることを意味します。世代 _N_ が収集されると、生き残ったオブジェクトは世代 _N+1_ に属するものとしてマークされます。このプロセスは**プロモーション (promotion)** と呼ばれます。降格 (demote) する場合やプロモーションしない場合の例外もあります。

小さなオブジェクトの場合、ヒープは 3 つの世代に分けられます：**gen0**、**gen1**、**gen2** です。大きなオブジェクトの場合は 1 つの世代 (**gen3**) があります。gen0 と gen1 は**エフェメラル世代 (ephemeral generation)** と呼ばれます (短期間しか存在しないオブジェクト用)。

::: tip 💡 初心者向け補足
世代別 GC の基本的な考え方は「ほとんどのオブジェクトは短命である」という経験則 (世代仮説) に基づいています。新しいオブジェクトを gen0 に配置し、GC を生き延びるたびに上の世代にプロモーションします。若い世代を頻繁に収集し、古い世代はまれにしか収集しないことで、効率的な GC を実現しています。
:::

小さなオブジェクトヒープでは、世代番号は年齢を表します。gen0 が最も若い世代です。ただし、gen0 のすべてのオブジェクトが gen1 や gen2 のオブジェクトよりも若いとは限りません。例外があり、以下で説明します。ある世代を収集するとは、その世代とそのすべての若い世代のオブジェクトを収集することを意味します。

原則として大きなオブジェクトも小さなオブジェクトと同じように扱えますが、大きなオブジェクトのコンパクションは非常にコストが高いため、異なる扱いを受けます。大きなオブジェクトの世代は 1 つだけで、パフォーマンス上の理由から常に gen2 の収集と一緒に収集されます。gen2 と gen3 はどちらも大きくなりえるため、エフェメラル世代 (gen0 と gen1) の収集は限られたコストで行う必要があります。

割り当ては常に最も若い世代に対して行われます。小さなオブジェクトの場合は常に gen0 に、大きなオブジェクトの場合は唯一の世代である gen3 に割り当てられます。

### マネージドヒープの物理的な表現

マネージドヒープは**マネージドヒープセグメント**の集合です。ヒープセグメントとは、GC が OS から取得する連続したメモリブロックです。ヒープセグメントには、含まれる内容に応じて、小さなオブジェクト用、大きなオブジェクト用、ピン留めオブジェクト用のセグメントがあります。各ヒープ上でヒープセグメントはチェーンでつながれています。少なくとも 1 つの小さなオブジェクト用セグメントと 1 つの大きなオブジェクト用セグメントがあり、CLR のロード時に確保されます。また、読み取り専用 (ro) セグメントを含む NonGC ヒープもあります。

各小さなオブジェクトヒープには常に 1 つだけ**エフェメラルセグメント**があり、gen0 と gen1 はここに存在します。このセグメントには gen2 のオブジェクトが含まれる場合も、含まれない場合もあります。エフェメラルセグメントに加えて、0 個以上の追加セグメントがあり得ますが、これらは gen2 オブジェクトのみを含むため gen2 セグメントとなります。

大きなオブジェクトヒープには 1 つ以上のセグメントがあります。

ヒープセグメントはアドレスの低い方から高い方へ消費されます。つまり、セグメント上のアドレスが低いオブジェクトは、アドレスが高いオブジェクトよりも古いことになります。ここにも後述する例外があります。

::: tip 💡 初心者向け補足
ヒープセグメントは、GC が OS から取得する実際のメモリの塊です。論理的な「世代」の概念とは異なり、物理的なメモリレイアウトを表しています。エフェメラルセグメントは特に重要で、新しいオブジェクトの割り当てが行われる場所です。
:::

ヒープセグメントは必要に応じて取得されます。ライブオブジェクトが含まれなくなると削除されますが、ヒープ上の初期セグメントは常に存在し続けます。各ヒープでは一度に 1 つのセグメントが取得されます。小さなオブジェクトの場合は GC 中に、大きなオブジェクトの場合は割り当て時に行われます。この設計により、大きなオブジェクトは gen2 の収集 (比較的コストが高い) でのみ収集されるため、パフォーマンスが向上します。

ヒープセグメントは取得された順にチェーンでつながれます。チェーンの最後のセグメントが常にエフェメラルセグメントです。収集済みのセグメント (ライブオブジェクトなし) は、削除される代わりに再利用でき、新しいエフェメラルセグメントになります。セグメントの再利用は小さなオブジェクトヒープでのみ実装されています。大きなオブジェクトが割り当てられるたびに、大きなオブジェクトヒープ全体が考慮されます。小さなオブジェクトの割り当てではエフェメラルセグメントのみが考慮されます。

### アロケーション予算

アロケーション予算 (allocation budget) は、各世代に関連付けられた論理的な概念です。超過すると、その世代の GC がトリガーされるサイズの上限です。

予算は、主にその世代の生存率 (survival rate) に基づいて設定されます。生存率が高い場合、次回の GC でデッドオブジェクトとライブオブジェクトの比率がより良くなることを期待して、予算は大きく設定されます。

### どの世代を収集するかの決定

GC がトリガーされると、GC はまずどの世代を収集するかを決定する必要があります。アロケーション予算以外にも、以下の要因を考慮する必要があります：

- **世代のフラグメンテーション:** 世代のフラグメンテーション (断片化) が高い場合、その世代を収集すると生産的になる可能性が高い。
- **マシンのメモリ負荷:** メモリ負荷が高すぎる場合、GC は空きスペースが得られる可能性があればより積極的に収集します。これは (マシン全体での) 不必要なページングを防ぐために重要です。
- **エフェメラルセグメントの空き容量:** エフェメラルセグメントの空きが少なくなっている場合、GC は新しいヒープセグメントの取得を避けるために、より積極的なエフェメラル収集 (gen1 をより多く実行) を行うことがあります。

## GC のフロー

### マークフェーズ (Mark Phase)

マークフェーズの目標は、すべての**ライブオブジェクト** (生きているオブジェクト) を見つけることです。

世代別コレクタの利点は、すべてのオブジェクトを常に調べるのではなく、ヒープの一部だけを収集できることです。エフェメラル世代を収集する際、GC はこれらの世代のどのオブジェクトがライブであるかを特定する必要があります。この情報は EE によって報告されます。EE によってライブに保たれるオブジェクトに加えて、古い世代のオブジェクトも、若い世代のオブジェクトへの参照を保持することで、それらをライブに保つことができます。

GC は古い世代のマーキングに**カード (card)** を使用します。カードは代入操作時に JIT ヘルパーによって設定されます。JIT ヘルパーは、エフェメラル範囲内のオブジェクトを検出すると、ソースの場所を表すカードを含むバイトを設定します。エフェメラル収集時、GC はヒープの残りの部分の設定されたカードを確認し、それらのカードに対応するオブジェクトのみを調べることができます。

::: tip 💡 初心者向け補足
「カード」とは、古い世代から若い世代への参照を効率的に追跡するための仕組みです。すべてのオブジェクトを毎回スキャンする代わりに、参照が変更された領域だけをチェックすることで、GC のパフォーマンスを向上させています。これは「ライトバリア (write barrier)」とも関連する技術です。
:::

### プランフェーズ (Plan Phase)

プランフェーズは、コンパクションをシミュレーションして効果的な結果を判断します。コンパクションが生産的であれば GC は実際のコンパクションを開始し、そうでなければスイープを行います。

::: tip 💡 初心者向け補足
「コンパクション (compaction)」はオブジェクトをメモリ内で移動させて隙間を埋める操作、「スイープ (sweep)」は空き領域をフリーリストに登録するだけの操作です。コンパクションはフラグメンテーションを解消しますが、オブジェクトの移動にコストがかかります。プランフェーズではどちらが効率的かを判断しています。
:::

### リロケートフェーズ (Relocate Phase)

GC がコンパクションを行うと決定した場合、オブジェクトが移動するため、それらのオブジェクトへの参照を更新する必要があります。リロケートフェーズは、収集対象の世代にあるオブジェクトを指すすべての参照を見つける必要があります。これはマークフェーズとは対照的で、マークフェーズはライブオブジェクトのみを対象とするため、弱い参照 (weak reference) を考慮する必要がありません。

### コンパクトフェーズ (Compact Phase)

このフェーズは非常に直接的です。プランフェーズがオブジェクトの移動先の新しいアドレスをすでに計算しているため、コンパクトフェーズはオブジェクトをそこにコピーします。

### スイープフェーズ (Sweep Phase)

スイープフェーズは、ライブオブジェクト間のデッドスペース (空き領域) を探します。これらのデッドスペースにフリーオブジェクトを作成します。隣接するデッドオブジェクトは 1 つのフリーオブジェクトにまとめられます。これらのフリーオブジェクトはすべて**フリーリスト (freelist)** に配置されます。

## コードフロー

用語：

- **WKS GC:** ワークステーション GC (Workstation GC)
- **SVR GC:** サーバー GC (Server GC)

### 機能的な動作

#### WKS GC (コンカレント GC 無効)

1. ユーザースレッドがアロケーション予算を使い果たし、GC をトリガーします。
2. GC は `SuspendEE` を呼び出してマネージドスレッドを一時停止します。
3. GC はどの世代を対象とするか (condemn) を決定します。
4. マークフェーズを実行します。
5. プランフェーズを実行し、コンパクション GC を行うかどうかを決定します。
6. コンパクションを行う場合はリロケートフェーズとコンパクトフェーズを実行し、行わない場合はスイープフェーズを実行します。
7. GC は `RestartEE` を呼び出してマネージドスレッドを再開します。
8. ユーザースレッドが実行を再開します。

::: tip 💡 初心者向け補足
`SuspendEE` はすべてのマネージドスレッドを一時停止させる処理で、`RestartEE` はそれらを再開させる処理です。GC 中にオブジェクトの移動が行われるため、アプリケーションのスレッドが同時にそのオブジェクトにアクセスすると問題が起きます。このため、GC 中は「Stop-the-World」(世界を止める) と呼ばれるスレッドの一時停止が行われます。
:::

#### WKS GC (コンカレント GC 有効)

以下は、バックグラウンド GC がどのように実行されるかを示しています。

1. ユーザースレッドがアロケーション予算を使い果たし、GC をトリガーします。
2. GC は `SuspendEE` を呼び出してマネージドスレッドを一時停止します。
3. GC はバックグラウンド GC を実行するかどうかを決定します。
4. バックグラウンド GC を実行する場合、バックグラウンド GC スレッドが起動されてバックグラウンド GC を実行します。バックグラウンド GC スレッドは `RestartEE` を呼び出してマネージドスレッドを再開します。
5. マネージドスレッドはバックグラウンド GC が作業を行っている間も割り当てを続けます。
6. ユーザースレッドがアロケーション予算を使い果たし、エフェメラル GC (フォアグラウンド GC と呼ばれます) をトリガーすることがあります。これは「WKS GC (コンカレント GC 無効)」と同じ方法で実行されます。
7. バックグラウンド GC は `SuspendEE` を再度呼び出してマーキングを完了し、その後 `RestartEE` を呼び出してユーザースレッドの実行中にコンカレントスイープフェーズを開始します。
8. バックグラウンド GC が完了します。

::: tip 💡 初心者向け補足
コンカレント GC (バックグラウンド GC) は、アプリケーションの応答性を向上させるための仕組みです。gen2 の収集のような時間のかかる GC を、専用のバックグラウンドスレッドで実行し、アプリケーションのスレッドはほとんど止まることなく動作を続けることができます。ただし、その間もエフェメラル世代の GC (フォアグラウンド GC) は必要に応じて実行されます。
:::

#### SVR GC (コンカレント GC 無効)

1. ユーザースレッドがアロケーション予算を使い果たし、GC をトリガーします。
2. サーバー GC スレッドが起動され、`SuspendEE` を呼び出してマネージドスレッドを一時停止します。
3. サーバー GC スレッドが GC 作業を実行します (コンカレント GC 無効のワークステーション GC と同じフェーズ)。
4. サーバー GC スレッドが `RestartEE` を呼び出してマネージドスレッドを再開します。
5. ユーザースレッドが実行を再開します。

::: tip 💡 初心者向け補足
サーバー GC (SVR GC) は、サーバーアプリケーション向けに最適化された GC モードです。CPU の各論理プロセッサに専用の GC スレッドとヒープが割り当てられ、GC 作業が並列に実行されます。これにより、スループットの高いサーバーワークロードで高いパフォーマンスが得られます。一方、ワークステーション GC (WKS GC) はデスクトップアプリケーション向けで、単一スレッドで GC を実行します。
:::

#### SVR GC (コンカレント GC 有効)

このシナリオは WKS GC (コンカレント GC 有効) と同じですが、バックグラウンドでない GC がサーバー GC スレッド上で実行される点が異なります。

## 物理アーキテクチャ

このセクションは、コードのフローを追うための参考です。

ユーザースレッドはアロケーションコンテキストのスペースを使い果たし、`try_allocate_more_space` を介して新しいコンテキストを取得します。

`try_allocate_more_space` は、GC をトリガーする必要があるときに `GarbageCollectGeneration` を呼び出します。

### WKS GC (コンカレント GC 無効) のコードフロー

WKS GC (コンカレント GC 無効) の場合、`GarbageCollectGeneration` は GC をトリガーしたユーザースレッド上ですべて実行されます。コードフローは以下のとおりです：

```cpp
GarbageCollectGeneration()
{
    SuspendEE();
    garbage_collect();
    RestartEE();
}

garbage_collect()
{
    generation_to_condemn();
    gc1();
}

gc1()
{
    mark_phase();
    plan_phase();
}

plan_phase()
{
    // 実際のプランフェーズの処理で
    // コンパクションするかどうかを決定
    if (compact)
    {
        relocate_phase();
        compact_phase();
    }
    else
        make_free_lists();
}
```

### WKS GC (コンカレント GC 有効) のコードフロー

WKS GC (コンカレント GC 有効、デフォルト) の場合、バックグラウンド GC のコードフローは以下のとおりです：

```cpp
GarbageCollectGeneration()
{
    SuspendEE();
    garbage_collect();
    RestartEE();
}

garbage_collect()
{
    generation_to_condemn();
    // バックグラウンド GC を実行することを決定
    // バックグラウンド GC スレッドを起動して作業を実行
    do_background_gc();
}

do_background_gc()
{
    init_background_gc();
    start_c_gc();

    // BGC によって再開されるまで待機
    wait_to_proceed();
}

bgc_thread_function()
{
    while (1)
    {
        // イベントを待機
        // 起動
        gc1();
    }
}

gc1()
{
    background_mark_phase();
    background_sweep();
}
```

## リソース

- [.NET CLR GC 実装 (ソースコード)](https://github.com/dotnet/runtime/blob/main/src/coreclr/gc/gc.cpp)
- [The Garbage Collection Handbook: The Art of Automatic Memory Management](http://www.amazon.com/Garbage-Collection-Handbook-Management-Algorithms/dp/1420082795)
- [ガベージコレクション (Wikipedia)](http://en.wikipedia.org/wiki/Garbage_collection_(computer_science))
- [Pro .NET Memory Management](https://prodotnetmemory.com/)
- [.NET GC Internals 動画シリーズ](https://www.youtube.com/playlist?list=PLpUkQYy-K8Y-wYcDgDXKhfs6OT8fFQtVm)
