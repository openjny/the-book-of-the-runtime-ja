# .NET を新しいプロセッサアーキテクチャへ移植するためのガイド

::: info 原文
この章の原文は [Guide For Porting](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/guide-for-porting.md) です。
:::

このドキュメントは大きく2つのセクションに分かれています。

1. .NET ランタイムの移植における各段階
2. 新しいアーキテクチャへの移植で影響を受ける主要コンポーネントに関する技術的な議論

::: tip 💡 初心者向け補足
「移植 (porting)」とは、あるプラットフォームやプロセッサアーキテクチャ向けに書かれたソフトウェアを、別のプラットフォームやアーキテクチャで動作するように適応させる作業のことです。たとえば、x86 向けに作られたランタイムを ARM64 で動くようにする、といった作業が該当します。
:::

# 移植の段階とステップ

.NET ランタイムを新しいアーキテクチャに移植する作業は、一般的に以下のような流れで進みます。

エンジニアリングが開発パスに沿って進む中で、ロジックはできるだけ早くランタイムのメインブランチ (main branch) に配置するのが最善です。これには主に2つの効果があります。

1. 個々のコミットがレビューしやすくなります。

2. 問題の修正アプローチが必ずしも受け入れられるとは限りません。変更がアップストリームの Git リポジトリに受け入れられない可能性もあり、そのような問題を早期に発見することで、大量の埋没費用を回避できます。

3. 他のプラットフォームを壊すような変更が行われた場合、破壊箇所を比較的簡単に特定できます。すべての変更を保留にして、製品が完全に機能するまで待ってから反映しようとすると、この作業ははるかに困難になりやすいです。

## ステージ1：初期のブリングアップ (Initial Bring Up)

.NET を新しいプラットフォームに移植するには、まず CoreCLR を新しいアーキテクチャに移植することから始めます。

このプロセスは以下の戦略に従います。

- 新しいターゲットアーキテクチャをビルド環境に追加し、ビルドできるようにします。

- インタープリタ (interpreter) をブリングアップする十分なインセンティブがあるか、それとも単に JIT に新しいアーキテクチャを対応させる方が安価かを判断します。CLR のインタープリタは現在ブリングアップシナリオにのみ使用されており、一般的に動作する状態としてはメンテナンスされていません。CoreCLR のコードベースに精通したエンジニアがインタープリタを有効にするには1～2ヶ月かかると想定されます。機能するインタープリタがあれば、移植チームは JIT に専念するエンジニアと VM 部分に専念するエンジニアに分かれて作業できます。

::: tip 💡 初心者向け補足
「ブリングアップ (bring up)」とは、新しいハードウェアやプラットフォーム上でソフトウェアを初めて動作させるプロセスのことです。Java でいえば、新しいアーキテクチャ上で JVM を初めて起動させるような作業に相当します。JIT (Just-In-Time コンパイラ) は実行時にコードをコンパイルし、インタープリタは命令を1つずつ解釈して実行します。
:::

- CoreCLR のテストを実行するスクリプトのセットを構築します。CoreCLR テストを実行する通常の手段は XUnit ですが、これはフレームワークがおおむね機能するようになってから初めて適切に使えるようになります。これらのスクリプトは開発の進行に伴い、ますます増える開発ニーズに対応するよう進化していきます。このスクリプトセットには以下のタスクが期待されます。
  - テストのサブセットを実行する。テストはディレクトリ構造でカテゴリ別に整理されているため、このサブセット化の仕組みはディレクトリ構造ベースのシステムだけで十分です。

  - 一部のテストをテスト単位で除外する必要があります。製品の出荷準備が整った時点で、無効化されたテストの大部分を再有効化する必要がありますが、製品の品質が十分に高まるまで数ヶ月～数年間無効化されたままとなるテストもあります。

  - クラッシュダンプまたはコアダンプを生成する。このフェーズでは多くのテストの失敗モードがクラッシュになります。コアダンプをキャプチャするテスト実行ツールがあれば、こうした問題の診断が容易になります。

  - 失敗をバケット化したリストを生成する。一般的なアプローチは、アサーションでグループ化し、クラッシュの場合はクラッシュのコールスタックでグループ化することです。

- 最初に注力すべきテストカテゴリは JIT カテゴリです。これは .NET コードを実行する基本的な能力をブリングアップするためです。これらのテストのほとんどは非常にシンプルですが、何らかのコードを動作させることは、より複雑なシナリオを扱うための前提条件です。初期ブリングアップの際は、GC の Gen0 バジェットを大きな数値に設定して、ほとんどのテスト中に GC が実行を試みないようにすると非常に便利です。（`DOTNET_GCgen0size=99999999` を設定）

::: tip 💡 初心者向け補足
Gen0 バジェットとは、ガベージコレクタ (GC) が第0世代のヒープにどれだけのメモリを割り当ててからコレクションを開始するかを制御するパラメータです。この値を非常に大きくすると、GC がほぼ起動しなくなるため、GC が未完成の段階でも JIT の基本動作のテストに集中できます。
:::

- 基本的なコードが実行できるようになったら、次は GC を動作させることに注力します。この初期フェーズでは、`FEATURE_CONSERVATIVE_GC` マクロを使って保守的 GC トラッキング (conservative GC tracking) を有効にするのが正しい選択です。この機能によりガベージコレクションはおおむね正しく機能しますが、.NET の本番利用には適しておらず、特定の状況下で際限のないメモリ使用を引き起こす可能性があります。

- 基本的な GC が動作し、基本的な JIT 機能が揃ったら、ランタイムのさまざまな機能に広げて作業できます。ランタイムを移植するエンジニアにとって特に関心が高いのは、EH（例外処理）、スタックウォーキング (stackwalking)、および相互運用 (interop) のテストスイートです。

- このフェーズでは、<https://github.com/dotnet/diagnostics> から SOS プラグインを移植することが非常に有用です。このツールで利用できる dumpmt、dumpdomain などのさまざまなコマンドは、ランタイムの移植を試みる開発者にとって日常的に役立ちます。

## ステージ2：シナリオカバレッジの拡大 (Expand Scenario Coverage)

- CoreCLR のテストがおおむねパスするようになったら、次のステップは XUnit を有効にすることです。この時点で CLR はおそらく XUnit テストを実行できるだけの能力をおおむね備えており、ライブラリテストを使ったテストの追加には XUnit が正しく動作する必要があります。

- XUnit が機能するようになったら、ライブラリのテストセットをブリングアップします。CoreCLR コードベースの相当部分は、ライブラリのテストスイートによってのみテストされています。

- エンジニアはこの時点で、ASP.NET Core アプリケーションなどの実際のシナリオテストも開始すべきです。ライブラリのテストスイートが動作すれば、ASP.NET Core も動作するはずです。

## ステージ3：パフォーマンスへの注力 (Focus on Performance)

- この時点でスループットパフォーマンスはおそらくあまり良くないでしょう。このステージではパフォーマンスを改善するための3つの主要な機会があります。
  - 保守的 GC を正確な GC (precise GC) に置き換える。

  - アセンブリスタブ (assembly stubs) をプラットフォーム上で高性能になるようチューニングし、手書きのアセンブリが同等の C++ コードよりも高速になるオプションのアセンブリスタブを実装する。

  - JIT が生成するコードを改善する。

- この時点まで、エンジニアはおそらく Ready To Run コンパイラ (crossgen/crossgen2) をプラットフォームで使用する代わりに、すべてのコードに JIT を使用してきたでしょう。AOT (Ahead-Of-Time) コンパイラの実装は、起動パフォーマンスを向上させるためにこの時点から有用になり始めます。

::: tip 💡 初心者向け補足
「保守的 GC (conservative GC)」は、メモリ上の値が GC 参照かどうかを厳密に判別せず、「参照かもしれない」値はすべて参照として扱います。これにより実装は簡単になりますが、本来回収できるメモリを回収できない場合があります。「正確な GC (precise GC)」は、各値が参照かどうかを正確に把握するため効率的ですが、JIT や VM からの正確なメタデータが必要です。
:::

## ステージ4：ストレスへの注力 (Focus on Stress)

- システムが本当に動作するという信頼性を確保するためには、ストレステスト (stress testing) が必要です。

- CI で行われるさまざまなテストパスを参照してください。特に重要なのは GCStress テストです。`DOTNET_GCStress` 環境変数の使用に関するドキュメントを参照してください。

## ステージ5：製品化 (Productization)

- 製品化とは、ランタイムをプラットフォーム上で効果的に出荷・実行できるようにすることです。

- このドキュメントでは、ここでの作業を列挙することは試みません。使用するプラットフォームや多数のステークホルダーの意見に大きく依存するためです。

# 設計上の課題

以下の大きなアーキテクチャ固有の設計課題は、JIT と VM の両方に大きな影響を与えます。

1. 呼び出し規約 (calling convention) のルール – 呼び出し元スタック解放 (Caller pop) vs 呼び出し先スタック解放 (Callee pop)、HFA 引数、構造体の引数渡しルールなど。CoreCLR は OS の API と広く類似した ABI を利用するように設計されています。マネージド間呼び出しには通常、VM の効率のために ABI に対する小さな調整や拡張のセットがありますが、マネージドコードの ABI とネイティブコードの ABI は一般的に非常に類似することが意図されています。（これは厳格な要件ではなく、Windows X86 ではランタイムはマネージド間 ABI に加えて、相互運用のための3つの別々のネイティブ ABI をサポートしていますが、このスキームは一般的に推奨されません。）既存アーキテクチャの動作については [CLR ABI](./clr-abi) ドキュメントを参照してください。新しいプラットフォームのすべての必要な詳細と特殊ケースで CLR ABI ドキュメントが更新されていることを確認してください。CoreCLR の新しいプロセッサアーキテクチャ ABI の動作を定義する際には、以下を維持する必要があります。
   1. `this` ポインタは、他のパラメータに関係なく、常に同じレジスタで渡されること。

   2. さまざまなスタブタイプが追加の「秘密の (secret)」パラメータを必要とすること。パフォーマンスの詳細が、これらがどこに配置されるかを通常決定します。

   3. マネージドコードの実行時に、リターンアドレスをハイジャック (hijack) することが可能でなければならないこと。現在の実装では、リターンアドレスが常にスタック上にある必要がありますが、これは ARM64 などの RISC プラットフォームにおける既知のパフォーマンス上の欠陥です。

::: tip 💡 初心者向け補足
ABI (Application Binary Interface) とは、コンパイルされたコード同士がどのように相互作用するかを定義する規約です。Java の JNI (Java Native Interface) に似た概念で、引数の渡し方、レジスタの使い方、スタックの管理方法などを規定します。「リターンアドレスのハイジャック」とは、ランタイムがスレッドを安全なポイントで停止させるために、関数の戻りアドレスを書き換えてランタイムのコードに制御を移すテクニックです。
:::

2. アーキテクチャ固有のリロケーション情報 (relocation information)（ロード、ストア、jmp、call 命令で使用されるリロケーションの生成を表現するため）。定義が必要な詳細の類例については <https://learn.microsoft.com/windows/win32/debug/pe-format#coff-relocations-object-only> を参照してください。

3. プロセス内からのプロセッサのシングルステップ機能 (single step features) の動作とアクセシビリティ。Unix では CLR デバッガはプロセス内スレッドを使用して関数をシングルステップ実行します。

4. アンワインド情報 (unwind information)。CoreCLR は Unix プラットフォーム上でも内部的に Windows スタイルのアンワインドデータを使用します。Windows スタイルのアンワインド構造体を定義する必要があります。さらに、GDB JIT <https://sourceware.org/gdb/onlinedocs/gdb/JIT-Interface.html> を通じて公開するための DWARF データの生成を有効にすることも可能です。このサポートは `#ifdef` による条件付きですが、過去に新しいプラットフォームのブリングアップをサポートするために使用されてきました。

5. EH ファンクレット (EH Funclets)。.NET は例外フィルタ (exception filters) を適切にサポートするために、2パスの例外モデル (2 pass exception model) を必要とします。これは、ほとんどの Linux アーキテクチャで使用される典型的な Itanium ABI モデルとは大きく異なります。

6. シグナル (Signals) に関する OS の動作。特に、報告される命令ポインタ (instruction pointer) が正確にどこに位置するか。

7. リトルエンディアン (little endian) vs ビッグエンディアン (big endian)。過去に .NET ランタイムがビッグエンディアンに移植された例はあります（Mono がさまざまなゲームコンソールや POWER をサポートしていた例、Xbox360 での XNA サポートなどが顕著な例です）が、CoreCLR のビッグエンディアンプラットフォームへの現行の移植はありません。

# 新しいアーキテクチャへの移植で影響を受けるランタイムのコンポーネント

これは、.NET ランタイムの注目すべきアーキテクチャ固有コンポーネントのリストです。このリストは完全ではありませんが、作業が必要となるほとんどの領域をカバーしています。

注目すべきコンポーネント

1. JIT。JIT はスタック内でアーキテクチャ固有のロジックの最大の集中を維持しています。これは驚くことではありません。ガイダンスについては [RyuJIT の移植](./porting-ryujit) を参照してください。

2. CLR PAL。Windows 以外の OS に移植する場合、PAL が最初に移植が必要なコンポーネントとなります。

3. CLR VM。VM は完全にアーキテクチャに依存しないロジックと、非常にマシン固有のパスが混在しています。

4. アンワインダ (unwinder)。アンワインダは Windows 以外のプラットフォームでスタックをアンワインドするために使用されます。<https://github.com/dotnet/runtime/tree/main/src/coreclr/unwinder> にあります。

5. System.Private.CoreLib/System.Reflection。ブリングアップに必要なアーキテクチャ固有の作業はほとんど、またはまったくありません。あると望ましい作業としては、System.Reflection.ImageFileMachine enum および ProcessorArchitecture enum のアーキテクチャサポートの追加と、それらを操作するロジックがあります。

6. 新しいアーキテクチャを追加するための PE ファイルフォーマットの変更。また、C# コンパイラも新しいアーキテクチャ向けのマシン固有コードを生成するための新しいスイッチがおそらく必要です。

7. Crossgen/Crossgen2 - 汎用の MSIL からマシン固有のロジックを生成する AOT コンパイラとして、起動パフォーマンスを向上させるために必要になります。

8. R2RDump - 事前コンパイルされたコードの問題を診断できます。

9. coredistools - GCStress（命令境界の判定が自明でない場合）、および JIT 開発用の SuperPMI asm diff に必要です。

10. デバッグおよび診断コンポーネント - マネージドデバッガとプロファイラーはこのドキュメントの範囲外です。

## CLR PAL

PAL は、CLR のコードベースがもともと Windows プラットフォーム上で動作するように設計されていたため、Win32 API に類似した API を提供します。PAL は主に OS の独立性に関わるものですが、アーキテクチャ固有のコンポーネントもあります。

1. pal.h - `CONTEXT` / `_KNONVOLATILE_CONTEXT_POINTERS` / `_RUNTIME_FUNCTION` などのアンワインドシナリオを処理するためのアーキテクチャ固有の詳細を含みます。

2. `seh-unwind.cpp` でのアンワインドサポート

3. context.cpp - レジスタコンテキストの操作とキャプチャを行います。

4. jitsupport.cpp - CPU の機能がどのように公開されるかに応じて、CPU の機能に関する情報を収集するために OS の API を呼び出すコードが必要になる場合があります。

5. PAL arch ディレクトリ - <https://github.com/dotnet/runtime/tree/main/src/coreclr/pal/src/arch>　このディレクトリには主に、シグナルと例外のアーキテクチャ固有の処理のためのアセンブリスタブが含まれています。

PAL のソースコードに加えて、<https://github.com/dotnet/runtime/tree/main/src/coreclr/pal/tests> に包括的な PAL テストのセットがあります。

## CLR VM

VM のアーキテクチャ固有のロジックのサポートは、さまざまな方法でエンコードされています。

1. 完全にアーキテクチャ固有のコンポーネント。これらはアーキテクチャ固有のフォルダに保持されます。

2. 特定のアーキテクチャでのみ有効な機能。例：`FEATURE_HFA`。

3. 特定のアーキテクチャに使用されるアドホックな `#if` ブロック。必要に応じて追加されます。一般的な目標はこれらを最小限に抑えることですが、ここでの難しさは主にプロセッサアーキテクチャがどのような特殊な動作を必要とするかによって決まります。

VM で CPU アーキテクチャを実装する方法の最新モデルとして、Arm64 がどのように実装されているかを見ることをお勧めします。

### アーキテクチャ固有コンポーネント

すべてのアーキテクチャが実装しなければならない、さまざまなアーキテクチャ固有のコンポーネントがあります。

1. アセンブリスタブ (Assembly Stubs)

2. `cgencpu.h`（CPU 固有のヘッダ。スタブやその他の CPU 固有の詳細を定義）

3. VSD コールスタブ生成 (virtualcallstubcpu.hpp および関連ロジック)

4. プリコード/プレスタブ/ジャンプスタブの生成 (Precode/Prestub/Jumpstub generation)

5. `callingconventions.h` / `argdestination.h` — VM コンポーネントが使用する ABI の実装を提供します。実装は長い一連の C プリプロセッサマクロを介してアーキテクチャ固有にされています。

6. `gcinfodecoder.h` — GC 情報のフォーマットはアーキテクチャ固有です。これは、どの特定のレジスタが GC データを保持しているかについての情報を保持するためです。実装は一般的にレジスタ番号の観点で定義されるように簡略化されていますが、既存のアーキテクチャよりも多くのレジスタが使用可能なアーキテクチャの場合、フォーマットの拡張が必要になります。

#### アセンブリスタブ (Assembly Stubs)

ランタイムがさまざまなアセンブリスタブを必要とする理由は多くあります。以下は、Unix 上の Arm64 向けに実装されたスタブの注釈付きリストです。

1. パフォーマンスのみ。一部のスタブには C++ コードでの代替実装があり、アセンブリスタブがない場合はそちらが使用されます。コンパイラが改善されるにつれて、C++ バージョンをそのまま使用することがより合理的になってきました。多くの場合、最大のパフォーマンスコスト/メリットは、スタックフレームを設定する必要がないファストパス (fast path) が書かれていることによるものです。キャスティングヘルパーのほとんどがこのカテゴリに該当します。
   1. `JIT_Stelem_Ref` – `JIT_Stelem_Ref_Portable` のわずかに高速なバージョン。

2. 汎用的な正確性。一部のヘルパーは呼び出し先の ABI を興味深い方法で調整したり、「秘密の」引数を操作/解析したり、標準化された C の概念にコンパイルできない他の処理を行います。
   1. `CallDescrWorkerInternal` – VM からマネージド関数への呼び出しをサポートするために必要です。main メソッドはこの方法で呼び出されるため、すべてのアプリケーションに必要です。

   2. `PInvokeImportThunk` – P/Invoke への引数のセットを保存して、ランタイムが実際のターゲットを見つけられるようにするために必要です。秘密の引数の1つも使用します（すべての P/Invoke メソッドで使用）。

   3. `PrecodeFixupThunk` – 秘密の引数を FixupPrecode\* から MethodDesc\* に変換するために必要です。この関数は FixupPrecode のコードサイズを削減するために存在します（多くのマネージドメソッドで使用）。

   4. `ThePreStub` - ランタイムが正しいターゲットメソッドを見つけるか JIT コンパイルできるように、引数のセットをスタックに保存するために必要です。（JIT コンパイルされるメソッドの実行に必要。すべてのマネージドメソッドで使用）

   5. `ThePreStubPatch` – マネージドデバッガがブレークポイントを設置するための信頼性の高いスポットを提供するために存在します。

   6. GC ライトバリア (Write Barriers) – どのメモリが更新されているかについての情報を GC に提供するために使用されます。これらの既存の実装はすべて複雑で、ランタイムがバリアの動作をさまざまな方法で調整するための多くのコントロールがあります。これらの調整の一部は、定数を注入するためにコードを変更したり、さまざまな部分をまるごと置き換えたりすることを含みます。高いパフォーマンスを達成するためにはこれらすべての機能が動作する必要がありますが、シンプルな GC をサポートするブリングアップを達成するには、シングルヒープのワークステーション GC のケースに焦点を当ててください。さらに、`FEATURE_MANUALLY_MANAGED_CARD_BUNDLES` と `FEATURE_USE_SOFTWARE_WRITE_WATCH_FOR_GC_HEAP` はパフォーマンスの必要性に応じて実装できます。

   7. `ComCallPreStub` / `COMToCLRDispatchHelper` / `GenericComCallStub` - 現時点では Windows 以外のプラットフォームには不要です。

   8. `TheUMEntryPrestub` / `UMThunkStub` - Marshal.GetFunctionPointerForDelegate API から生成されたエントリポイントを通じて、非マネージドコードからランタイムに入るために使用されます。

   9. `OnHijackTripThread` - GC やその他の停止を必要とするイベントをサポートするためのスレッド停止 (thread suspension) に必要です。これは製品の非常に初期段階のブリングアップには通常必要ありませんが、ある程度のサイズのアプリケーションには必要です。

   10. `CallEHFunclet` – catch、finally、fault のファンクレット (funclet) を呼び出すために使用されます。動作はファンクレットがどのように実装されているかに固有です。

   11. `CallEHFilterFunclet` – フィルタファンクレット (filter funclet) を呼び出すために使用されます。動作はファンクレットがどのように実装されているかに固有です。

   12. `ResolveWorkerChainLookupAsmStub` / `ResolveWorkerAsmStub` — 仮想スタブディスパッチ (virtual stub dispatch)（インターフェイスおよび一部の仮想メソッドの仮想呼び出しサポート）に使用されます。これらは virtualcallstubcpu.h のロジックと連動して、[仮想スタブディスパッチ](./virtual-stub-dispatch) で説明されているロジックを実装します。

   13. `ProfileEnter` / `ProfileLeave` / `ProfileTailcall` – ICorProfiler インターフェイスを通じて取得された関数のエントリ/イグジットプロファイル関数を呼び出すために使用されます。非常にまれな状況で使用されます。これらの実装は製品化の最終段階まで待つのが合理的です。ほとんどのプロファイラーはこの機能を使用しません。

   14. `JIT_PInvokeBegin` / `JIT_PInvokeEnd` – マネージドランタイム状態からの離脱/エントリ。ReadyToRun で事前コンパイルされた P/Invoke 呼び出しが GC スタベーション (starvation) を引き起こさないようにするために必要です。

   15. `VarargPInvokeStub` / `GenericPInvokeCalliHelper` — calli P/Invoke をサポートするために使用されます。C# 8.0 でこの機能の使用が増加することが期待されます。現在、Unix でのこの機能の使用には手書きの IL が必要です。Windows ではこの機能は C++/CLI で一般的に使用されます。

::: tip 💡 初心者向け補足
「スタブ (stub)」とは、ある処理を別の処理に橋渡しするための小さなコード片のことです。Java でいうところのプロキシやアダプタに近い役割を果たします。たとえば、マネージドコード（C#）からネイティブコード（C/C++）を呼び出す際、引数の変換やレジスタの保存などを行うスタブが挿入されます。「ファンクレット (funclet)」は、例外処理のために分離された小さなコード片で、try-catch-finally の各ブロックに対応する独立した関数のようなものです。
:::

#### cgencpu.h

このヘッダは VM ディレクトリのさまざまなコードからインクルードされます。アーキテクチャ固有の大きな機能セットを提供しており、以下を含みますが、これに限定されません。

1. VM が作成すべきさまざまなデータ構造のサイズなどを指定する、アーキテクチャ固有の定義

2. さまざまな JIT ヘルパーのうち、ポータブルな C++ 実装の代わりにアセンブリ関数に置き換えるべきものを指定する定義

3. プラットフォームの呼び出し規約を記述するために必要な CalleeSavedRegisters、ArgumentRegisters、および FloatArgumentRegisters

4. ClrFlushInstructionCache 関数。アーキテクチャが実際に手動で命令キャッシュ (icache) をフラッシュする必要がない場合、この関数は空です。

5. ジャンプ命令のデコードと操作のためのさまざまな関数。これらはコードがどこに向かうかを予測したり、シンプルなジャンプスタブを生成するために、さまざまなスタブルーチンで使用されます。

6. アーキテクチャの StubLinkerCpu クラス。各アーキテクチャは独自の StubLinkerCpu API サーフェスを定義し、それを使用して VM が生成するコードを生成します。汎用 VM コード（EmitComputedInstantiatingMethodStub、EmitShuffleThunkshared）から複数のアーキテクチャにわたって呼び出される小さな API のセットがあり、さらにアーキテクチャ固有の個々のアセンブリ命令エミッション関数があります。StubLinker は、スタブごとにエミットされるアセンブリ命令のセットが異なる複雑なスタブを生成するために使用されます。

7. さまざまなスタブデータ構造。非常にシンプルなスタブの多くは、バイトストリームのエミッションでは生成されず、代わりに非常に規則的であり、実質的に各スタブで同じ命令で、わずかに異なるデータメンバーを持つだけです。StubLinker メカニズムを使用する代わりに、VM はスタブ全体と関連データを表す構造体を持ち、通常のコンストラクタ呼び出しでマジックナンバーを設定してアセンブリ命令とデータフィールドを埋めます。実行可能であることに加えて、これらのスタブは、ある関数が何であるか、何をしているか、制御フローがどこに向かうかなどを正確に判別するためにパースされることも多くあります。

#### virtualcallstubcpu.h

このヘッダは、仮想スタブディスパッチ (virtual stub dispatch) で使用されるさまざまなスタブの実装を提供するために使用されます。これらのスタブは、[仮想スタブディスパッチ](./virtual-stub-dispatch) で説明されているルックアップスタブ (lookup stub)、リゾルバスタブ (resolver stub)、およびディスパッチスタブ (dispatch stub) です。これらは歴史的な理由と、サイズの理由（ここにはかなり多くのロジックがあります）により、cgencpu.h の残りの部分とは別のファイルで管理されています。

## System.Private.CoreLib

### 初期ブリングアップ

System.Private.CoreLib では、初期ブリングアップに必要な作業はありません。

### 完全なサポート

完全なサポートには、製品の公開 API サーフェスの変更が含まれます。これは GitHub 上のパブリックイシューと API レビューボードとの議論を通じて処理されるプロセスです。

- System.Reflection.ImageFileMachine enum および System.Reflection.ProcessorArchitecture enum、ならびに関連ロジックへのアーキテクチャサポートの追加

- SIMD 命令やその他の非標準 API サーフェスなど、アーキテクチャ固有のイントリンシック (intrinsics) のサポートの追加
