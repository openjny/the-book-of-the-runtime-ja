# 共通言語ランタイム (CLR) 入門

::: info 原文
この章の原文は [Introduction to the Common Language Runtime (CLR)](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/intro-to-clr.md) です。
:::

著者: Vance Morrison ([@vancem](https://github.com/vancem)) - 2007

共通言語ランタイム (Common Language Runtime, CLR) とは何でしょうか？簡潔に言えば：

> 共通言語ランタイム (CLR) とは、幅広いプログラミング言語とそれらの相互運用をサポートするために設計された、完全で高水準な仮想マシンです。

ずいぶんと大げさな表現です。しかし、それだけでは大して意味が分かりません。しかしこの表現は _有用_ です。なぜなら、[CLR][clr] という大規模で複雑なソフトウェアの機能を理解しやすい形にまとめるための第一歩だからです。これにより、ランタイムの大まかな目標と目的を理解するための「上空 10,000 フィート」からの視点を得ることができます。この高い視点で CLR を理解した後であれば、サブコンポーネントをより深く見ても、詳細の中で迷子になる可能性が低くなります。

::: tip 💡 初心者向け補足
「仮想マシン (Virtual Machine)」とは、ソフトウェアによって実現された仮想的なコンピュータのことです。CLR は Java の JVM (Java Virtual Machine) に相当するもので、C# や VB.NET などで書かれたプログラムの実行環境を提供します。プログラムのコードを実行するだけでなく、メモリ管理、セキュリティ、例外処理など、プログラムの実行に必要なあらゆる機能を提供する「裏方のソフトウェア」です。
:::

## CLR：（非常にまれな）完全なプログラミングプラットフォーム

すべてのプログラムは、その実行環境に対して驚くほど多くの依存関係を持っています。最も明らかなのは、プログラムが特定のプログラミング言語で書かれていることですが、それはプログラマがプログラムに織り込む多くの前提の最初の一つに過ぎません。すべての意味のあるプログラムは、マシンの他のリソース（ユーザー入力、ディスクファイル、ネットワーク通信など）とやり取りするための何らかの _ランタイムライブラリ_ を必要とします。プログラムはまた、ネイティブハードウェアが直接実行できる形式に何らかの方法で変換される（インタプリタまたはコンパイルによって）必要があります。プログラムのこれらの依存関係は非常に多く、相互に依存し、多様であるため、プログラミング言語の実装者はほとんど常に他の標準に仕様の策定を委ねます。たとえば、C++ 言語は C++ 実行ファイルのフォーマットを規定していません。代わりに、各 C++ コンパイラは特定のハードウェアアーキテクチャ（例：X86）とオペレーティングシステム環境（例：Windows、Linux、Mac OS）に結びつけられており、それらが実行ファイル形式とロード方法を規定します。したがって、プログラマは「C++ 実行ファイル」ではなく、「Windows X86 実行ファイル」や「Power PC Mac OS 実行ファイル」を作成することになります。

既存のハードウェアやオペレーティングシステムの標準を活用することは通常良いことですが、仕様を既存の標準の抽象化レベルに縛りつけてしまうという欠点があります。たとえば、今日の一般的なオペレーティングシステムにはガベージコレクションヒープ (garbage-collected heap) という概念がありません。したがって、ガベージコレクションを活用するインターフェースを、既存の標準を使って記述する方法がないのです（たとえば、誰が文字列を削除する責任があるかを気にせずに文字列をやり取りするなど）。同様に、一般的な実行ファイル形式はプログラムを実行するための十分な情報は提供しますが、コンパイラが他のバイナリをその実行ファイルにバインドするための十分な情報は提供しません。たとえば、C++ プログラムは一般的に標準ライブラリ（Windows では msvcrt.dll と呼ばれる）を使用し、これには一般的な機能のほとんど（例：printf）が含まれますが、そのライブラリが存在するだけでは十分ではありません。それに対応するヘッダファイル（例：stdio.h）がなければ、プログラマはそのライブラリを使えません。したがって、既存の実行ファイル形式の標準は、実行可能なファイル形式の記述とプログラムを完全にするために必要な他の情報やバイナリの記述の両方に使うことはできません。

CLR は、[非常に完全な仕様][ecma-spec]（ECMA で標準化）を定義することでこれらの問題を解決します。この仕様には、構築とバインドからデプロイと実行まで、プログラムの完全なライフサイクルに必要な詳細が含まれています。したがって、CLR は特に以下を規定しています：

- プログラムが実行するプリミティブな操作を指定するための、独自の命令セット（共通中間言語 (Common Intermediate Language, CIL) と呼ばれる）を持つ GC 対応の仮想マシン。これにより、CLR は特定の種類の CPU に依存しません。
- プログラム宣言（型、フィールド、メソッドなど）のためのリッチなメタデータ (metadata) 表現。これにより、他の実行ファイルを生成するコンパイラは「外部」の機能を呼び出すために必要な情報を得ることができます。
- ファイルにビットをどのように配置するかを正確に指定するファイルフォーマット。これにより、特定のオペレーティングシステムやコンピュータハードウェアに縛られない CLR EXE を適切に語ることができます。
- ロードされたプログラムのライフタイムセマンティクス (lifetime semantics)、ある CLR EXE ファイルが別の CLR EXE を参照するメカニズム、および実行時にランタイムが参照先のファイルを見つける方法に関するルール。
- CLR が提供する機能（ガベージコレクション、例外、ジェネリック型など）を活用して、基本的な機能（整数、文字列、配列、リスト、辞書など）とオペレーティングシステムサービス（ファイル、ネットワーク、ユーザーインタラクションなど）の両方にアクセスを提供するクラスライブラリ。

::: tip 💡 初心者向け補足
CIL (Common Intermediate Language) は、C# や VB.NET などのソースコードがコンパイルされた結果生成される中間言語です。Java のバイトコードに相当します。C# のコードは最初に CIL にコンパイルされ、実行時に JIT (Just-In-Time) コンパイラによってネイティブコード（CPU が直接実行するマシン語）に変換されます。この 2 段階のコンパイルにより、同じ CIL を異なる CPU アーキテクチャ（x86、ARM など）で実行できるという「プラットフォーム非依存性」が実現されます。
:::

## 多言語サポート

これらの詳細をすべて定義し、仕様化し、実装することは非常に大きな取り組みです。だからこそ、CLR のような完全な抽象化は非常にまれなのです。実際、このような合理的に完全な抽象化の大部分は、単一の言語のために構築されました。たとえば、Java ランタイム、Perl インタプリタ、または初期バージョンの Visual Basic ランタイムは、同様に完全な抽象化境界を提供しています。これらの先行する取り組みと CLR を区別するのは、そのマルチランゲージ (多言語) の性質です。Visual Basic（COM オブジェクトモデルを活用しているため）の唯一の例外の可能性を除けば、言語内での体験はしばしば非常に良いものですが、他の言語で書かれたプログラムとの相互運用は非常に困難です。相互運用が困難なのは、これらの言語はオペレーティングシステムが提供するプリミティブを使ってのみ「外国語」と通信できるからです。OS の抽象化レベルが非常に低い（たとえば、オペレーティングシステムにはガベージコレクションヒープの概念がない）ため、不必要に複雑なテクニックが必要になります。共通言語ランタイムを提供することで、CLR は言語間で高水準のコンストラクト（例：GC で管理される構造体）を使って通信できるようにし、相互運用の負担を劇的に軽減しています。

ランタイムが _多くの_ 言語間で共有されるということは、それを十分にサポートするためにより多くのリソースを投入できることを意味します。言語のための優れたデバッガやプロファイラーを構築するのは多大な作業であり、そのため、それらはフル機能の形で最も重要なプログラミング言語に対してのみ存在します。しかし、CLR 上に実装された言語はこのインフラストラクチャを再利用できるため、個々の言語にかかる負担は大幅に軽減されます。おそらくさらに重要なのは、CLR 上に構築された言語は、CLR 上に構築された _すべての_ クラスライブラリに即座にアクセスできることです。この大規模な（そして成長し続ける）、デバッグ済みでサポートされた機能群が、CLR が大成功を収めた大きな理由です。

要するに、ランタイムはプログラムを作成し実行するためにファイルに配置する必要がある正確なビットの完全な仕様です。これらのファイルを実行する仮想マシンは、幅広いプログラミング言語を実装するのに適した高水準なレベルにあります。この仮想マシンと、その仮想マシン上で実行されるクラスライブラリの絶えず増え続ける集合体のことを、私たちは共通言語ランタイム (CLR) と呼びます。

## CLR の主要な目標

CLR がどのようなものか基本的な理解ができたところで、少し戻って、ランタイムが解決しようとしていた問題を理解するのが有益です。非常に高いレベルでは、ランタイムにはたった一つの目標しかありません：

> CLR の目標は、プログラミングを簡単にすることです。

この主張が有用なのは 2 つの理由からです。第一に、ランタイムが進化する際の _非常に_ 有用な指針となります。たとえば、基本的に単純なものだけが簡単になり得るため、ランタイムに **ユーザーに見える** 複雑さを追加することは常に疑いの目で見るべきです。機能のコスト/ベネフィット比よりも重要なのは、その _追加される露出した複雑さ/すべてのシナリオにわたる重み付けされた利点_ の比率です。理想的には、この比率は負（つまり、新しい機能が制限を取り除いたり、既存の特殊ケースを一般化したりすることで複雑さを減少させる）です。しかし、より一般的には、露出する複雑さを最小化し、機能が価値を追加するシナリオの数を最大化することで、この比率を低く保ちます。

この目標がとても重要である第二の理由は、**使いやすさこそが CLR の成功の根本的な理由** だということです。CLR がネイティブコードを書くよりも速いまたは小さいから成功したのではありません（実際、よく書かれたネイティブコードの方がしばしば優れています）。CLR がガベージコレクション、プラットフォーム非依存性、オブジェクト指向プログラミング、バージョニングサポートなどの特定の機能をサポートしているから成功したのでもありません。CLR が成功したのは、それらすべての機能と他の多くの機能が組み合わさって、プログラミングをそうでなかった場合よりも大幅に簡単にしているからです。重要でありながらしばしば見過ごされる使いやすさの機能には以下が含まれます：

1. 簡素化された言語（例：C# や Visual Basic は C++ よりもはるかにシンプルです）
2. クラスライブラリにおけるシンプルさへの献身（例：文字列型は 1 つだけで、それはイミュータブル (immutable) です。これにより、文字列を使用するすべての API が大幅に簡素化されます）
3. クラスライブラリにおける命名の強い一貫性（例：API には完全な単語と一貫した命名規則を使用することが求められます）
4. アプリケーションの作成に必要なツールチェーンの優れたサポート（例：Visual Studio は CLR アプリケーションの構築を非常に簡単にし、Intellisense はアプリケーション作成に適切な型やメソッドを見つけるのを非常に容易にします）

使いやすさへのこの献身（これはユーザーモデルのシンプルさと表裏一体です）こそが、CLR の成功の理由として際立っています。奇妙なことに、最も重要な使いやすさの機能のいくつかは、最も「退屈」なものでもあります。たとえば、どのプログラミング環境でも一貫した命名規則を適用できますが、大規模なクラスライブラリ全体にわたって実際にそれを行うのはかなりの作業です。多くの場合、そのような取り組みは他の目標（既存インターフェースとの互換性の維持など）と衝突したり、重大な物流上の懸念（_非常に_ 大きなコードベース全体でメソッドの名前を変更するコストなど）に直面したりします。このようなときこそ、ランタイムの最も重要な包括的目標を思い出し、その目標に到達するために優先順位を正しくする必要があります。

## CLR の基本機能

ランタイムには多くの機能があるため、以下のようにカテゴリ分けすると有益です：

1. **基本機能** – 他の機能の設計に広範な影響を与える機能。以下が含まれます：
   1. ガベージコレクション (Garbage Collection)
   2. メモリ安全性 (Memory Safety) と型安全性 (Type Safety)
   3. プログラミング言語のための高水準サポート
2. **二次的機能** – 基本機能によって実現される機能で、多くの有用なプログラムでは必要とされない可能性がある機能：
   1. AppDomain によるプログラムの分離
   2. プログラムのセキュリティとサンドボックス化
3. **その他の機能** – すべてのランタイム環境が必要とするが、CLR の基本機能を活用しない機能。これらは完全なプログラミング環境を作成したいという要望の結果です。含まれるものとしては：
   1. バージョニング (Versioning)
   2. デバッグ/プロファイリング (Debugging/Profiling)
   3. 相互運用 (Interoperation)

## CLR ガベージコレクタ (GC)

CLR が提供するすべての機能の中で、ガベージコレクタは特別に注目に値します。ガベージコレクション (GC) とは、自動メモリ回収の一般的な呼称です。ガベージコレクションされるシステムでは、ユーザープログラムはメモリを削除するために特別な演算子を呼び出す必要がなくなります。代わりに、ランタイムがガベージコレクションヒープ内のメモリへのすべての参照を自動的に追跡し、時々それらの参照をたどって、どのメモリがまだプログラムから到達可能かを調べます。それ以外のすべてのメモリは _ガベージ_ であり、新しいアロケーション (allocation) に再利用できます。

::: tip 💡 初心者向け補足
ガベージコレクション (GC) は、Java や Python などの言語でも採用されているメモリ管理方式です。C/C++ ではプログラマが `malloc`/`free` や `new`/`delete` を使って手動でメモリを管理しますが、GC がある環境ではランタイムが「もう使われていないメモリ」を自動的に検出して回収してくれます。これにより、メモリリーク（使い終わったメモリを解放し忘れる）やダングリングポインタ（すでに解放されたメモリを参照してしまう）といったバグを大幅に削減できます。
:::

ガベージコレクションはプログラミングを簡素化するため、素晴らしいユーザー機能です。最も明らかな簡素化は、ほとんどの明示的な delete 操作が不要になることです。delete 操作をなくすことは重要ですが、プログラマにとっての本当の価値はもう少し繊細です：

1. ガベージコレクションはインターフェースの設計を簡素化します。なぜなら、インターフェースを越えて渡されるオブジェクトの削除にどちら側が責任を持つかを注意深く指定する必要がなくなるからです。たとえば、CLR のインターフェースは単に文字列を返します。文字列バッファとその長さを受け取ることはしません。つまり、バッファが小さすぎる場合にどうなるかという複雑さに対処する必要がないのです。したがって、ガベージコレクションにより、ランタイムの _すべての_ インターフェースが、そうでなかった場合よりもシンプルになります。
2. ガベージコレクションは、一般的なユーザーミスのクラス全体を排除します。特定のオブジェクトのライフタイムに関するミスを犯すのは恐ろしいほど簡単で、早すぎる削除（メモリ破損につながる）や遅すぎる削除（到達不可能なメモリリーク）が起こり得ます。一般的なプログラムは文字通り何百万ものオブジェクトを使用するため、エラーの確率は非常に高くなります。さらに、特にオブジェクトが多くの他のオブジェクトから参照されている場合、ライフタイムのバグを追跡することは非常に困難です。このクラスのミスを不可能にすることで、多くの苦労を避けることができます。

しかし、ここで特別に注目するに値するのは、ガベージコレクションの有用性ではありません。もっと重要なのは、それがランタイム自体に課す単純な要件です：

> ガベージコレクションは、GC ヒープへのすべての参照を追跡する必要があります。

これは非常にシンプルな要件ですが、実際にはランタイムに対して深遠な影響を及ぼします。想像できるように、プログラム実行のあらゆる瞬間にオブジェクトへのすべてのポインタがどこにあるかを知ることは、非常に困難です。一つの軽減要因があります。厳密に言えば、この要件は GC が実際に発生する必要があるときにのみ適用されます（したがって、理論的には常にすべての GC 参照がどこにあるか知る必要はなく、GC 時にのみ知ればよい）。しかし実際には、CLR の別の機能のため、この軽減は完全には当てはまりません：

> CLR は、単一のプロセス内で複数の同時実行スレッドをサポートしています。

いつでも、他の実行スレッドがガベージコレクションを必要とするアロケーションを実行する可能性があります。同時実行スレッド間の正確な操作のシーケンスは非決定的です。あるスレッドが GC をトリガーするアロケーションを要求したとき、別のスレッドが正確に何をしているかを知ることはできません。したがって、GC は実質的にいつでも発生し得ます。CLR は別のスレッドの GC 要求に _即座に_ 応答する必要はないため、多少の「余裕」はありますが、実行の _すべての_ ポイントで GC 参照を追跡する必要はないものの、別のスレッドでのアロケーションによって生じる GC の必要性に「タイムリーに」対応できることを保証するのに十分な場所では追跡する _必要があります_ 。

これが意味するのは、CLR は GC ヒープへの _すべての_ 参照を _ほぼ_ 常に追跡する必要があるということです。GC 参照はマシンレジスタ、ローカル変数、静的フィールド (static)、その他のフィールドに存在する可能性があるため、追跡すべきものは非常に多くあります。これらの場所の中で最も問題なのは、マシンレジスタとローカル変数です。なぜなら、それらはユーザーコードの実際の実行と非常に密接に関連しているからです。実質的に、これが意味するのは、GC 参照を操作する _マシンコード_ には追加の要件があるということです：使用するすべての GC 参照を追跡しなければなりません。これは、参照を追跡するための命令を出力するために、コンパイラに追加の作業が必要であることを意味します。

詳しくは、[ガベージコレクタ設計ドキュメント](garbage-collection.md)をご覧ください。

## 「マネージドコード」の概念

自らのライブな GC 参照のすべてを「ほぼ常時」報告できるように追加のブックキーピング（記帳処理）を行うコードは、_マネージドコード_ （CLR によって「管理されている」ため）と呼ばれます。これを行わないコードは _アンマネージドコード_ と呼ばれます。したがって、CLR 以前のすべてのコードはアンマネージドコードであり、特にすべてのオペレーティングシステムのコードはアンマネージドコードです。

::: tip 💡 初心者向け補足
マネージドコード (managed code) とアンマネージドコード (unmanaged code) の区別は .NET の重要な概念です。Java では基本的にすべてのコードが JVM によって管理されますが、.NET ではネイティブの C/C++ コードと共存できます。マネージドコードは CLR が GC 参照の追跡やメモリ安全性の保証を行えるコード、アンマネージドコードはそのような管理の外にあるコード（OS の API や C/C++ で書かれたライブラリなど）です。C# で `unsafe` キーワードを使うときは、マネージドコードの安全性の一部を手放してアンマネージドコードに近い操作を行っていることになります。
:::

### スタックアンワインドの問題

マネージドコードはオペレーティングシステムのサービスを必要とするため、マネージドコードがアンマネージドコードを呼び出す場合が明らかにあります。同様に、オペレーティングシステムが最初にマネージドコードを開始したため、アンマネージドコードがマネージドコードを呼び出す場合もあります。したがって、一般的に、マネージドプログラムを任意の場所で停止すると、コールスタックにはマネージドコードとアンマネージドコードによって作成されたフレームが混在しています。

アンマネージドコードのスタックフレームには、プログラムの実行以上の要件は _ありません_ 。特に、実行時にアンワインド（巻き戻し）して呼び出し元を見つけることができるという要件はありません。これが意味するのは、プログラムを任意の場所で停止し、それがアンマネージドメソッド内にあった場合、一般的に<sup>[1]</sup>呼び出し元が誰であったかを見つける方法がないということです。シンボル情報（PDB ファイル）に格納された追加情報があるため、デバッガでのみこれを行えます。この情報は利用可能であることが保証されていません（デバッガで適切なスタックトレースが得られない場合がある理由です）。これはマネージドコードにとって非常に問題です。なぜなら、アンワインドできないスタックには、実際に報告が必要な GC 参照を含むマネージドコードフレームが含まれている可能性があるからです。

マネージドコードには追加の要件があります：実行中に使用するすべての GC 参照を追跡するだけでなく、呼び出し元にアンワインドできる必要もあります。さらに、マネージドコードからアンマネージドコードへの遷移（またはその逆）がある場合、マネージドコードはアンマネージドコードがスタックフレームをアンワインドする方法を知らないことを補うための追加のブックキーピングも行わなければなりません。実質的に、マネージドコードはマネージドフレームを含むスタックの部分をリンクします。したがって、アンマネージドスタックフレームは追加情報なしにはアンワインドできない可能性がありますが、マネージドコードに対応するスタックの塊を見つけ、それらの塊内のマネージドフレームを列挙することは常に可能です。

[1] 最近のプラットフォーム ABI（アプリケーションバイナリインターフェース (Application Binary Interface)）はこの情報をエンコードするための規約を定義していますが、通常、すべてのコードがそれに従うという厳密な要件はありません。

### マネージドコードの「世界」

結果として、マネージドコードへの遷移とマネージドコードからの遷移のたびに、特別なブックキーピングが必要です。マネージドコードは実質的に、CLR が知らない限り実行が出入りできない独自の「世界」に住んでいます。この 2 つの世界は非常に現実的な意味で互いに異なっています（どの時点でも、コードは _マネージドの世界_ か _アンマネージドの世界_ にいます）。さらに、マネージドコードの実行は CLR フォーマット（[共通中間言語 (CIL)][cil-spec]）で仕様化されており、CLR がネイティブハードウェアで実行するためにそれを変換するため、CLR はその実行が行うことに対して _はるかに_ 多くの制御を持っています。たとえば、CLR はオブジェクトからフィールドを取得することや関数を呼び出すことの意味を変更できます。実際、CLR は MarshalByReference オブジェクトの作成をサポートするために、まさにこれを行っています。これらは通常のローカルオブジェクトのように見えますが、実際には別のマシンに存在している可能性があります。要するに、CLR のマネージドの世界には、後のセクションでより詳しく説明される強力な機能をサポートするために使用できる多数の _実行フック_ があるのです。

さらに、マネージドコードのもう一つの重要な影響があり、それほど明白ではないかもしれません。アンマネージドの世界では、GC ポインタは許可されておらず（追跡できないため）、マネージドコードからアンマネージドコードへの遷移にはブックキーピングコストが伴います。これが意味するのは、マネージドコードから任意のアンマネージド関数を呼び出すことは _可能_ ですが、多くの場合それは快適ではないということです。アンマネージドメソッドは引数や戻り値に GC オブジェクトを使用しないため、それらのアンマネージド関数が作成して使用する「オブジェクト」や「オブジェクトハンドル」は明示的にデアロケート（解放）する必要があります。これは非常に残念なことです。これらの API は例外や継承などの CLR 機能を活用できないため、マネージドコードでインターフェースが設計されていたならどうなるかと比較して、「不一致な」ユーザー体験を持つ傾向があります。

この結果、アンマネージドインターフェースは、マネージドコード開発者に公開される前にほぼ常に _ラップ_ されます。たとえば、ファイルにアクセスする際、オペレーティングシステムが提供する Win32 の CreateFile 関数を使うのではなく、この機能をラップしたマネージドの System.IO.File クラスを使います。実際、アンマネージドの機能がユーザーに直接公開されることは極めてまれです。

このラッピングは一見「悪い」ことのように思えるかもしれません（あまり多くのことをしないように見えるコードが増える）が、実際には非常に多くの価値を追加するため、良いことです。アンマネージドインターフェースを直接公開することは常に _可能_ でした。機能をラップすることを _選んだ_ のです。なぜでしょうか？ランタイムの包括的な目標は **プログラミングを簡単にする** ことであり、通常アンマネージド関数は十分に簡単ではないからです。多くの場合、アンマネージドインターフェースは使いやすさを念頭に置いて設計 _されていません_ が、むしろ完全性のためにチューニングされています。CreateFile や CreateProcess の引数を見て「簡単」だと言える人はまずいないでしょう。幸いなことに、機能はマネージドの世界に入るときに「フェイスリフト（美容整形）」を受けます。そしてこの変身はしばしば非常に「ローテク」な（名前変更、簡素化、機能の整理以上の複雑なものを必要としない）ものですが、それでも非常に有用です。CLR のために作成された非常に重要なドキュメントの一つが、[Framework Design Guidelines][fx-design-guidelines] です。この 800 ページ以上のドキュメントは、新しいマネージドクラスライブラリを作成するためのベストプラクティスを詳述しています。

::: tip 💡 初心者向け補足
.NET の世界では、OS のネイティブ API を直接呼び出す代わりに、`System.IO.File` や `System.Net.Http.HttpClient` のような使いやすいマネージドクラスを通じて機能にアクセスするのが一般的です。Java でも `java.io.File` や `java.net.HttpURLConnection` のように、OS の API を直接呼ばずにラッパークラスを使うのと同じ考え方です。ラッピングにより、一貫した命名規則、例外によるエラー処理、GC によるメモリ管理といった恩恵を受けることができます。
:::

したがって、マネージドコード（CLR と密接に関わるコード）がアンマネージドコードと異なる重要な点は 2 つあることが分かりました：

1. ハイテク：コードは独自の世界に住んでおり、CLR が非常に微細なレベルで（潜在的に個々の命令に至るまで）プログラム実行のほとんどの側面を制御し、実行がマネージドコードに出入りするときに CLR がそれを検出します。これにより、多種多様な有用な機能が実現されます。
2. ローテク：マネージドコードからアンマネージドコードへの遷移コストがあること、およびアンマネージドコードが GC オブジェクトを使用できないことが、ほとんどのアンマネージドコードをマネージドのファサード（外観）でラップする慣行を促進しています。これにより、インターフェースは「フェイスリフト」を受けて簡素化され、一貫した命名規則と設計ガイドラインに準拠することで、アンマネージドの世界にも存在 _し得た_ が実際には存在しなかった一貫性と発見しやすさのレベルを生み出します。

**両方** の特性が、マネージドコードの成功にとって非常に重要です。

## メモリ安全性と型安全性

ガベージコレクタが実現する、目立たないが非常に広範囲に影響する機能の一つがメモリ安全性 (memory safety) です。メモリ安全性の不変条件は非常にシンプルです：プログラムがアロケートされた（かつ解放されていない）メモリにのみアクセスする場合、そのプログラムはメモリ安全です。これは単に、ランダムな場所（より正確には、早期に解放されたメモリ）を指す「ワイルドな」（ダングリング）ポインタを持たないことを意味します。明らかに、メモリ安全性はすべてのプログラムが持つべき性質です。ダングリングポインタは常にバグであり、それらを追跡するのはしばしば非常に困難です。

> メモリ安全性の保証を提供するには、GC は _必要_ です。

ガベージコレクタがメモリ安全性の保証にどのように役立つかはすぐに分かります。ユーザーがメモリを早期に解放する可能性を除去するからです（したがって、適切にアロケートされていないメモリへのアクセスを防ぎます）。それほど明白でないかもしれないのは、メモリ安全性を保証したい（プログラマがメモリ安全でないプログラムを作成することを _不可能_ にしたい）場合、実質的にガベージコレクタを避けられないということです。その理由は、非自明なプログラムは _ヒープスタイル_ の（動的な）メモリアロケーションを必要とし、オブジェクトのライフタイムは本質的に任意のプログラム制御の下にあるためです（高度に制約されたアロケーションプロトコルを持つスタック割り当てメモリや静的割り当てメモリとは異なります）。このような制約のない環境では、特定の明示的な delete 文が正しいかどうかを判定する問題は、プログラム分析では予測不可能になります。実質的に、delete が正しいかどうかを判定する唯一の方法は、実行時にそれをチェックすることです。これはまさに GC が行うこと（メモリがまだ生きているかどうかをチェックすること）です。したがって、ヒープスタイルのメモリアロケーションを必要とするプログラムについて、メモリ安全性を保証したいなら、GC が _必要_ なのです。

::: tip 💡 初心者向け補足
メモリ安全性 (memory safety) と型安全性 (type safety) は、プログラムの信頼性を大幅に向上させる重要な概念です。C/C++ では「ダングリングポインタ」（解放済みメモリへの参照）や「バッファオーバーラン」（配列の範囲外アクセス）といった深刻なバグが発生しやすいですが、.NET の CLR ではこれらを仕組みとして防止しています。Java も同様にメモリ安全なプラットフォームですが、CLR はさらに型安全性（変数が宣言された型と互換性のある操作のみ許可する仕組み）も厳密に保証しています。
:::

GC はメモリ安全性を保証するために必要ですが、十分ではありません。GC はプログラムが配列の末端を超えてインデックスしたり、オブジェクトの末端を超えてフィールドにアクセスしたり（ベースとオフセットの計算を使ってフィールドのアドレスを計算する場合に可能）することを防ぎません。しかし、これらのケースを防ぐことができれば、プログラマがメモリ安全でないプログラムを作成することを本当に不可能にできます。

[共通中間言語 (CIL)][cil-spec] は任意のメモリを取得・設定できる演算子を持っています（したがってメモリ安全性を侵害し得ます）が、以下のメモリ安全な演算子も持っており、CLR はほとんどのプログラミングでそれらの使用を強く推奨しています：

1. フィールド取得演算子 (LDFLD, STFLD, LDFLDA)：名前でフィールドを取得（読み取り）、設定、およびアドレスを取得します。
2. 配列取得演算子 (LDELEM, STELEM, LDELEMA)：インデックスで配列要素を取得、設定、およびアドレスを取得します。すべての配列にはその長さを指定するタグが含まれています。これにより、各アクセスの前に自動的な境界チェックが容易になります。

ユーザーコードでより低レベルの（かつ安全でない） _メモリ取得_ 演算子の代わりにこれらの演算子を使用し、他の安全でない [CIL][cil-spec] 演算子も避ける（たとえば、任意の場所にジャンプできる演算子、つまり不正な場所にジャンプしかねないもの）ことで、メモリ安全ではあるがそれだけのシステムを構築することが想像できます。しかし、CLR はそうしません。代わりに、CLR はより強い不変条件を強制します：型安全性です。

型安全性については、概念的に各メモリアロケーションは型に関連付けられます。メモリ位置に作用するすべての演算子も、概念的にそれらが有効な型でタグ付けされます。型安全性は、特定の型でタグ付けされたメモリが、その型に許可された操作のみを受けることを要求します。これにより、メモリ安全性（ダングリングポインタなし）が保証されるだけでなく、個々の型に対する追加の保証も可能になります。

これらの型固有の保証の中で最も重要なものの一つは、型に関連付けられたアクセシビリティ（可視性）属性（特にフィールドの可視性）が強制されることです。したがって、フィールドが private（その型のメソッドのみがアクセス可能）と宣言されている場合、そのプライバシーはすべての型安全なコードによって確実に尊重されます。たとえば、特定の型がテーブル内の項目数を表す count フィールドを宣言しているとします。count とテーブルのフィールドが private であり、それらを更新するコードだけが両方を一緒に更新すると仮定すれば、count とテーブル内の項目数が実際に同期しているという強い保証が（すべての型安全なコードにわたって）存在します。プログラムについて推論する際、プログラマはそれを知っているかどうかにかかわらず、常に型安全性の概念を使用しています。CLR は型安全性を単なるプログラミング言語/コンパイラの慣習から、実行時に厳密に強制できるものへと昇格させます。

### 検証可能コード - メモリ安全性と型安全性の強制

概念的に、型安全性を強制するには、プログラムが実行するすべての操作が、操作と互換性のある方法で型付けされたメモリ上で動作していることを確認する必要があります。システムはこれをすべて実行時に行うこともできますが、非常に遅くなるでしょう。代わりに、CLR には [CIL][cil-spec] 検証 (verification) の概念があり、[CIL][cil-spec] に対して（コードが実行される前に）静的解析が行われ、ほとんどの操作が確かに型安全であることを確認します。この静的解析が完全にできない場合にのみ、実行時チェックが必要になります。実際には、必要な実行時チェックの数は非常に少なく、以下の操作が含まれます：

1. 基底型へのポインタを派生型へのポインタにキャストすること（逆方向は静的にチェックできます）
2. 配列の境界チェック（メモリ安全性で見たのと同様）
3. ポインタの配列の要素に新しい（ポインタ）値を代入すること。この特定のチェックは、CLR の配列が自由なキャストルールを持っているため（後述）にのみ必要です。

これらのチェックを行う必要性は、ランタイムに対して要件を課すことに注意してください。特に：

1. GC ヒープ内のすべてのメモリはその型でタグ付けされなければなりません（キャスト演算子を実装できるように）。この型情報は実行時に利用可能でなければならず、キャストが有効かどうかを判定するのに十分なリッチさが必要です（たとえば、ランタイムは継承階層を知っている必要があります）。実際、GC ヒープ上のすべてのオブジェクトの最初のフィールドは、その型を表すランタイムデータ構造を指しています。
2. すべての配列はそのサイズも持っている必要があります（境界チェックのため）。
3. 配列は要素型に関する完全な型情報を持っている必要があります。

幸いなことに、最もコストのかかる要件（各ヒープ項目のタグ付け）は、ガベージコレクションをサポートするためにすでに必要だったもの（GC はすべてのオブジェクト内のどのフィールドにスキャンが必要な参照が含まれているかを知る必要がある）なので、型安全性を提供するための追加コストは低いものです。

したがって、コードの [CIL][cil-spec] を検証し、いくつかの実行時チェックを行うことで、CLR は型安全性（およびメモリ安全性）を保証できます。しかしながら、この追加の安全性はプログラミングの柔軟性に代価を課します。CLR には汎用的なメモリ取得演算子がありますが、コードが検証可能であるためには非常に制約された方法でのみ使用できます。特に、すべてのポインタ演算は現在、検証に失敗します。したがって、多くの古典的な C や C++ の慣習は、検証可能コードでは使用できません。代わりに配列を使わなければなりません。これはプログラミングを少し制約しますが、実際にはそれほど悪くなく（配列は非常に強力です）、利点（「厄介な」バグが大幅に減少する）は非常に現実的です。

CLR は検証可能で型安全なコードの使用を強く推奨しています。しかし、（主にアンマネージドコードを扱う際に）検証不可能なプログラミングが必要な時もあります。CLR はこれを許可しますが、ベストプラクティスは、この安全でないコードをできるだけ限定することです。一般的なプログラムは、安全でないコードが必要な部分はごくわずかで、残りは型安全にできます。

## 高水準機能

ガベージコレクションをサポートすることは、ランタイムに深遠な影響を与えました。なぜなら、すべてのコードが追加のブックキーピングをサポートする必要があるからです。型安全性への欲求も深遠な影響を与え、プログラムの記述（[CIL][cil-spec]）がフィールドやメソッドに詳細な型情報を持つ高水準なものであることを要求しました。型安全性への欲求はまた、[CIL][cil-spec] が型安全である他の高水準プログラミング構造をサポートすることを強制します。これらの構造を型安全な方法で表現するにはランタイムのサポートも必要です。これらの高水準機能の中で最も重要な 2 つは、オブジェクト指向プログラミングの 2 つの本質的な要素をサポートするために使用されます：継承 (inheritance) と仮想呼び出しディスパッチ (virtual call dispatch) です。

### オブジェクト指向プログラミング

継承 (inheritance) は機械的な意味では比較的シンプルです。基本的な考え方は、型 `derived` のフィールドが型 `base` のフィールドのスーパーセットであり、`derived` がそのフィールドを `base` のフィールドが最初に来るように配置する場合、`base` のインスタンスへのポインタを期待するコードには `derived` のインスタンスへのポインタを与えることができ、コードは「そのまま動く」ということです。したがって、型 `derived` は `base` から継承していると言われ、`base` が使えるところならどこでも使用できます。同じコードが多くの異なる型に対して使用できるため、コードは _ポリモーフィック_ （多態的）になります。ランタイムはどのような型変換が可能かを知る必要があるため、型安全性を検証できるように継承の指定方法を形式化しなければなりません。

仮想呼び出しディスパッチ (virtual call dispatch) は、継承のポリモーフィズムを一般化します。基底型が派生型によって _オーバーライド_ されるメソッドを宣言できるようにします。型 `base` の変数を使用するコードは、仮想メソッドへの呼び出しが、実行時のオブジェクトの実際の型に基づいて正しいオーバーライドされたメソッドにディスパッチされることを期待できます。このような _実行時ディスパッチロジック_ は、ランタイムの直接サポートなしにプリミティブな [CIL][cil-spec] 命令を使って実装することもできましたが、2 つの重要な欠点がありました：

1. 型安全ではない（ディスパッチテーブルのミスは壊滅的なエラー）
2. 各オブジェクト指向言語がおそらく少しずつ異なる方法で仮想ディスパッチロジックを実装する。結果として、言語間の相互運用性が低下する（ある言語が別の言語で実装された基底型を継承できない）

この理由から、CLR はオブジェクト指向の基本機能に対する直接的なサポートを持っています。可能な限り、CLR はその継承モデルを「言語中立」にしようとしました。つまり、異なる言語が同じ継承階層を共有できるようにしたのです。しかし残念ながら、それが常に可能だったわけではありません。特に、多重継承 (multiple inheritance) は多くの異なる方法で実装できます。CLR はフィールドを持つ型の多重継承をサポートしないことを選択しましたが、フィールドを持たないように制約された特殊な型（インターフェース (interface) と呼ばれる）からの多重継承はサポートしています。

::: tip 💡 初心者向け補足
Java に馴染みのある方にとって、この設計は馴染み深いものでしょう。Java でもクラスの多重継承は許可されず、インターフェースの多重実装のみが許されます。CLR (C#) でも同じアプローチを採用しています。`class MyClass : BaseClass, IInterface1, IInterface2` のように、クラスは 1 つだけ継承し、インターフェースは複数実装できます。これにより、「ダイヤモンド継承問題」（2 つの親クラスから同じメソッドを継承したときの曖昧さ）を回避しつつ、多態的なプログラミングが可能です。
:::

ランタイムがこれらのオブジェクト指向の概念をサポートしている一方で、その使用を要求しているのではないことを念頭に置くことが重要です。継承の概念を持たない言語（たとえば関数型言語）は、これらの機能を単に使用しないだけです。

### 値型（とボクシング）

オブジェクト指向プログラミングの深遠でありながら繊細な側面は、オブジェクト同一性 (object identity) の概念です：（別々のアロケーション呼び出しによって）アロケートされたオブジェクトが、すべてのフィールド値が同一であっても区別できるという概念です。オブジェクト同一性は、オブジェクトが値ではなく参照（ポインタ）によってアクセスされるという事実と強く関連しています。2 つの変数が同じオブジェクトを保持している場合（ポインタが同じメモリを指している）、一方の変数への更新が他方の変数に影響します。

残念ながら、オブジェクト同一性の概念はすべての型に対して良いセマンティックな一致を示すわけではありません。特に、プログラマは一般的に整数をオブジェクトとは考えません。数字の「1」が 2 つの異なる場所でアロケートされた場合、プログラマは一般的にそれら 2 つの項目を等しいと見なしたいと思い、一方のインスタンスへの更新が他方に影響することを確実に望みません。実際、「関数型言語」と呼ばれる広範なクラスのプログラミング言語は、オブジェクト同一性と参照セマンティクスを完全に回避しています。

すべてが（整数を含めて）オブジェクトである「純粋な」オブジェクト指向システムを持つことは可能ですが（Smalltalk-80 がこれを行っています）、効率的な実装を得るためにこの均一性を元に戻すための一定量の実装上の「体操」が必要です。他の言語（Perl、Java、JavaScript）は実用的な見方を採り、一部の型（整数など）を値として、他の型を参照として扱います。CLR も混合モデルを選択しましたが、他とは異なり、ユーザー定義の値型 (value type) を許可しました。

値型の主要な特性は以下の通りです：

1. 値型の各ローカル変数、フィールド、または配列要素は、値のデータの個別のコピーを持ちます。
2. ある変数、フィールド、または配列要素が別のものに代入されると、値がコピーされます。
3. 等価性は常にその変数のデータのみで定義されます（その場所ではなく）。
4. 各値型には、1 つの暗黙的な無名フィールドのみを持つ対応する参照型もあります。これはボックス化 (boxed) された値と呼ばれます。ボックス化された値型は継承に参加でき、オブジェクト同一性を持ちます（ただし、ボックス化された値型のオブジェクト同一性の使用は強く推奨されません）。

::: tip 💡 初心者向け補足
値型 (value type) と参照型 (reference type) の違いは .NET プログラミングの基礎です。`int`、`double`、`bool`、`struct` は値型で、変数に直接データが格納されます。`class`、`string`、配列は参照型で、変数にはヒープ上のオブジェクトへの参照（ポインタ）が格納されます。ボクシング (boxing) とは、値型を参照型に変換する操作です。たとえば `object obj = 42;` と書くと、整数 42 がヒープ上にオブジェクトとしてラップ（ボックス化）されます。Java でも `int` と `Integer` の間で同様のオートボクシング/アンボクシングが行われます。
:::

値型は C（および C++）の struct（または C++ の class）の概念と非常によく似ています。C と同様に値型へのポインタを持つことができますが、ポインタは struct の型とは異なる型です。

### 例外

CLR が直接サポートするもう一つの高水準プログラミング構造が例外 (exception) です。例外はプログラミング言語の機能で、失敗が発生したポイントでプログラマが任意のオブジェクトを _スロー_ できるようにします。オブジェクトがスローされると、ランタイムはコールスタックを検索して、例外を _キャッチ_ できると宣言しているメソッドを探します。そのような catch 宣言が見つかった場合、そのポイントから実行が続行されます。例外の有用性は、呼び出したメソッドが失敗したかどうかをチェックしないという非常に一般的なミスを回避することです。例外がプログラミングミスの回避に役立つ（つまりプログラミングをより簡単にする）ことを考えると、CLR がそれらをサポートするのは驚くべきことではありません。

余談ですが、例外は一般的なエラー（失敗のチェック漏れ）を回避しますが、別のエラー（失敗時にデータ構造を一貫した状態に戻すこと）を防ぐことはできません。これは、例外がキャッチされた後、実行を続行しても追加のエラー（最初の失敗によって引き起こされたもの）が発生しないかどうかを一般的に知ることが困難であることを意味します。これは CLR が将来価値を追加する可能性がある分野です。しかし、現在の実装においても、例外は大きな前進です（さらに進む必要があるだけです）。

### パラメータ化された型（ジェネリクス）

CLR のバージョン 2.0 以前は、唯一のパラメータ化された型は配列でした。その他すべてのコンテナ（ハッシュテーブル、リスト、キューなど）は、汎用的な Object 型で操作していました。`List<ElemT>` や `Dictionary<KeyT, ValueT>` を作成できないことは、値型がコレクションに入る際にボックス化される必要があり、要素の取得時には明示的なキャストが必要であるため、確かにパフォーマンスに悪影響を及ぼしました。しかし、パラメータ化された型を CLR に追加する最も重要な理由はそれではありません。主な理由は、**パラメータ化された型がプログラミングをより簡単にする** ということです。

::: tip 💡 初心者向け補足
ジェネリクス (Generics) は、型をパラメータとして受け取るクラスやメソッドを定義する機能です。Java のジェネリクス (`List<String>`, `Map<String, Integer>`) と同じ概念ですが、実装方法が異なります。Java のジェネリクスは「型消去 (type erasure)」という方式で、コンパイル後に型パラメータ情報が消えますが、CLR のジェネリクスは「具象化 (reification)」という方式で、実行時にも型パラメータ情報が保持されます。そのため、CLR ではジェネリクスの実行時パフォーマンスが向上し、`List<int>` のようにボクシングなしで値型を直接格納できるという利点があります。
:::

その理由は繊細です。その効果を理解する最も簡単な方法は、すべての型が汎用的な Object 型に置き換えられた場合にクラスライブラリがどのように見えるかを想像することです。この効果は、JavaScript のような動的型付け言語で起こることと似ています。そのような世界では、プログラマが不正な（しかし型安全な）プログラムを作成する方法がはるかに多くなります。そのメソッドのパラメータはリストであるべきですか？文字列ですか？整数ですか？上記のいずれかですか？メソッドのシグネチャを見るだけではもはや明白ではありません。さらに悪いことに、メソッドが Object を返す場合、他のどのメソッドがそれをパラメータとして受け入れるでしょうか？一般的なフレームワークには数百のメソッドがあります。すべてが Object 型のパラメータを取る場合、メソッドが実行する操作に対してどの Object インスタンスが有効かを判定することが非常に困難になります。要するに、強い型付けはプログラマがその意図をより明確に表現するのを助け、ツール（例：コンパイラ）がその意図を強制できるようにします。これにより生産性が大幅に向上します。

これらの利点は、型が List や Dictionary に入れられたからといって消えないため、明らかにパラメータ化された型には価値があります。唯一の本当の問題は、パラメータ化された型が、CIL が生成される時点で「コンパイルアウト」される言語固有の機能として考えるのが最適か、この機能がランタイムでファーストクラスのサポートを持つべきかということです。どちらの実装も確かに可能です。CLR チームはファーストクラスのサポートを選択しました。なぜなら、それなしでは、パラメータ化された型は異なる言語によって異なる方法で実装されることになるからです。これは、相互運用性がせいぜい面倒になることを意味します。さらに、パラメータ化された型についてプログラマの意図を表現することは、クラスライブラリの _インターフェース_ で最も価値があります。CLR が公式にパラメータ化された型をサポートしていなければ、クラスライブラリはそれらを使えず、重要なユーザビリティ機能が失われてしまいます。

### データとしてのプログラム（リフレクション API）

CLR の基礎はガベージコレクション、型安全性、高水準言語機能です。これらの基本的な特性により、プログラムの仕様（CIL）はかなり高水準であることを余儀なくされました。このデータが実行時に存在するようになると（C や C++ のプログラムでは真ではないこと）、このリッチなデータをエンドプログラマにも公開することに価値があることが明らかになりました。このアイデアの結果、System.Reflection インターフェース群が作成されました（プログラムが自分自身を見る（反映する、リフレクトする）ことを可能にするため、そのように名付けられました）。このインターフェースにより、プログラムのほぼすべての側面を探索できます（どのような型があるか、継承関係、どのようなメソッドやフィールドが存在するかなど）。実際、失われる情報は非常に少ないため、マネージドコードに対する非常に優れた「デコンパイラ」が可能です（例：[NET Reflector](http://www.red-gate.com/products/reflector/)）。知的財産権の保護を懸念する人々はこの機能に愕然としますが（これは _難読化_ と呼ばれる操作で意図的に情報を破壊することで対処できます）、これが可能であるという事実は、マネージドコードで実行時に利用可能な情報の豊富さの証です。

実行時にプログラムを単に検査するだけでなく、プログラムに対して操作を実行することも可能です（例：メソッドの呼び出し、フィールドの設定など）。そして、おそらく最も強力なのは、実行時にスクラッチからコードを生成すること（System.Reflection.Emit）です。実際、ランタイムライブラリはこの機能を、文字列照合のための特殊なコードの作成（System.Text.RegularExpressions）や、オブジェクトをファイルに保存したりネットワーク経由で送信するための「シリアル化」コードの生成に使用しています。このような機能は以前は単に実現不可能でした（コンパイラを書かなければならなかったでしょう！）が、ランタイムのおかげで、はるかに多くのプログラミング問題の手の届く範囲にあります。

リフレクション機能は確かに強力ですが、その力は注意して使う必要があります。リフレクションは通常、静的にコンパイルされた対応するものよりも大幅に遅くなります。より重要なことに、自己参照システムは本質的に理解が困難です。これは、Reflection や Reflection.Emit のような強力な機能は、その価値が明確で実質的な場合にのみ使用すべきであることを意味します。

## その他の機能

ランタイム機能の最後のグループは、CLR の基本的なアーキテクチャ（GC、型安全性、高水準仕様）とは関係ないが、完全なランタイムシステムの重要なニーズを満たす機能です。

## アンマネージドコードとの相互運用

マネージドコードは、アンマネージドコードで実装された機能を使えなければなりません。相互運用には 2 つの主要な「種類」があります。1 つ目は、単にアンマネージド関数を呼び出す機能です（これは Platform Invoke または P/Invoke と呼ばれます）。アンマネージドコードにも COM（コンポーネントオブジェクトモデル (Component Object Model)）と呼ばれるオブジェクト指向の相互運用モデルがあり、アドホックなメソッド呼び出しよりも構造化されています。COM と CLR の両方がオブジェクトやその他の規約（エラーの処理方法、オブジェクトのライフタイムなど）のモデルを持っているため、特別なサポートがある方が、CLR は COM コードとの相互運用をよりうまく行えます。

## 事前コンパイル (Ahead of Time Compilation)

CLR モデルでは、マネージドコードはネイティブコードではなく CIL として配布されます。ネイティブコードへの変換は実行時に行われます。最適化として、CIL から生成されたネイティブコードは、crossgen と呼ばれるツール（.NET Framework の NGEN ツールに似ています）を使用してファイルに保存できます。これにより、実行時の大量のコンパイル時間が回避され、クラスライブラリが非常に大きいため、非常に重要です。

## スレッディング

CLR は、マネージドコードでマルチスレッドプログラムをサポートする必要性を完全に予見していました。当初から、CLR ライブラリには System.Threading.Thread クラスが含まれており、これはオペレーティングシステムの実行スレッドの概念の 1 対 1 のラッパーです。しかし、OS スレッドのラッパーに過ぎないため、System.Threading.Thread の作成は比較的コストが高く（開始に数ミリ秒かかります）。これは多くの操作には問題ありませんが、あるスタイルのプログラミングでは非常に小さい作業項目（数十ミリ秒しかかからない）を作成します。これはサーバーコード（たとえば、各タスクが 1 つの Web ページを提供するだけ）や、マルチプロセッサを活用しようとするコード（たとえば、マルチコアソートアルゴリズム）で非常に一般的です。これをサポートするため、CLR にはスレッドプール (ThreadPool) という概念があり、ワークアイテムをキューに入れることができます。このスキームでは、CLR が作業を行うために必要なスレッドを作成する責任を負います。CLR は ThreadPool を System.Threading.Threadpool クラスとして直接公開していますが、推奨されるメカニズムは [Task Parallel Library](<https://msdn.microsoft.com/en-us/library/dd460717(v=vs.110).aspx>) の使用です。これは、非常に一般的な形式の並行性制御に対する追加のサポートを提供します。

実装の観点から、ThreadPool の重要なイノベーションは、作業をディスパッチするために最適な数のスレッドが使用されることを保証する責任を負っていることです。CLR は、スループットレートとスレッド数を監視し、スループットを最大化するためにスレッド数を調整するフィードバックシステムを使ってこれを行います。これは非常に優れています。プログラマは主に「並列性の公開」（つまり、ワークアイテムの作成）の観点で考えることができ、（ワークロードとプログラムが実行されるハードウェアに依存する）適切な並列度を決定するというより繊細な問題を考える必要がなくなるからです。

## まとめとリソース

ランタイムは実に多くのことを行います！内部の詳細について話し始めることもなく、ランタイムの機能の _一部_ を説明するだけで多くのページを費やしました。しかし、この入門がその内部の詳細をより深く理解するための有用なフレームワークを提供することを願っています。このフレームワークの基本的な概要は以下の通りです：

- ランタイムはプログラミング言語をサポートするための完全なフレームワークです。
- ランタイムの目標はプログラミングを簡単にすることです。
- ランタイムの基本的な機能は以下の通りです：
  - ガベージコレクション (Garbage Collection)
  - メモリ安全性と型安全性 (Memory and Type Safety)
  - 高水準言語機能のサポート (Support for High-Level Language Features)

## 便利なリンク

- [CLR の MSDN エントリ][clr]
- [CLR の Wikipedia エントリ](http://en.wikipedia.org/wiki/Common_Language_Runtime)
- [共通言語基盤 (CLI) の ECMA 標準][ecma-spec]
- [.NET Framework 設計ガイドライン](http://msdn.microsoft.com/en-us/library/ms229042.aspx)
- [CoreCLR リポジトリのドキュメント](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/README.md)

[clr]: http://msdn.microsoft.com/library/8bs2ecf4.aspx
[ecma-spec]: https://github.com/dotnet/runtime/blob/main/project/dotnet-standards.md
[cil-spec]: http://download.microsoft.com/download/7/3/3/733AD403-90B2-4064-A81E-01035A7FE13C/MS%20Partition%20III.pdf
[fx-design-guidelines]: http://msdn.microsoft.com/en-us/library/ms229042.aspx
