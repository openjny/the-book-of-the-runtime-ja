# スレッディング

::: info 原文
この章の原文は [Threading](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/threading.md) です。
:::

## マネージドスレッドとネイティブスレッド

マネージドコードは「マネージドスレッド」上で実行されます。マネージドスレッドは、オペレーティングシステムが提供するネイティブスレッドとは異なるものです。ネイティブスレッドは物理マシン上でネイティブコードを実行するスレッドですが、マネージドスレッドは CLR の仮想マシン上で実行される仮想的なスレッドです。

JIT コンパイラが「仮想的な」IL 命令を物理マシン上で実行されるネイティブ命令にマッピングするのと同様に、CLR のスレッディング基盤は「仮想的な」マネージドスレッドをオペレーティングシステムが提供するネイティブスレッドにマッピングします。

::: tip 💡 初心者向け補足
マネージドスレッドとネイティブスレッドの関係は、IL コードとネイティブコードの関係に似ています。CLR は OS のスレッドを直接公開せず、独自の抽象化されたスレッドモデルを提供します。これにより、異なる OS 間での移植性やスレッド管理の柔軟性が向上します。
:::

任意の時点において、マネージドスレッドは実行のためにネイティブスレッドに割り当てられている場合もあれば、割り当てられていない場合もあります。たとえば、`new System.Threading.Thread` で作成されたがまだ `System.Threading.Thread.Start` で開始されていないマネージドスレッドは、ネイティブスレッドに割り当てられていないマネージドスレッドです。同様に、原理的にはマネージドスレッドは実行の過程で複数のネイティブスレッド間を移動することも可能ですが、現在の CLR の実装ではこれはサポートされていません。

マネージドコードに公開される Thread のパブリックインターフェースは、意図的に基盤となるネイティブスレッドの詳細を隠蔽しています。その理由は以下の通りです：

- マネージドスレッドは必ずしも単一のネイティブスレッドにマッピングされるわけではない（そもそもネイティブスレッドにマッピングされていない場合もある）
- オペレーティングシステムによってネイティブスレッドの抽象化が異なる
- 原則として、マネージドスレッドは「仮想化」されている

CLR はマネージドスレッドに対して同等の抽象化を提供し、CLR 自身がこれを実装しています。たとえば、OS のスレッドローカルストレージ (TLS) メカニズムは公開せず、代わりにマネージドの「スレッド静的 (thread-static)」変数を提供しています。同様に、ネイティブスレッドの「スレッド ID」は公開せず、OS とは独立に生成される「マネージドスレッド ID」を提供しています。ただし、診断目的で `System.Diagnostics` 名前空間のタイプを通じて基盤となるネイティブスレッドの一部の詳細を取得することは可能です。

マネージドスレッドには、ネイティブスレッドでは通常不要な追加機能が必要です。第一に、マネージドスレッドはスタック上に GC 参照を保持するため、GC が発生するたびに CLR はこれらの参照を列挙（場合によっては変更）できる必要があります。そのために、CLR は各マネージドスレッドを「サスペンド」（すべての GC 参照が特定可能な地点でスレッドを停止）する必要があります。第二に、AppDomain がアンロードされる際、CLR はその AppDomain 内でコードを実行しているスレッドがないことを保証する必要があります。これには、スレッドを強制的にその AppDomain から巻き戻す機能が必要であり、CLR はそのようなスレッドに `ThreadAbortException` を注入することでこれを実現します。

::: tip 💡 初心者向け補足
GC 参照の列挙とは、スレッドのスタックやレジスタ上にあるマネージドオブジェクトへの参照をすべて見つけ出すことです。GC はこの情報を使って、どのオブジェクトがまだ使用中でどのオブジェクトが回収可能かを判断します。スレッドが動いたままだと参照が変化してしまうため、安全な地点でスレッドを一時停止する必要があるのです。
:::

## データ構造

すべてのマネージドスレッドには、[threads.h](https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/threads.h) で定義された関連する Thread オブジェクトがあります。このオブジェクトは、VM がマネージドスレッドについて知る必要があるすべての情報を追跡します。これには、スレッドの現在の GC モードや Frame チェーンなど_必須_のものだけでなく、パフォーマンス上の理由からスレッドごとに割り当てられている多くのもの（一部の高速なアリーナスタイルのアロケータなど）も含まれます。

すべての Thread オブジェクトは ThreadStore（これも [threads.h](https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/threads.h) で定義）に格納されます。ThreadStore は、既知のすべての Thread オブジェクトの単純なリストです。すべてのマネージドスレッドを列挙するには、まず ThreadStoreLock を取得し、次に `ThreadStore::GetAllThreadList` を使用してすべての Thread オブジェクトを列挙します。このリストには、現在ネイティブスレッドに割り当てられていないマネージドスレッド（たとえば、まだ開始されていないもの、またはネイティブスレッドが既に終了したものなど）が含まれている場合があります。

現在ネイティブスレッドに割り当てられている各マネージドスレッドは、そのネイティブスレッドのネイティブスレッドローカルストレージ (TLS) スロットを通じてアクセス可能です。これにより、そのネイティブスレッド上で実行中のコードが、`GetThread()` を通じて対応する Thread オブジェクトを取得できます。

さらに、多くのマネージドスレッドは_マネージド_の Thread オブジェクト（`System.Threading.Thread`）を持っています。これはネイティブの Thread オブジェクトとは別のものです。マネージド Thread オブジェクトは、マネージドコードがスレッドと対話するためのメソッドを提供し、ネイティブ Thread オブジェクトが提供する機能のラッパーとして機能します。現在のマネージド Thread オブジェクトは、マネージドコードから `Thread.CurrentThread` を通じてアクセスできます。

デバッガでは、SOS 拡張コマンドの `!Threads` を使用して ThreadStore 内のすべての Thread オブジェクトを列挙できます。

## スレッドのライフタイム

マネージドスレッドは以下の状況で作成されます：

1. マネージドコードが `System.Threading.Thread` を通じて明示的に CLR に新しいスレッドの作成を依頼する
2. CLR が直接マネージドスレッドを作成する（下記の[「特殊なスレッド」](#特殊なスレッド)を参照）
3. ネイティブコードが、まだマネージドスレッドに関連付けられていないネイティブスレッド上でマネージドコードを呼び出す（「リバース P/Invoke」または COM 相互運用を通じて）
4. マネージドプロセスが開始される（プロセスの Main スレッド上で Main メソッドを呼び出す）

ケース #1 と #2 では、CLR がマネージドスレッドを裏付けるネイティブスレッドを作成する責任を持ちます。ただし、これはスレッドが実際に_開始_されるまで行われません。これらのケースでは、ネイティブスレッドは CLR に「所有」されており、CLR がネイティブスレッドのライフタイムに責任を持ちます。CLR は、自身がスレッドを作成したという事実によって、スレッドの存在を認識しています。

ケース #3 と #4 では、マネージドスレッドの作成前にネイティブスレッドがすでに存在しており、CLR の外部のコードに所有されています。CLR はネイティブスレッドのライフタイムに責任を持ちません。CLR がこれらのスレッドを認識するのは、初めてマネージドコードの呼び出しが試みられたときです。

ネイティブスレッドが終了すると、CLR は `DllMain` 関数を通じて通知を受けます。これは OS の「ローダーロック」内で発生するため、この通知の処理中に（安全に）実行できることはほとんどありません。そのため、マネージドスレッドに関連するデータ構造を破棄する代わりに、スレッドは単に「デッド」としてマークされ、ファイナライザスレッドに実行シグナルを送ります。ファイナライザスレッドは ThreadStore 内のスレッドを走査し、デッドであり_かつ_マネージドコードから到達不能なスレッドを破棄します。

::: tip 💡 初心者向け補足
「ローダーロック」とは、Windows が DLL のロード・アンロードを安全に管理するために使用する内部ロックです。このロック内で複雑な操作を行うとデッドロックの原因になるため、CLR はスレッドの破棄を後回しにして、ファイナライザスレッドに委任しています。
:::

## サスペンション

CLR は GC を実行するために、マネージドオブジェクトへのすべての参照を見つける必要があります。マネージドコードは常に GC ヒープにアクセスし、スタックやレジスタに格納された参照を操作しています。CLR は、すべてのマネージドオブジェクトを安全かつ確実に見つけるために、すべてのマネージドスレッドを停止（ヒープの変更を防止）する必要があります。停止はレジスタやスタック上のライブ参照を検査できる_セーフポイント_でのみ行われます。

別の言い方をすれば、GC ヒープと各スレッドのスタック・レジスタの状態は、複数のスレッドからアクセスされる「共有状態」です。ほとんどの共有状態と同様に、これを保護するために何らかの「ロック」が必要です。マネージドコードはヒープにアクセスする際にこのロックを保持し、セーフポイントでのみロックを解放できます。

CLR はこの「ロック」をスレッドの **GC モード**と呼びます。**コオペラティブモード (cooperative mode)** にあるスレッドはロックを保持しています。GC が進行するためには、スレッドがロックを解放して GC に「協力 (cooperate)」する必要があります。**プリエンプティブモード (preemptive mode)** にあるスレッドはロックを保持していません。そのスレッドは GC ヒープにアクセスしていないことがわかっているため、GC は「先制的 (preemptively)」に進行できます。

::: tip 💡 初心者向け補足
GC モードは、スレッドが GC ヒープを安全に操作できるかどうかを管理する仕組みです。「コオペラティブモード」はスレッドがヒープを使用中であることを示し、「プリエンプティブモード」はスレッドがヒープを使用していないことを示します。GC はすべてのスレッドがプリエンプティブモードになるまで待機してから実行されます。
:::

GC は、すべてのマネージドスレッドがプリエンプティブモード（ロックを保持していない状態）にある場合にのみ進行できます。すべてのマネージドスレッドをプリエンプティブモードに移行させるプロセスは、**GC サスペンション**または**実行エンジン (EE) のサスペンド**として知られています。

このロックの素朴な実装としては、各マネージドスレッドが GC ヒープへのアクセスのたびに実際のロックを取得・解放する方法が考えられます。すると GC は各スレッドのロックの取得を試みるだけで済み、すべてのスレッドのロックを取得できれば GC を安全に実行できます。

しかし、この素朴なアプローチには 2 つの理由で問題があります。第一に、マネージドコードがロックの取得と解放（または GC がロックの取得を試みているかどうかのチェック、いわゆる「GC ポーリング」）に多くの時間を費やすことになります。第二に、JIT がすべてのポイントにおけるスタックとレジスタのレイアウトを記述する「GC 情報」を出力する必要があり、この情報は大量のメモリを消費します。

この素朴なアプローチを改良するため、JIT されたマネージドコードは**部分的に割り込み可能 (partially interruptible)** なコードと**完全に割り込み可能 (fully interruptible)** なコードに分離されます。

- **部分的に割り込み可能なコード**では、セーフポイントは他のメソッドへの呼び出し箇所と、JIT が GC の保留をチェックするコードを出力する明示的な「GC ポーリング」地点のみです。GC 情報はこれらの地点に対してのみ出力すればよいです。
- **完全に割り込み可能なコード**では、すべての命令がセーフポイントであり、JIT はすべての命令に対して GC 情報を出力しますが、GC ポーリングは出力しません。代わりに、完全に割り込み可能なコードは、スレッドのハイジャック（後述）によって「割り込み」を受けることができます。

JIT は、コード品質、GC 情報のサイズ、GC サスペンションのレイテンシの間で最適なトレードオフを見つけるためのヒューリスティクスに基づいて、完全に割り込み可能なコードと部分的に割り込み可能なコードのどちらを出力するかを選択します。

以上を踏まえると、定義すべき 3 つの基本操作があります：コオペラティブモードへの移行、コオペラティブモードからの離脱、EE のサスペンドです。

### コオペラティブモードへの移行

スレッドは `Thread::DisablePreemptiveGC` を呼び出してコオペラティブモードに入ります。これにより、現在のスレッドの「ロック」が以下のように取得されます：

1. GC が進行中（GC がロックを保持している）であれば、GC が完了するまでブロックする
2. スレッドをコオペラティブモードとしてマークする。スレッドがプリエンプティブモードに再移行するまで、GC は進行できない

これら 2 つのステップはアトミックであるかのように進行します。

### プリエンプティブモードへの移行

スレッドは `Thread::EnablePreemptiveGC` を呼び出してプリエンプティブモード（ロックの解放）に入ります。これは単にスレッドをコオペラティブモードではなくなったとマークし、GC スレッドに進行可能になった可能性を通知します。

### EE のサスペンド

GC が必要になると、最初のステップは EE のサスペンドです。これは `GCHeap::SuspendEE` によって以下のように行われます：

1. GC が進行中であることを示すグローバルフラグ (`g_fTrapReturningThreads`) を設定する。コオペラティブモードに入ろうとするスレッドは GC が完了するまでブロックされる
2. 現在コオペラティブモードで実行中のすべてのスレッドを見つける。それぞれのスレッドについて、スレッドをハイジャックしてコオペラティブモードから強制的に離脱させる
3. コオペラティブモードで動作中のスレッドがなくなるまで繰り返す

### ハイジャック

GC サスペンションのためのハイジャックは `Thread::SysSuspendForGC` によって行われます。このメソッドは、現在コオペラティブモードで実行中のマネージドスレッドを「セーフポイント」でコオペラティブモードから強制的に離脱させることを試みます。これは ThreadStore を走査してすべてのマネージドスレッドを列挙し、コオペラティブモードで実行中の各マネージドスレッドについて以下を行います：

1. **ネイティブスレッドのサスペンド。** Win32 の `SuspendThread` API を使用して行われます。この API はスレッドの実行を強制的に停止しますが、停止する地点は実行中のランダムな位置であり、必ずしもセーフポイントではありません。
2. **スレッドの現在の CONTEXT を取得。** `GetThreadContext` を使用して取得します。これは OS の概念であり、CONTEXT はスレッドの現在のレジスタ状態を表します。これにより命令ポインタを検査でき、スレッドが現在実行しているコードの種類を判定できます。
3. **スレッドがまだコオペラティブモードかどうかを再確認。** サスペンドされる前にすでにコオペラティブモードを離脱している可能性があります。その場合、スレッドは危険な状態にあります（任意のネイティブコードを実行している可能性がある）ため、デッドロックを回避するために直ちにスレッドを再開する必要があります。
4. **スレッドがマネージドコードを実行中かどうかを確認。** コオペラティブモードでネイティブ VM コードを実行している可能性があり（下記の「同期」を参照）、その場合はスレッドを直ちに再開する必要があります。
5. **マネージドコード内でスレッドがサスペンドされた場合。** そのコードが完全に割り込み可能か部分的に割り込み可能かに応じて、以下のいずれかが実行されます：
   - **完全に割り込み可能な場合:** 定義上、スレッドはセーフポイントにあるため、任意の地点で GC を実行できます。この地点でスレッドをサスペンドしたままにすることは安全ですが、歴史的な OS のバグにより、先ほど取得した CONTEXT が破損している可能性があるため、これは機能しません。代わりに、スレッドの命令ポインタが上書きされ、より完全な CONTEXT をキャプチャし、コオペラティブモードを離脱し、GC の完了を待ち、コオペラティブモードに再移行し、スレッドの以前の状態を復元するスタブにリダイレクトされます。
   - **部分的に割り込み可能な場合:** 定義上、スレッドはセーフポイントにはありません。しかし、呼び出し元はセーフポイント（メソッドの遷移地点）にあります。この知識を利用して、CLR は最上位のスタックフレームの戻りアドレスを「ハイジャック」し（スタック上のその場所を物理的に上書きし）、完全に割り込み可能なコードで使用されるものと同様のスタブに置き換えます。メソッドが戻る際、実際の呼び出し元ではなくスタブに戻ります（メソッドはその前に JIT が挿入した GC ポーリングを実行し、コオペラティブモードを離脱してハイジャックを元に戻す場合もあります）。

::: tip 💡 初心者向け補足
「ハイジャック」とは、スレッドの実行フローを強制的に変更するテクニックです。スレッドの戻りアドレスや命令ポインタを書き換えて、GC が安全に実行できる状態に持っていきます。この仕組みは高度な低レベル操作であり、OS の API を活用しています。
:::

## ThreadAbort / AppDomain-Unload

AppDomain をアンロードするためには、CLR はその AppDomain 内でスレッドが実行されていないことを保証する必要があります。これを実現するために、すべてのマネージドスレッドが列挙され、アンロード対象の AppDomain に属するスタックフレームを持つスレッドが「中断 (abort)」されます。実行中のスレッドに `ThreadAbortException` が「注入」され、スレッドがバックアウトコードを実行しながら巻き戻され、AppDomain 内で実行されなくなった時点で `ThreadAbortException` は `AppDomainUnloadedException` に変換されます。

`ThreadAbortException` は特殊な種類の例外です。ユーザーコードでキャッチすることはできますが、CLR はユーザーの例外ハンドラの実行後に例外が再スローされることを保証します。そのため `ThreadAbortException` は「キャッチ不可能」と呼ばれることがありますが、厳密にはこれは正確ではありません。

`ThreadAbortException` は通常、マネージドスレッドに「中断中 (aborting)」というビットを設定するだけでスローされます。このビットは CLR の各所（特に、すべての P/Invoke からの戻り時）で確認されるため、多くの場合、このビットを設定するだけでスレッドをタイムリーに中断できます。

しかし、スレッドが長時間実行されるマネージドループを実行している場合など、このビットがチェックされないことがあります。このようなスレッドをより速く中断するために、スレッドは「ハイジャック」され、`ThreadAbortException` を発生させるよう強制されます。このハイジャックは GC サスペンションと同じ方法で行われますが、スレッドがリダイレクトされるスタブは、GC の完了を待つのではなく `ThreadAbortException` を発生させます。

このハイジャックは、`ThreadAbortException` がマネージドコード内の基本的にどの任意の地点でも発生しうることを意味します。このため、マネージドコードが `ThreadAbortException` を正常に処理することは極めて困難です。したがって、AppDomain-Unload 以外の目的でこのメカニズムを使用するのは賢明ではありません。AppDomain-Unload では ThreadAbort によって破損した状態が AppDomain とともにクリーンアップされることが保証されます。

::: tip 💡 初心者向け補足
`ThreadAbortException` は、通常の例外と異なり、catch ブロックで捕捉しても自動的に再スローされる特殊な例外です。これにより、スレッドを確実に終了させることができます。ただし、.NET Core / .NET 5 以降では AppDomain のアンロードはサポートされておらず、`Thread.Abort()` も `PlatformNotSupportedException` をスローします。
:::

## 同期: マネージド

マネージドコードは `System.Threading` 名前空間に集められた多くの同期プリミティブにアクセスできます。これには、Mutex、Event、Semaphore オブジェクトなどのネイティブ OS プリミティブのラッパーに加えて、Barrier や SpinLock などの抽象化が含まれます。しかし、ほとんどのマネージドコードが使用する主要な同期メカニズムは `System.Threading.Monitor` です。これは_任意のマネージドオブジェクト_に対する高性能なロック機能を提供し、さらにロックによって保護された状態の変化を通知するための「条件変数」セマンティクスも提供します。

Monitor は**ハイブリッドロック**として実装されています。スピンロックとカーネルベースのロック (Mutex など) の両方の特性を兼ね備えています。その考え方は、ほとんどのロックは短時間しか保持されないため、カーネルを呼び出してスレッドをブロックするよりも、ロックが解放されるのをスピンウェイト（ビジーウェイト）する方が速いということです。ただし、スピンで CPU サイクルを無駄にしないよう、短期間のスピンの後にロックが取得できなかった場合、実装はカーネルでのブロッキングにフォールバックします。

::: tip 💡 初心者向け補足
ハイブリッドロックは、最初に短時間のスピン（CPU をビジーに回す）を試み、それでもロックを取得できない場合にカーネルモードでの待機に切り替えます。これにより、短時間のロックでは高速に動作し、長時間のロックではCPUリソースを無駄にしません。C# で `lock` ステートメントを使うと、内部的にこの `Monitor` が使用されます。
:::

任意のオブジェクトがロック/条件変数として使用される可能性があるため、すべてのオブジェクトにロック情報を格納する場所が必要です。これは**オブジェクトヘッダー**と**同期ブロック (sync block)** によって行われます。

**オブジェクトヘッダー**は、すべてのマネージドオブジェクトの前に配置されるマシンワードサイズのフィールドです。オブジェクトのハッシュコードの格納など、多くの目的に使用されます。その目的の 1 つがオブジェクトのロック状態の保持です。オブジェクトヘッダーに収まらないほどのオブジェクト単位のデータが必要な場合、「同期ブロック」を作成してオブジェクトを「膨張 (inflate)」させます。

同期ブロックは**同期ブロックテーブル (Sync Block Table)** に格納され、同期ブロックインデックスでアドレスされます。関連する同期ブロックを持つ各オブジェクトは、そのインデックスをオブジェクトのオブジェクトヘッダーに保持しています。

オブジェクトヘッダーと同期ブロックの詳細は [syncblk.h](https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/syncblk.h) / [syncblk.cpp](https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/syncblk.cpp) で定義されています。

オブジェクトヘッダーに空きがある場合、Monitor はオブジェクトのロックを現在保持しているスレッドのマネージドスレッド ID を格納します（ロックを保持しているスレッドがない場合はゼロ (0)）。この場合、ロックの取得はオブジェクトヘッダーのスレッド ID がゼロになるまでスピンウェイトし、その後アトミックに現在のスレッドのマネージドスレッド ID を設定するだけの簡単な操作です。

一定回数のスピンの後にロックを取得できない場合、またはオブジェクトヘッダーがすでに他の目的で使用されている場合は、同期ブロックを作成する必要があります。同期ブロックには、現在のスレッドをブロックするために使用できるイベントなどの追加データが含まれており、スピンを停止してロックの解放を効率的に待機できます。

条件変数として使用されるオブジェクト（`Monitor.Wait` と `Monitor.Pulse` を通じて）は、必要な状態を保持するためのオブジェクトヘッダーの空きが十分にないため、常に膨張させる必要があります。

## 同期: ネイティブ

CLR のネイティブ部分もスレッディングを意識する必要があります。複数のスレッドからマネージドコードによって呼び出されるためです。これにはロック、イベントなどのネイティブ同期メカニズムが必要です。

ITaskHost API を使用すると、ホストはスレッドの作成、破棄、同期など、マネージドスレッディングの多くの側面をオーバーライドできます。ホストがネイティブ同期をオーバーライドできるということは、VM コードは一般的にネイティブ同期プリミティブ（クリティカルセクション、Mutex、Event など）を直接使用できず、これらに対する VM のラッパーを使用する必要があるということです。

さらに、前述のように、GC サスペンションは CLR のほぼすべての側面に影響する特殊な「ロック」です。VM 内のネイティブコードは、GC ヒープオブジェクトを操作する必要がある場合にコオペラティブモードに入ることができ、そのため「GC サスペンションロック」はネイティブ VM コードとマネージドコードの両方で最も重要な同期メカニズムの 1 つとなっています。

ネイティブ VM コードで使用される主要な同期メカニズムは、GC モードと Crst です。

### GC モード

前述のように、すべてのマネージドコードは GC ヒープを操作する可能性があるため、コオペラティブモードで実行されます。一般的に、ネイティブコードはマネージドオブジェクトに触れないため、プリエンプティブモードで実行されます。しかし、VM 内の一部のネイティブコードは GC ヒープにアクセスする必要があり、コオペラティブモードで実行されなければなりません。

ネイティブコードは一般的に GC モードを直接操作せず、2 つのマクロ `GCX_COOP` と `GCX_PREEMP` を使用します。これらは目的のモードに入り、スコープを抜けるときにスレッドを以前のモードに戻すための「ホルダー」を設置します。

`GCX_COOP` は実質的に GC ヒープのロックを取得することを理解することが重要です。スレッドがコオペラティブモードにある間、GC は進行できません。また、ネイティブコードはマネージドコードのようにハイジャックできないため、スレッドは明示的にプリエンプティブモードに戻るまでコオペラティブモードのままです。

したがって、ネイティブコードでコオペラティブモードに入ることは推奨されません。コオペラティブモードに入る必要がある場合は、可能な限り短い時間に抑えるべきです。このモードではスレッドをブロックしてはならず、特にロックを安全に取得することは一般的にできません。

同様に、`GCX_PREEMP` は、スレッドが保持していたロックを_解放_する可能性があります。プリエンプティブモードに入る前に、すべての GC 参照が適切に保護されていることを確認するために細心の注意が必要です。

### Crst

Monitor がマネージドコードに適したロックメカニズムであるのと同様に、Crst は VM コードに適したメカニズムです。Monitor と同様に、Crst はホストと GC モードを意識するハイブリッドロックです。Crst はまた、「ロックレベリング」によるデッドロック回避も実装しています。

一般的に、コオペラティブモード中に Crst を取得することは不正ですが、絶対に必要な場合には例外が認められています。

## 特殊なスレッド

マネージドコードによって作成されるスレッドの管理に加えて、CLR は独自の用途のためにいくつかの「特殊な」スレッドを作成します。

### ファイナライザスレッド

このスレッドはマネージドコードを実行するすべてのプロセスで作成されます。GC がファイナライズ可能なオブジェクトが到達不能になったと判断すると、そのオブジェクトをファイナライゼーションキューに配置します。GC の終了時に、ファイナライザスレッドにシグナルが送られ、キュー内のすべてのファイナライザを処理します。各オブジェクトは 1 つずつデキューされ、そのファイナライザが実行されます。

このスレッドは、CLR 内部のハウスキーピングタスクの実行や、外部イベント（たとえば、メモリ不足の通知。これにより GC はより積極的にコレクションを行います）の通知待機にも使用されます。詳細は `GCHeap::FinalizerThreadStart` を参照してください。

### GC スレッド

「コンカレント」または「サーバー」モードで実行している場合、GC はガベージコレクションの各段階を並行して実行するために、1 つ以上のバックグラウンドスレッドを作成します。これらのスレッドは完全に GC によって所有・管理され、マネージドコードを実行することはありません。

### デバッガスレッド

CLR は各マネージドプロセスで単一のネイティブスレッドを維持しています。このスレッドは、アタッチされたマネージドデバッガに代わって各種タスクを実行します。

### AppDomain-Unload スレッド

このスレッドは AppDomain のアンロードを担当します。これは、アンロードを要求したスレッドではなく、CLR 内部の別スレッドで行われます。その理由は、a) アンロードロジックのためのスタック空間を保証するため、b) 必要に応じて、アンロードを要求したスレッドを AppDomain から巻き戻せるようにするためです。

### ThreadPool スレッド

CLR の ThreadPool は、ユーザーの「ワークアイテム」を実行するためのマネージドスレッドのコレクションを維持します。これらのマネージドスレッドは ThreadPool が所有するネイティブスレッドにバインドされています。ThreadPool はまた、「スレッドインジェクション」、タイマー、「登録済み待機」などの機能を処理するための少数のネイティブスレッドも維持しています。

::: tip 💡 初心者向け補足
ThreadPool は、スレッドの作成と破棄のオーバーヘッドを避けるために、あらかじめスレッドのプールを用意しておく仕組みです。C# では `Task.Run()` や `ThreadPool.QueueUserWorkItem()` を使って、ThreadPool のスレッド上で作業を実行できます。
:::
