# すべての開発者がランタイムの例外について知るべきこと

::: info 原文
この章の原文は [What Every Dev needs to Know About Exceptions in the Runtime](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/exceptions.md) です。
:::

日付: 2005年

CLR における「例外（Exception）」について話す際、重要な区別を念頭に置く必要があります。**マネージド例外（managed exceptions）** は、C# の try/catch/finally などのメカニズムを通じてアプリケーションに公開されるもので、それらを実装するためのすべてのランタイム機構を伴います。一方、**CLR 内部例外（CLR's internal exceptions）** は、ランタイム自体のエラー処理に使用されるものです。ほとんどのランタイム開発者は、マネージド例外モデルの構築と公開方法について考える必要はほとんどありませんが、すべてのランタイム開発者は、ランタイムの実装における例外の使用方法を理解する必要があります。区別を明確にする必要がある場合、この文書ではマネージドアプリケーションがスローまたはキャッチできる「_マネージド例外_」と、ランタイムが独自のエラー処理のために使用する「_CLR 内部例外_」を区別して呼びます。ただし、この文書の大部分は CLR 内部例外についてのものです。

::: tip 💡 初心者向け補足
C# で `try { ... } catch (Exception e) { ... }` と書くとき、これは「マネージド例外」を扱っています。一方、CLR ランタイムの内部（C++ で書かれた部分）でも独自の例外処理の仕組みがあり、これが「CLR 内部例外」です。Java に例えると、マネージド例外は Java アプリケーションの例外処理に、CLR 内部例外は JVM 実装内部のエラー処理に相当します。この章では主に後者について説明しています。
:::

## 例外が重要になる場面

例外はほぼすべての場所で重要です。例外をスローまたはキャッチする関数では特に重要です。なぜなら、そのコードは例外をスローするか、例外をキャッチして適切に処理するために明示的に記述されなければならないからです。たとえ特定の関数自体が例外をスローしなくても、例外をスローする関数を呼び出す可能性が十分にあるため、例外がスローされた場合に正しく動作するように記述する必要があります。**ホルダー（holders）** を適切に使用することで、このようなコードの正確な記述が大幅に容易になります。

## CLR 内部例外が異なる理由

CLR の内部例外は C++ 例外によく似ていますが、完全に同じではありません。CoreCLR は Mac OSX、Linux、BSD、Windows 向けにビルドできます。OS とコンパイラの違いにより、標準的な C++ の try/catch をそのまま使用することはできません。さらに、CLR 内部例外はマネージドの "finally" や "fault" に似た機能を提供します。

いくつかのマクロの助けを借りれば、標準的な C++ とほぼ同じように簡単に記述・読解できる例外処理コードを書くことが可能です。

## 例外のキャッチ

### EX_TRY

基本的なマクロは、もちろん EX_TRY / EX_CATCH / EX_END_CATCH であり、使用時には次のようになります：

```cpp
EX_TRY
  // 関数を呼び出す。例外がスローされるかもしれない。
  Bar();
EX_CATCH
  // ここに来たら、何かが失敗した。
  m_finalDisposition = terminallyHopeless;
  RethrowTransientExceptions();
EX_END_CATCH
```

EX_TRY マクロは、単に try ブロックを導入するもので、C++ の "try" とほぼ同じですが、開き波括弧 "{" も含んでいる点が異なります。

::: tip 💡 初心者向け補足
CLR のランタイムは C++ で書かれていますが、標準的な C++ 例外をそのまま使えません。代わりに `EX_TRY` / `EX_CATCH` というマクロを使います。これは C# の `try` / `catch` に相当しますが、**すべての例外をキャッチする**という点が大きく異なります。特定の例外だけを処理したい場合は、キャッチ後に例外を調べて、関係ないものは再スローする必要があります。
:::

### EX_CATCH

EX_CATCH マクロは、閉じ波括弧 "}" を含めて try ブロックを終了し、catch ブロックを開始します。EX_TRY と同様に、catch ブロックも開き波括弧で始まります。

そしてここが C++ 例外との大きな違いです：CLR 開発者は何をキャッチするかを指定できません。実際のところ、このマクロのセットは、アクセス違反（AV）やマネージド例外を含む非 C++ 例外も含め、**すべてをキャッチ**します。特定の例外やサブセットだけをキャッチしたい場合は、キャッチ後に例外を調べ、関連のないものは何でも再スローする必要があります。

繰り返しますが、EX_CATCH マクロはすべてをキャッチします。この振る舞いは、関数が必要とするものではないことが多いです。次の 2 つのセクションでは、キャッチすべきでない例外への対処方法について詳しく説明します。

### GET_EXCEPTION() と GET_THROWABLE()

では、CLR 開発者はキャッチされたものが何であるかをどのように発見し、どう対処すべきかをどのように判断するのでしょうか？要件に応じていくつかのオプションがあります。

まず、キャッチされた（C++）例外が何であれ、それはグローバルな Exception クラスから派生したクラスのインスタンスとして配信されます。これらの派生クラスの中には、OutOfMemoryException のように明らかなものもあります。EETypeLoadException のようにやや特定のドメイン向けのものもあります。そして、CLRException（任意のマネージド例外を参照する OBJECTHANDLE を持つ）や HRException（HRESULT をラップする）のように、他のシステムの例外のラッパークラスに過ぎないものもあります。元の例外が Exception から派生していなかった場合、マクロはそれを Exception の派生クラスにラップします。（これらの例外はすべてシステム提供であり、よく知られたものです。_新しい例外クラスは、コア実行エンジンチームの関与なしに追加すべきではありません！_）

::: tip 💡 初心者向け補足
ここでの「Exception クラス」は C# の `System.Exception` ではなく、CLR の C++ 実装内部で定義されている C++ クラスです。CLR 内部では、すべての例外がこの基底クラスから派生する形で統一的に扱われます。たとえば、COM から来た HRESULT エラーも `HRException` としてラップされ、マネージド例外は `CLRException` としてラップされます。
:::

次に、CLR 内部例外には常に HRESULT が関連付けられています。HRException のように値が COM ソースから来る場合もありますが、内部エラーや Win32 API の失敗にも HRESULT があります。

最後に、CLR 内部のほぼすべての例外がマネージドコードに返される可能性があるため、内部例外から対応するマネージド例外へのマッピングが存在します。マネージド例外は必ずしも作成されるわけではありませんが、常にそれを取得する可能性があります。

これらの特徴を踏まえて、CLR 開発者はどのように例外を分類するのでしょうか？

多くの場合、例外を分類するために必要なのは、例外に対応する HRESULT だけであり、これは非常に簡単に取得できます：

```cpp
HRESULT hr = GET_EXCEPTION()->GetHR();
```

より詳細な情報は、マネージド例外オブジェクト（managed exception object）を通じて最も便利に入手できることが多いです。そして、例外がマネージドコードに返される場合（すぐに返される場合でも、後でキャッシュされる場合でも）、マネージドオブジェクトが当然必要です。例外オブジェクトの取得も同様に簡単です。もちろん、それはマネージド objectref なので、通常のルールがすべて適用されます：

```cpp
OBJECTREF throwable = NULL;
GCPROTECT_BEGIN(throwable);
// . . .
EX_TRY
    // . . . 例外をスローする可能性のある処理
EX_CATCH
    throwable = GET_THROWABLE();
    RethrowTransientExceptions();
EX_END_CATCH
// . . . throwable を使って何かする
GCPROTECT_END()
```

C++ 例外オブジェクトが直接必要になることもありますが、これは主に例外実装の内部で使用されます。C++ 例外の正確な型が重要な場合、例外を分類する軽量の RTTI（実行時型情報、Runtime Type Information）的な関数のセットがあります。例えば：

```cpp
Exception *pEx = GET_EXCEPTION();
if (pEx->IsType(CLRException::GetType())) {/* ... */}
```

このコードは、例外が CLRException であるか（または CLRException から派生しているか）を判定します。

### RethrowTransientExceptions

上記の例では、"RethrowTransientExceptions" は `EX_CATCH` ブロック内のマクロであり、「例外の処理方針（exception disposition）」と考えられる 3 つの事前定義マクロの 1 つです。以下がそのマクロとその意味です：

- **RethrowTerminalExceptions** — より適切な名前は "RethrowThreadAbort" であり、まさにそれを行うマクロです。
- **RethrowTransientExceptions** — 「一時的（transient）」な例外の最もよい定義は、再試行すれば（おそらく異なるコンテキストで）発生しない可能性のある例外です。以下が一時的な例外の一覧です：
  - COR_E_THREADABORTED
  - COR_E_THREADINTERRUPTED
  - COR_E_THREADSTOP
  - COR_E_APPDOMAINUNLOADED
  - E_OUTOFMEMORY
  - HRESULT_FROM_WIN32(ERROR_COMMITMENT_LIMIT)
  - HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY)
  - (HRESULT)STATUS_NO_MEMORY
  - COR_E_STACKOVERFLOW
  - MSEE_E_ASSEMBLYLOADINPROGRESS

どのマクロを使うか迷った CLR 開発者は、おそらく **RethrowTransientExceptions** を選ぶべきです。

いずれの場合でも、EX_CATCH ブロックを記述する開発者は、どの例外をキャッチすべきかを慎重に考え、それらの例外のみをキャッチする必要があります。そして、マクロはとにかくすべてをキャッチするため、例外をキャッチしない唯一の方法は再スローすることです。

::: tip 💡 初心者向け補足
「一時的（transient）な例外」とは、一時的な状況によって引き起こされる例外のことです。たとえば、メモリ不足（OOM）はその瞬間だけのことかもしれませんし、スレッド中断は特定のタイミングでのみ起こります。これらは再試行すれば成功する可能性があるため、通常は飲み込まず（swallow せず）に再スローするのが適切です。C# の世界でも、`OutOfMemoryException` や `StackOverflowException` を安易にキャッチしてはいけないのと同じ考え方です。
:::

### EX_CATCH_HRESULT

例外に対応する HRESULT のみが必要な場合、特にコードが COM からのインターフェースにある場合、EX_CATCH_HRESULT は EX_CATCH ブロック全体を記述するよりも簡潔です。典型的なケースは次のようになります：

```cpp
HRESULT hr;
EX_TRY
  // コード
EX_CATCH_HRESULT (hr)

return hr;
```

_しかし、非常に魅力的ではありますが、常に正しいわけではありません_。EX_CATCH_HRESULT はすべての例外をキャッチし、HRESULT を保存し、例外を飲み込みます。したがって、その例外の飲み込みが関数に本当に必要なものでない限り、EX_CATCH_HRESULT は適切ではありません。

### EX_RETHROW

上記のとおり、例外マクロはすべての例外をキャッチします。特定の例外だけをキャッチする唯一の方法は、すべてをキャッチし、対象外のものをすべて再スローすることです。したがって、例外がキャッチされ、調べられ、ログに記録されるなどした後に、やはりキャッチすべきでないと判断された場合は、再スローすることができます。EX_RETHROW は同じ例外を再度発生させます。

## 例外をキャッチしない場合

コードの一部が例外をキャッチする必要はないが、何らかのクリーンアップや補償的なアクション（compensating action）を実行する必要がある場合がよくあります。ホルダー（holders）はこのシナリオにまさに適していることが多いですが、常にそうとは限りません。ホルダーでは不十分な場合のために、CLR には "finally" ブロックの 2 つのバリエーションがあります。

### EX_TRY_FOR_FINALLY

コードの終了時に何らかの補償アクションが必要な場合、finally が適切かもしれません。CLR で try/finally を実装するためのマクロのセットがあります：

```cpp
EX_TRY_FOR_FINALLY
  // コード
EX_FINALLY
  // 終了処理またはバックアウトコード
EX_END_FINALLY
```

**重要**：EX_TRY_FOR_FINALLY マクロは C++ EH ではなく SEH（構造化例外処理、Structured Exception Handling）で構築されており、C++ コンパイラは SEH と C++ EH を同じ関数内で混在させることを許可しません。自動デストラクタ（auto-destructor）を持つローカル変数はデストラクタの実行に C++ EH を必要とします。したがって、EX_TRY_FOR_FINALLY を持つ関数では EX_TRY を使用できず、自動デストラクタを持つローカル変数を持つこともできません。

::: tip 💡 初心者向け補足
SEH（構造化例外処理）は Windows 固有の例外処理メカニズムで、C++ の例外処理（C++ EH）とは異なる仕組みです。C++ コンパイラの制約により、1 つの関数内で SEH と C++ EH を混在させることはできません。そのため、`EX_TRY_FOR_FINALLY`（SEH ベース）と `EX_TRY`（C++ EH ベース）を同じ関数に書くことはできません。Java でいえば、`try-finally` と `try-catch` で異なる実装メカニズムが使われているようなものです。
:::

### EX_HOOK

例外がスローされた場合にのみ補償コードが必要になることがよくあります。このような場合、EX_HOOK は EX_FINALLY に似ていますが、"hook" 句は例外がある場合にのみ実行されます。例外は "hook" 句の終了時に自動的に再スローされます。

```cpp
EX_TRY
  // コード
EX_HOOK
  // "code" ブロックから例外がエスケープしたときに実行されるコード
EX_END_HOOK
```

この構造は、単に EX_CATCH と EX_RETHROW を組み合わせるよりもいくらか優れています。なぜなら、スタックオーバーフロー以外の例外は再スローしますが、スタックオーバーフロー例外をキャッチして（スタックをアンワインドして）から、新しいスタックオーバーフロー例外をスローするからです。

## 例外のスロー

CLR で例外をスローすることは、一般的に以下を呼び出すことで行います：

```cpp
COMPlusThrow ( < args > )
```

複数のオーバーロードがありますが、基本的な考え方は例外の「種類（kind）」を COMPlusThrow に渡すことです。「種類」のリストは [rexcep.h](https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/rexcep.h) に対するマクロのセットによって生成され、さまざまな「種類」には kAmbiguousMatchException、kApplicationException などがあります。追加の引数（オーバーロード用）はリソースと置換テキストを指定します。一般的に、正しい「種類」は、類似のエラーを報告する他のコードを探すことで選択されます。

いくつかの事前定義された便利なバリエーションがあります：

::: tip 💡 初心者向け補足
`COMPlusThrow` や `COMPlusThrowOOM` などは、C# で言えば `throw new OutOfMemoryException()` に相当する操作です。特に OOM（メモリ不足）や StackOverflow（スタック溢れ）は特別な扱いが必要です。メモリ不足時に新しい例外オブジェクトを割り当てることはできないため、ランタイムは事前に例外オブジェクトを割り当てておき、それを使い回します。
:::

### COMPlusThrowOOM()

ThrowOutOfMemory() に委譲し、C++ OOM 例外をスローします。これは事前割り当てされた例外をスローし、メモリ不足の状況でメモリ不足例外をスローしようとする問題を回避します。

この例外のマネージド例外オブジェクトを取得する際、ランタイムはまず新しいマネージドオブジェクトの割り当てを試みます<sup>[1]</sup>。それが失敗した場合、事前割り当てされた共有グローバルのメモリ不足例外オブジェクトを返します。

[1] 結局のところ、2GB の配列のリクエストが失敗した場合、単純なオブジェクトなら問題ないかもしれません。

### COMPlusThrowHR(HRESULT theBadHR)

IErrorInfo などを持っている場合のために、いくつかのオーバーロードがあります。特定の HRESULT に対応する例外の種類を判定するための、驚くほど複雑なコードがあります。

### COMPlusThrowWin32() / COMPlusThrowWin32(hr)

基本的に HRESULT_FROM_WIN32(GetLastError()) をスローします。

### COMPlusThrowSO()

スタックオーバーフロー（SO）例外をスローします。これはハード SO ではなく、処理を続行するとハード SO になる可能性がある場合にスローする例外です。

OOM と同様に、事前割り当てされた C++ SO 例外オブジェクトをスローします。OOM と異なり、マネージドオブジェクトを取得する際には、ランタイムは常に事前割り当てされた共有グローバルのスタックオーバーフロー例外オブジェクトを返します。

### COMPlusThrowArgumentNull()

「引数 foo は null であってはならない」例外をスローするヘルパーです。

### COMPlusThrowArgumentOutOfRange()

名前の通りです。

### COMPlusThrowArgumentException()

無効な引数例外のさらに別のバリエーションです。

### COMPlusThrowInvalidCastException(thFrom, thTo)

試みられたキャストの from および to の型の型ハンドル（TypeHandle）が与えられると、ヘルパーはきれいにフォーマットされた例外メッセージを作成します。

### EX_THROW

これは低レベルのスロー構造であり、通常のコードでは一般的に必要ありません。多くの COMPlusThrowXXX 関数は内部的に EX_THROW を使用しており、他の特殊な ThrowXXX 関数も同様です。例外メカニズムの複雑な詳細をできるだけカプセル化するために、EX_THROW の直接使用は最小限に抑えるのが最善です。しかし、上位レベルの Throw 関数がどれも使えない場合は、EX_THROW を使用することは問題ありません。

このマクロは 2 つの引数を取ります：スローする例外の型（C++ Exception クラスの何らかのサブタイプ）と、例外型のコンストラクタへの引数の括弧付きリストです。

## SEH の直接使用

SEH を直接使用することが適切ないくつかの状況があります。特に、SEH はスタックがアンワインドされる前の第 1 パス（first pass）で何らかの処理が必要な場合に唯一の選択肢です。SEH の \_\_try/\_\_except におけるフィルターコードは、例外を処理するかどうかを決定するだけでなく、何でも行うことができます。デバッガー通知（debugger notifications）は、第 1 パスの処理が必要になることがある領域です。

フィルターコードは非常に慎重に記述する必要があります。一般的に、フィルターコードは、あらゆるランダムで、おそらく矛盾した状態に対して準備ができていなければなりません。フィルターは第 1 パスで実行され、デストラクタは第 2 パスで実行されるため、ホルダーはまだ実行されておらず、状態を復元していません。

### PAL_TRY / PAL_EXCEPT, PAL_EXCEPT_FILTER, PAL_FINALLY / PAL_ENDTRY

フィルターが必要な場合、PAL_TRY ファミリーは CLR でフィルターを記述するポータブルな方法です。フィルターは SEH を直接使用するため、同じ関数内の C++ EH とは互換性がなく、関数内にホルダーを置くこともできません。

繰り返しますが、これらの使用はまれであるべきです。

### \_\_try / \_\_except, \_\_finally

CLR でこれらを直接使用する正当な理由はありません。

## 例外と GC モード

`COMPlusThrowXXX()` で例外をスローしても GC モードには影響せず、どのモードでも安全に使用できます。例外が EX_CATCH にアンワインドされて戻る際、スタック上にあったすべてのホルダーがアンワインドされ、リソースが解放され状態がリセットされます。EX_CATCH で実行が再開されるまでに、ホルダーで保護された状態は EX_TRY 時点の状態に復元されています。

## 遷移

マネージドコード、CLR、COM サーバー、その他のネイティブコードを考慮すると、呼び出し規約、メモリ管理、そしてもちろん例外処理メカニズム間の多くの遷移が可能です。例外に関しては、CLR 開発者にとって幸いなことに、これらの遷移のほとんどはランタイムの完全に外側にあるか、自動的に処理されます。CLR 開発者にとって日常的に関係する遷移は 3 つです。それ以外は上級トピックであり、それらについて知る必要がある人々は、自分がそれを知る必要があることを十分に認識しています！

### マネージドコードからランタイムへ

これは "fcall"、"JIT ヘルパー" などです。ランタイムがマネージドコードにエラーを報告する典型的な方法は、マネージド例外を通じてです。したがって、fcall 関数が直接的または間接的にマネージド例外を発生させた場合、それはまったく問題ありません。通常の CLR マネージド例外実装が「正しいこと」を行い、適切なマネージドハンドラーを探します。

一方で、fcall 関数が CLR 内部例外（C++ 例外の 1 つ）をスローする可能性のある処理を行う場合、その例外がマネージドコードに漏れ出すことを許してはなりません。このケースを処理するために、CLR には UnwindAndContinueHandler（UACH）があります。これは C++ EH 例外をキャッチし、マネージド例外として再発生させるためのコードセットです。

マネージドコードから呼び出され、C++ EH 例外をスローする可能性のあるすべてのランタイム関数は、スローするコードを `INSTALL_UNWIND_AND_CONTINUE_HANDLER` / `UNINSTALL_UNWIND_AND_CONTINUE_HANDLER` でラップする必要があります。UACH のインストールには無視できないオーバーヘッドがあるため、すべての場所で使用すべきではありません。パフォーマンスが重要なコードで使用されるテクニックの 1 つは、UACH なしで実行し、例外をスローする直前にのみインストールすることです。

C++ 例外がスローされ、UACH が欠落している場合、典型的な障害は CPFH_RealFirstPassHandler での「GC_TRIGGERS が GC_NOTRIGGER 領域で呼び出された」というコントラクト違反（Contract Violation）になります。これを修正するには、マネージドからランタイムへの遷移を探し、`INSTALL_UNWIND_AND_CONTINUE_HANDLER` を確認してください。

::: tip 💡 初心者向け補足
「遷移（transition）」とは、マネージドコード（C#）とネイティブコード（C++）の間の境界を越えることです。Java でいえば JNI（Java Native Interface）を介したネイティブコード呼び出しに似ています。CLR では、C++ の内部例外がマネージドコード側に漏れ出さないように、UACH（UnwindAndContinueHandler）という仕組みで境界を守っています。UACH が欠落していると、例外処理が正しく動作せず、デバッグが困難なクラッシュの原因になります。
:::

### ランタイムコードからマネージドコードへ

ランタイムからマネージドコードへの遷移には、高度にプラットフォーム依存な要件があります。32 ビット Windows プラットフォームでは、CLR のマネージド例外コードはマネージドコードに入る直前に "COMPlusFrameHandler" がインストールされていることを必要とします。これらの遷移は高度に特殊化されたヘルパー関数によって処理され、適切な例外ハンドラーが設定されます。通常の新しいマネージドコードへの呼び出しが他の方法を使用する可能性は非常に低いです。COMPlusFrameHandler が欠落していた場合、最も可能性の高い影響は、ターゲットのマネージドコード内の例外処理コードが単に実行されないこと — finally ブロックも catch ブロックも実行されないことです。

### ランタイムコードから外部ネイティブコードへ

ランタイムから他のネイティブコード（OS、CRT、その他の DLL）への呼び出しには、特別な注意が必要な場合があります。重要なケースは、外部コードが例外を発生させる可能性がある場合です。これが問題となる理由は、EX_TRY マクロの実装、特に非 Exception を Exception に変換またはラップする方法にあります。C++ EH では、あらゆる例外をキャッチすることが可能ですが（"catch(...)" を使用して）、キャッチされたものに関する情報をすべて失うことになります。Exception\* をキャッチする場合、マクロは例外オブジェクトを調べることができますが、それ以外のものをキャッチする場合、調べるものは何もなく、マクロは実際の例外が何であるかを推測しなければなりません。そして、例外がランタイムの外部から来る場合、マクロは常に誤った推測をします。

現在のソリューションは、外部コードへの呼び出しを「コールアウトフィルター（callout filter）」でラップすることです。フィルターは外部例外をキャッチし、ランタイムの内部例外の 1 つである SEHException に変換します。このフィルターは事前定義されており、使い方は簡単です。ただし、フィルターを使用するということは SEH を使用するということであり、もちろん同じ関数内で C++ EH を使用することはできません。C++ EH を使用する関数にコールアウトフィルターを追加するには、関数を 2 つに分割する必要があります。

コールアウトフィルターを使用するには、次のように書く代わりに：

```cpp
length = SysStringLen(pBSTR);
```

次のように書きます：

```cpp
BOOL OneShot = TRUE;
struct Param {
    BSTR*  pBSTR;
    int length;
};
struct Param param;
param.pBSTR = pBSTR;

PAL_TRY(Param*, pParam, &param)
{
  pParam->length = SysStringLen(pParam->pBSTR);
}
PAL_EXCEPT_FILTER(CallOutFilter, &OneShot)
{
  _ASSERTE(!"CallOutFilter returned EXECUTE_HANDLER.");
}
PAL_ENDTRY;
```

::: tip 💡 初心者向け補足
外部のネイティブコード（Windows API など）を呼び出す際、そのコードが例外を発生させると、CLR の例外マクロは何がスローされたのかを正しく判別できません。これは `catch(...)` ですべてをキャッチしても、例外の型情報が失われるためです。そこで「コールアウトフィルター」というラッパーを使用して、外部例外を CLR が理解できる形（SEHException）に変換します。コードが冗長になりますが、正しい例外情報を保持するために必要です。
:::

例外を発生させる呼び出しにコールアウトフィルターが欠落していると、常にランタイムで誤った例外が報告される結果になります。誤って報告される型は決定的でさえないこともあります。すでにマネージド例外が「飛行中（in flight）」の場合、そのマネージド例外が報告されます。現在の例外がない場合は、OOM が報告されます。チェックビルドでは、コールアウトフィルターの欠落に対して通常アサートが発火します。これらのアサートメッセージには「The runtime may have lost track of the type of an exception（ランタイムが例外の型を見失った可能性があります）」というテキストが含まれます。

## その他

EX_TRY には実際に多くのマクロが関わっています。そのほとんどは、マクロ実装の外部では決して使用すべきではありません。
