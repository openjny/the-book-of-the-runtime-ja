# 共有ジェネリクスの設計

::: info 原文
この章の原文は [Shared Generics Design](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/shared-generics.md) です。
:::

著者: Fadi Hanna - 2019

# はじめに

共有ジェネリクス (Shared Generics) は、さまざまなインスタンス化 (instantiation) を持つジェネリックメソッド (generic method) に対してランタイムが生成するコード量を削減することを目的とした、ランタイムと JIT の連携機能です（ジェネリック型のメソッドとジェネリックメソッドの両方をサポートします）。この機能の基本的な考え方は、特定のインスタンス化においては、生成されるコードがごくわずかな命令を除いてほぼ同一になるため、メモリフットプリントの削減とジェネリックメソッドの JIT コンパイルにかかる時間を短縮するために、ランタイムが単一の特別な正規バージョン (canonical version) のコードを生成し、そのメソッドの互換性のあるすべてのインスタンス化で共用できるようにする、というものです。

::: tip 💡 初心者向け補足
ジェネリクスとは、`List<T>` のように型パラメータを使ってさまざまな型に対応できる仕組みです（Java のジェネリクスに似ています）。たとえば `List<string>` と `List<object>` はどちらも `List<T>` のインスタンス化ですが、参照型同士であればメモリレイアウトが同じなので、同じ機械語コードを使い回すことができます。これが「共有ジェネリクス」の核心です。
:::

### 正規コード生成とジェネリックディクショナリ

以下の C# コードサンプルを考えてみましょう:

```c#
string Method<T>()
{
    return typeof(List<T>).ToString();
}
```

共有ジェネリクスがない場合、`Method<object>` や `Method<string>` のようなインスタンス化のコードは、1 つの命令を除いて同一になります。その命令とは、`List<T>` 型の正しいタイプハンドル (TypeHandle) をロードするものです:

```asm
    mov rcx, type handle of List<string> or List<object>
    call ToString()
    ret
```

共有ジェネリクスでは、正規コード (canonical code) に `List<T>` のタイプハンドルのハードコードされたバージョンは含まれず、代わりにランタイムヘルパー API の呼び出しか、実行中の `Method<T>` のインスタンス化の*ジェネリックディクショナリ (generic dictionary)* からロードすることで、正確なタイプハンドルを検索します。コードは以下のようになります:

```asm
    mov rcx, generic context                                                // Method<string> または Method<object> の MethodDesc
    mov rcx, [rcx + offset of InstantiatedMethodDesc::m_pPerInstInfo]       // これがジェネリックディクショナリ
    mov rcx, [rcx + dictionary slot containing type handle of List<T>]
    call ToString()
    ret
```

この例におけるジェネリックコンテキスト (generic context) は、`Method<object>` または `Method<string>` の `InstantiatedMethodDesc` です。ジェネリックディクショナリ (generic dictionary) とは、共有ジェネリックコードがインスタンス化固有の情報を取得するために使用するデータ構造です。基本的には配列であり、そのエントリにはインスタンス化固有のタイプハンドル (type handle)、メソッドハンドル (method handle)、フィールドハンドル (field handle)、メソッドエントリポイント (method entry point) などが格納されています。MethodTable および `InstantiatedMethodDesc` 構造体の「PerInstInfo」フィールドは、それぞれジェネリック型とジェネリックメソッドのジェネリックディクショナリ構造体を指しています。

この例では、`Method<object>` のジェネリックディクショナリには `List<object>` 型のタイプハンドルを持つスロットが含まれ、`Method<string>` のジェネリックディクショナリには `List<string>` 型のタイプハンドルを持つスロットが含まれます。

この機能は現在、参照型 (reference type) のインスタンス化でのみサポートされています。参照型はすべて同じサイズ・プロパティ・レイアウトなどを持つためです。プリミティブ型 (primitive type) や値型 (value type) のインスタンス化については、ランタイムがインスタンス化ごとに個別のコード本体を生成します。

::: tip 💡 初心者向け補足
参照型（`string`、`object`、ユーザー定義のクラスなど）は、すべてポインタとして表現されるため、メモリ上のサイズが同じです。そのため `Method<string>` と `Method<object>` は同じ機械語コードを共有できます。一方、値型（`int`、`double`、ユーザー定義の構造体など）はそれぞれサイズが異なるため、個別にコードを生成する必要があります。Java ではジェネリクスが型消去 (type erasure) によって実装されますが、.NET ではこのように実行時の型情報を保持しつつ、参照型についてはコード共有で効率化しています。
:::

# レイアウトとアルゴリズム

### 型とメソッドにおけるディクショナリポインタ

特定のジェネリックメソッドが使用するディクショナリは、そのメソッドの `InstantiatedMethodDesc` 構造体の `m_pPerInstInfo` フィールドによってポイントされています。これはジェネリックディクショナリデータの内容への直接ポインタです。

ジェネリック型では、もう 1 段階の間接参照 (indirection) があります。`MethodTable` 構造体の `m_pPerInstInfo` フィールドは、ディクショナリのテーブルへのポインタであり、そのテーブルの各エントリが実際のジェネリックディクショナリデータへのポインタです。これは、型には継承があり、派生ジェネリック型 (derived generic type) は基底型 (base type) のディクショナリを継承するためです。

以下に例を示します:

```c#
class BaseClass<T> { }

class DerivedClass<U> : BaseClass<U> { }

class AnotherDerivedClass : DerivedClass<string> { }
```

これらの各型の MethodTable は以下のようになります:

| **BaseClass[T] の MethodTable**                        |
| ------------------------------------------------------ |
| ...                                                    |
| `m_PerInstInfo`: 以下のディクショナリテーブルを指す    |
| ...                                                    |
| `dictionaryTable[0]`: 以下のディクショナリデータを指す |
| `BaseClass のディクショナリデータ`                     |

| **DerivedClass[U] の MethodTable**                             |
| -------------------------------------------------------------- |
| ...                                                            |
| `m_PerInstInfo`: 以下のディクショナリテーブルを指す            |
| ...                                                            |
| `dictionaryTable[0]`: `BaseClass` のディクショナリデータを指す |
| `dictionaryTable[1]`: 以下のディクショナリデータを指す         |
| `DerivedClass のディクショナリデータ`                          |

| **AnotherDerivedClass の MethodTable**                            |
| ----------------------------------------------------------------- |
| ...                                                               |
| `m_PerInstInfo`: 以下のディクショナリテーブルを指す               |
| ...                                                               |
| `dictionaryTable[0]`: `BaseClass` のディクショナリデータを指す    |
| `dictionaryTable[1]`: `DerivedClass` のディクショナリデータを指す |

`AnotherDerivedClass` はジェネリック型ではないため、独自のディクショナリを持たず、基底型のディクショナリポインタを継承していることに注意してください。

### ディクショナリスロット

前述のとおり、ジェネリックディクショナリはインスタンス化固有の情報を含む複数のスロット (slot) の配列です。あるジェネリック型またはメソッドに対してディクショナリが最初にアロケート (allocate) されると、すべてのスロットは `NULL` で初期化され、コードの実行に応じて遅延的にオンデマンドで設定されます（`Dictionary::PopulateEntry(...)` を参照）。

インスタンス化の最初の N 個のスロット（N は引数の数）には、常にインスタンス化の型引数のタイプハンドルが格納されます（これは一種の最適化でもあります）。それに続くスロットには、インスタンス化に基づく情報が格納されます。

たとえば、先ほどの `Method<string>` の例におけるジェネリックディクショナリの内容は以下のとおりです:

| `Method<string> のディクショナリ`     |
| ------------------------------------- |
| `slot[0]: TypeHandle(string)`         |
| `slot[1]: ディクショナリの合計サイズ` |
| `slot[2]: TypeHandle(List<string>)`   |
| `slot[3]: NULL (未使用)`              |
| `slot[4]: NULL (未使用)`              |

_注: サイズスロットはジェネリックコードによって使用されることはなく、動的ディクショナリ拡張 (dynamic dictionary expansion) 機能の一部です。詳しくは後述します。_

このディクショナリが最初にアロケートされた時点では、`slot[0]` のみが初期化されています。これはインスタンス化の型引数を含んでいるためです（もちろん、動的ディクショナリ拡張機能によりサイズスロットも初期化されます）。残りのスロット（たとえば `slot[2]`）は `NULL` であり、それらを使用するコードパスに到達した場合に遅延的に値が設定されます。

まだ `NULL` であるスロットから情報をロードする際、ジェネリックコードはディクショナリスロットに値を設定するために、以下のランタイムヘルパー関数のいずれかを呼び出します:

- `JIT_GenericHandleClass`: ジェネリック型ディクショナリの値を検索するために使用されます。このヘルパーは、ジェネリック型のすべてのインスタンスメソッドで使用されます。
- `JIT_GenericHandleMethod`: ジェネリックメソッドディクショナリの値を検索するために使用されます。このヘルパーは、すべてのジェネリックメソッド、またはジェネリック型の非ジェネリックな静的メソッドで使用されます。

共有ジェネリックコードを生成する際、JIT は `DictionaryLayout` の実装（[genericdict.cpp](https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/genericdict.cpp)）を利用して、各種検索に使用するスロットと各スロットに含まれる情報の種類を把握します。

::: tip 💡 初心者向け補足
ジェネリックディクショナリは、いわば「型情報の引き出し」のようなものです。`Method<string>` が実行されるとき、JIT が生成した共有コードは「今自分がどの型で動いているか」をこのディクショナリから調べます。たとえば `List<T>` の `T` が何であるかを知りたい場合、ハードコードする代わりにディクショナリのスロットを参照します。必要になるまでスロットを埋めない「遅延設定」方式により、使わない情報のための無駄な初期化を避けています。
:::

### ディクショナリレイアウト

`DictionaryLayout` 構造体は、ディクショナリ検索を実行する際にどのスロットを使用するかを JIT に指示するものです。この `DictionaryLayout` 構造体には、いくつかの重要な特性があります:

- これは、ある型またはメソッドの互換性のあるすべてのインスタンス化で共有されます。言い換えると、ディクショナリレイアウトは型またはメソッドの正規インスタンス化 (canonical instantiation) に関連付けられています。たとえば上記の例では、`Method<object>` と `Method<string>` は互換性のあるインスタンス化であり、それぞれが**個別のディクショナリ**を持っていますが、すべてが正規インスタンス化 `Method<__Canon>` に関連付けられた**同じディクショナリレイアウト**を共有しています。
- ジェネリック型またはメソッドのディクショナリは、そのディクショナリレイアウトと同じ数のスロットを持ちます。注: 歴史的には、動的ディクショナリ拡張機能の導入以前は、ジェネリックディクショナリがレイアウトよりも小さい場合があり、特定の検索ではランタイムヘルパー API を呼び出す必要がありました（スローパス）。

ジェネリック型またはメソッドが最初に作成されたとき、そのディクショナリレイアウトには「未割り当て」のスロットが含まれています。割り当ては、JIT がディクショナリ検索シーケンスを発行する必要があるときに、コード生成の一部として行われます。この割り当ては `DictionaryLayout::FindToken(...)` API の呼び出し中に行われます。スロットが一度割り当てられると、それは特定のシグネチャ (signature) に関連付けられ、そのシグネチャはそのスロットインデックスにおいてすべてのインスタンス化されたディクショナリに格納される値の種類を記述します。

入力シグネチャが与えられた場合、スロットの割り当ては以下のアルゴリズムで実行されます:

```
slot = 0 から開始
ディクショナリレイアウトの各エントリに対して
    If entry.signature != NULL
        If entry.signature == inputSignature
            return slot
        EndIf
    Else
        entry.signature = inputSignature
        return slot
    EndIf
    slot++
EndForeach
```

では、上記のアルゴリズムが実行されたが、同じシグネチャを持つ既存のスロットが見つからず、しかも「未割り当て」のスロットが尽きた場合はどうなるでしょうか？ここで動的ディクショナリ拡張 (dynamic dictionary expansion) が登場し、レイアウトにスロットを追加してリサイズし、このレイアウトに関連付けられたすべてのディクショナリもリサイズします。

# 動的ディクショナリ拡張

### 歴史的背景

動的ディクショナリ拡張機能の導入以前は、ディクショナリレイアウトはバケット (bucket)（固定サイズの `DictionaryLayout` 構造体の連結リスト）で構成されていました。初期レイアウトバケットのサイズは、ジェネリック型についてはヒューリスティクスに基づいて計算された数値に常に固定され、ジェネリックメソッドについては常に 4 スロットに固定されていました。ジェネリック型とメソッドには、検索に使用できる固定サイズのジェネリックディクショナリもありました（「高速検索スロット (fast lookup slots)」とも呼ばれます）。

バケットがエントリで埋まると、新しい `DictionaryLayout` バケットをアロケートしてリストに追加するだけでした。しかし問題は、型やメソッドのジェネリックディクショナリはすでに固定サイズでアロケートされているためリサイズできず、JIT はディクショナリの連結リストに間接参照できる命令の生成をサポートしていなかったことです。この制約により、固定数の値（最初の `DictionaryLayout` バケットのエントリに関連付けられたもの）についてのみジェネリックディクショナリを検索でき、それ以外の検索についてはより低速なランタイムヘルパーを経由する必要がありました。

これは、[ReadyToRun](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/readytorun-overview.md) と階層コンパイル (Tiered Compilation) 技術が導入されるまでは許容できるものでした。ReadyToRun コードによってスロットが急速に割り当てられ、ランタイムがパフォーマンス向上のために特定のメソッドを再 JIT コンパイルしたとき、残りの「高速検索スロット」が見つからない場合があり、より低速なランタイムヘルパーを経由するコードを生成せざるを得ませんでした。これにより一部のシナリオでパフォーマンスが低下し、ReadyToRun コードでは高速検索スロットを使用せず、再 JIT コンパイルされたコード用に予約しておくという決定がなされました。しかし、この決定は ReadyToRun のパフォーマンスを低下させるものでしたが、R2R のスループットよりも再 JIT コンパイルされたコードのスループットをより重視していたため、必要な妥協でした。

このような理由から、動的ディクショナリ拡張機能が導入されました。

::: tip 💡 初心者向け補足
ReadyToRun (R2R) は、アプリケーションの起動時間を短縮するための事前コンパイル (AOT) 技術です。階層コンパイル (Tiered Compilation) は、最初は高速に起動できるコードを生成し、頻繁に実行されるメソッドについてのみ最適化された再コンパイルを行う仕組みです。これらの技術では多くのジェネリックインスタンス化が使用されるため、ディクショナリのスロットが不足しやすく、動的に拡張できる仕組みが必要になりました。
:::

### 説明とアルゴリズム

この機能のコンセプトはシンプルです: ディクショナリレイアウトをバケットの連結リストから、動的に拡張可能な配列に変更する、というものです。シンプルに聞こえますが、実装には細心の注意が必要でした。その理由は以下のとおりです:

- `DictionaryLayout` 構造体だけをリサイズすることはできません。レイアウトのサイズが実際のジェネリックディクショナリのサイズより大きい場合、JIT がディクショナリデータのサイズと一致しない間接参照命令を生成し、アクセス違反 (access violation) を引き起こします。
- 型やメソッドのジェネリックディクショナリだけをリサイズすることもできません:
  - 型の場合、ジェネリックディクショナリは `MethodTable` 構造体の一部であり、マネージドコードで既に使用中のため再アロケートできません。
  - メソッドの場合、ジェネリックディクショナリは `MethodDesc` 構造体の一部ではありませんが、ジェネリックコードで使用中の可能性があります。
  - いずれにしても、同じ型やメソッドに対して複数の MethodTable や MethodDesc を持つことはできないため、再アロケートは選択肢にありません。
- 単一のインスタンス化のジェネリックディクショナリだけをリサイズすることもできません。たとえば上記の例で、`Method<string>` のディクショナリを拡張したいとします。レイアウトのリサイズは、JIT が `Method<__Canon>` に対して生成する共有正規コード (shared canonical code) に影響を与えます。`Method<string>` のディクショナリだけをリサイズした場合、共有ジェネリックコードはそのインスタンス化でのみ動作しますが、`Method<object>` のような他のインスタンス化で使用しようとすると、JIT コンパイルされた命令がディクショナリ構造のサイズと一致しなくなり、アクセス違反を引き起こします。
- ランタイムはマルチスレッド (multi-threaded) であり、これが複雑さをさらに増します。

現在の実装では、シンプルさを保つために、ディクショナリレイアウトと実際のディクショナリの拡張を別々に行っています:

- ディクショナリレイアウトは、空のスロットがなくなったときに拡張されます。[genericdict.cpp](https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/genericdict.cpp) の `DictionaryLayout::FindToken()` の実装を参照してください。
- インスタンス化された型とメソッドのディクショナリは、その型またはメソッドのディクショナリのサイズを超えるスロットの値をコードが読み取ろうとしたときに、遅延的にオンデマンドで拡張されます。これは、前述のヘルパー関数（`JIT_GenericHandleClass` および `JIT_GenericHandleMethod`）の呼び出しを通じて行われます。

ディクショナリアクセスのコード生成は、以下のコードと同等です（JIT コンパイルされたコードと ReadyToRun コードの両方で同じ）:

```c++
void* pMethodDesc = <some value>;		           // インスタンス化されたジェネリックメソッドの入力 MethodDesc
int requiredOffset = <some value>;                 // アクセスする必要のあるオフセット

void* pDictionary = pMethodDesc->m_pPerInstInfo;

// 'requiredOffset' で間接参照する前に、まずディクショナリサイズを確認していることに注目
if (pDictionary[sizeOffset] <= requiredOffset || pDictionary[requiredOffset] == NULL)
    pResult = JIT_GenericHandleMethod(pMethodDesc, <signature>);
else
    pResult = pDictionary[requiredOffset];
```

このサイズチェックは、ディクショナリから値を読み取るたびに無条件に実行されるわけでは**ありません**。もしそうすると、顕著なパフォーマンス低下を引き起こすことになります。ディクショナリレイアウトが最初にアロケートされたとき、初期に割り当てられたスロット数を記録しておき、その初期スロット数を超えるスロットの値を読み取ろうとする場合に**のみ**サイズチェックを実行します。

型とメソッドのディクショナリは、[genericdict.cpp](https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/genericdict.cpp) の `Dictionary::GetTypeDictionaryWithSizeCheck()` および `Dictionary::GetMethodDictionaryWithSizeCheck()` ヘルパー関数によって拡張されます。

型に関して 1 つ注意すべき点は、型は基底型からディクショナリポインタを継承できるということです。これは、あるジェネリック型のジェネリックディクショナリをリサイズした場合、その派生型すべてに新しいディクショナリポインタを伝播させる必要があることを意味します。この伝播も、コードが派生型の MethodTable ポインタを使って `JIT_GenericHandleWorker` ヘルパー関数を呼び出す際に、遅延的に行われます。このヘルパーの中で、基底型のディクショナリポインタが更新されていることがわかった場合、それを派生型にコピーします。

::: tip 💡 初心者向け補足
動的ディクショナリ拡張の設計上、最も困難な点は「すべてのインスタンス化のディクショナリを同期的にリサイズしなければならない」ことです。たとえば `Method<string>` のディクショナリだけを大きくしても、同じ共有コードを使う `Method<object>` のディクショナリが古いサイズのままだとクラッシュしてしまいます。この問題を解決するため、ランタイムはレイアウトの拡張とディクショナリの拡張を分離し、各ディクショナリは実際にアクセスされたタイミングで遅延的にリサイズされます。古いディクショナリは安全のために解放されず、新しいディクショナリが公開された時点で以降のアクセスはすべて新しいほうを使用します。
:::

古いディクショナリはリサイズ後に解放されませんが、新しいディクショナリが MethodTable または MethodDesc に公開されると、ジェネリックコードによるその後のディクショナリ検索はすべて、新しくアロケートされたディクショナリを使用するようになります。古いディクショナリの解放は、特にマルチスレッド環境では極めて複雑になり、有用なメリットもありません。
