# ILC コンパイラアーキテクチャ

::: info 原文
この章の原文は [ILC Compiler Architecture](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/ilc-architecture.md) です。
:::

著者: Michal Strehovsky ([@MichalStrehovsky](https://github.com/MichalStrehovsky)) - 2018

ILC (IL Compiler) は、CIL (Common Intermediate Language、共通中間言語) で書かれたプログラムを、簡素化された CoreCLR ランタイム上で実行するためのターゲット言語または命令セットに変換する事前コンパイラ (Ahead-of-Time Compiler) です。ILC への入力は、C#、VB.NET、F# などの一般的なマネージド言語コンパイラが生成する共通の命令形式です。ILC の出力は、ターゲットプラットフォーム向けのネイティブコード (native code) と、ターゲットランタイム上でそのコードを実行するために必要なデータ構造 (data structures) です。少し大げさに言えば、ILC は C# のための事前ネイティブコンパイラと言えるでしょう。

::: tip 💡 初心者向け補足
従来の .NET では、プログラムは「中間言語 (IL)」という形でコンパイルされ、実行時に JIT (Just-In-Time) コンパイラがネイティブコードに変換していました。ILC はこれとは異なり、**実行前に**ネイティブコードへ変換します。Java で例えると、GraalVM の Native Image に相当する仕組みです。これにより、アプリケーションの起動時間やメモリ使用量が大幅に改善されます。
:::

従来、CIL は「ジャストインタイム」(JIT) でコンパイルされてきました。これは、CIL からターゲットランタイム環境で実行可能な命令セットへの変換が、ネイティブコードが実行の継続に必要になったとき（例えば CIL メソッドの初回呼び出し時）に、必要に応じて行われることを意味します。事前コンパイラ (ahead-of-time compiler) は、コードとデータ構造をプログラムの実行開始前にあらかじめ準備しようとします。コードの実行に必要なネイティブコードとデータ構造が事前に利用可能であることの主な利点は、プログラムの起動時間とワーキングセット (working set) の大幅な改善です。

完全に事前コンパイルされた環境では、コンパイラは実行時に必要となるすべてのコードとデータ構造を生成する責任を負います。つまり、コンパイル後は元の CIL 命令やプログラムメタデータ（メソッド名やそのシグネチャなど）の存在はもはや不要です。留意すべき重要な点として、事前コンパイルは JIT コンパイルを排除するものではありません。アプリケーションの一部は事前コンパイルされ、他の部分は JIT コンパイルまたはインタープリタで実行される、混合実行モードを想像することもできます。ILC はこのような動作モードをサポートする必要があります。なぜなら、どちらにも長所と短所があるからです。私たちは過去にこのような混合実行モードのプロトタイプを作成したことがあります。

## 目標

- CIL をコンパイルし、ターゲットプラットフォーム向けのネイティブコードを生成する
- ランタイムがマネージドネイティブコードを実行するために必要な基本的なデータ構造を生成する（例外処理やメソッドの GC 情報、型を記述するデータ構造、GC レイアウトと vtable、インターフェースディスパッチマップなど）
- 基本クラスライブラリ (base class libraries) がユーザーコードにリッチなマネージド API を提供するために必要なオプションのデータ構造を生成する（リフレクション (reflection)、相互運用 (interop)、テキストのスタックトレース情報、実行時の型ロードなどをサポートするデータ構造）
- プログラム全体の解析ステップからのオプション入力をサポートし、コンパイルに影響を与える
- 実行可能ファイルおよび静的/動的ライブラリの生成をサポートする（フラットな C スタイルのパブリック API サーフェスを持つ）
- 複数のコンパイルモードをサポートする:
  - 単一ファイル出力 (Single-file output):
    - すべての入力アセンブリが ILC によって生成される単一のオブジェクトファイルにマージされる（マネージドアセンブリのマージは ILC 内で行われる）。このモードでは最大限の最適化が可能。
    - 複数のオブジェクトファイルを生成し、プラットフォームリンカによって単一の実行可能ファイルにマージする（マージは ILC の実行後にネイティブリンカで行われる）。このモードではインクリメンタルコンパイルが可能だが、ILC 内の最適化が制限される。
  - マルチファイル出力 (Multi-file output)（1 つ以上の入力アセンブリが 1 つ以上の動的ライブラリを生成し、それらが互いに動的にリンクする）。このモードでは複数の実行可能ファイルや動的ライブラリ間でコード/データの共有が可能だが、多くの最適化が制限される。
- マルチスレッドコンパイル (Multi-threaded compilation)
- ターゲットプラットフォーム向けのネイティブデバッグ情報を生成し、ネイティブデバッガでのデバッグを可能にする
- プラットフォームのネイティブオブジェクトファイル形式（`.obj` ファイルおよび `.o` ファイル）で出力を生成する
- 入力が不完全な場合（例: アセンブリの欠落やアセンブリのバージョン不一致）に定義された動作を持つ

## ILC の構成

ILC はおおまかに 3 つの部分で構成されています: コンパイルドライバ (compilation driver)、コンパイラ (compiler)、そしてコード生成バックエンド (code generation backends) です。

### コンパイルドライバ

コンパイルドライバの役割は、コマンドライン引数を解析し、コンパイラをセットアップし、コンパイルを実行することです。コンパイラのセットアップ作業には `CompilationBuilder` の設定が含まれます。コンパイルビルダは、コマンドライン引数の指示に従ってドライバがコンパイラの各種コンポーネントを設定・構成できるメソッドを公開しています。これらのコンポーネントは、何がコンパイルされるか、どのようにコンパイルが行われるかに影響を与えます。最終的に、ドライバは `Compilation` オブジェクトを構築し、コンパイルの実行、コンパイル結果の検査、出力のディスクへの書き込みなどのメソッドを提供します。

関連クラス: `CompilationBuilder`, `ICompilation`

### コンパイラ

コンパイラは、本ドキュメントの残りの部分で説明する中核コンポーネントです。コンパイルプロセスの実行と、ターゲットランタイムおよびターゲット基本クラスライブラリ向けのデータ構造の生成を担当します。

コンパイラは、何をコンパイルするか、どのデータ構造を生成するか、どのようにコンパイルを行うかについて、ポリシーフリー (policy-free) を維持しようとします。具体的なポリシーは、コンパイルの設定の一部としてコンパイルドライバによって供給されます。

### コード生成バックエンド

ILC は、同一のランタイムをターゲットとする複数のコード生成バックエンド (code generation backends) をサポートするように設計されています。これは、コンパイラ内に共通の部分（何をコンパイルする必要があるかの決定、基盤ランタイム向けのデータ構造の生成）と、ターゲット環境固有の部分があるモデルを意味します。共通の部分（データ構造のレイアウト）はターゲット固有ではありません。ターゲット固有の違いは、「ターゲットは相対ポインタの表現をサポートするか？」といった一般的な質問に限定され、データ構造の基本的な形状はターゲットプラットフォームに関係なく同じです。

ILC は現在、以下のコード生成バックエンドをサポートしています（完成度にばらつきあり）:

- **RyuJIT**: CoreCLR の JIT コンパイラとしても使用されるネイティブコードジェネレータ。このバックエンドは Windows、Linux、macOS、BSD 上の x64、arm64、arm32 をサポートします。
- **LLVM**: LLVM バックエンドは現在、Emscripten と連携して WebAssembly コードを生成するために使用されています。[NativeAOT-LLVM ブランチ](https://github.com/dotnet/runtimelab/tree/feature/NativeAOT-LLVM)にあります。

本ドキュメントでは、すべてのコード生成バックエンドに共通するコンパイラの部分について説明します。

過去に ILC がサポートしていたバックエンドは以下の通りです:

- **CppCodegen**: CIL を C++ コードに変換するポータブルコードジェネレータ。新しい CPU アーキテクチャ用のコードジェネレータを構築する代わりに、プラットフォームがすでに持っている可能性の高い C++ コンパイラに依存することで、プラットフォームへの迅速な対応をサポートします。移植性にはある程度のコストが伴います。このコード生成バックエンドは、現在アーカイブされている CoreRT リポジトリからは[移植されませんでした](https://github.com/dotnet/corert/tree/master/src/ILCompiler.CppCodeGen/src)。

関連プロジェクトファイル: ILCompiler.LLVM.csproj, ILCompiler.RyuJit.csproj

## 依存関係分析

ILC でのコンパイルを駆動する中核概念は、依存関係分析 (dependency analysis) です。依存関係分析は、出力オブジェクトファイルに生成する必要のあるランタイムアーティファクト（メソッドのコード本体やさまざまなデータ構造）のセットを決定するプロセスです。依存関係分析は、各頂点が以下のいずれかであるグラフを構築します:

- 出力ファイルの一部となるアーティファクトを表す（「コンパイル済みメソッド本体」や「実行時に型を記述するデータ構造」など）— これは「オブジェクトノード (object node)」です。
- コンパイルされたプログラムの特定の抽象的な特性を捉える（「プログラムに `Object.GetHashCode` メソッドへの仮想呼び出しが含まれる」など）— これは一般的な「依存関係ノード (dependency node)」です。一般的な依存関係ノードは出力にバイトとして物理的に表れませんが、通常は（推移的に）出力の一部を形成するオブジェクトノードにつながるエッジを持っています。

グラフのエッジは「必要とする (requires)」関係を表します。コンパイルプロセスは、このグラフを構築し、どのノードがグラフの一部であるかを決定することに相当します。

::: tip 💡 初心者向け補足
依存関係分析は、Java のプロファイルガイド最適化 (PGO) や、JavaScript のツリーシェイキング (tree shaking) に似た概念です。プログラムのどの部分が実際に必要かをグラフとして分析し、不要なコードやデータを出力から除外することで、最終的な実行ファイルのサイズを最小化します。
:::

関連クラス: `DependencyNodeCore<>`, `ObjectNode`

関連プロジェクトファイル: ILCompiler.DependencyAnalysisFramework.csproj

### 依存関係の展開プロセス

コンパイルは、依存関係グラフ内のコンパイルルート (compilation roots) と呼ばれるノードのセットから開始されます。ルートはコンパイルドライバによって指定され、通常は `Main()` メソッドを含みますが、正確なルートのセットはコンパイルモードに依存します。例えば、ライブラリをビルドする場合、マルチファイルコンパイルを行う場合、単一ファイルアプリケーションをビルドする場合では、ルートのセットが異なります。

このプロセスは、ルートノードのリストを調べ、それらの依存関係（依存ノード）を確定することから始まります。依存関係がわかると、コンパイルはその依存関係の依存関係の検査に進み、すべての依存関係が判明して依存関係グラフ内でマークされるまで繰り返します。それが完了すると、コンパイルは終了です。

グラフの展開は、コンパイルグループ (compilation group) の範囲内に留まる必要があります。コンパイルグループは、依存関係グラフがどのように展開されるかを制御するコンポーネントです。その役割は、マルチファイルコンパイルと単一ファイルコンパイルを対比することで最もよく説明できます。単一ファイルコンパイルでは、ルートから静的到達可能なすべてのメソッドと型が、それらを定義する入力アセンブリに関係なく依存関係グラフの一部になります。マルチファイルコンパイルでは、コンパイルの一部が異なる作業単位として行われます。現在の作業単位に含まれないメソッドや型は、その依存関係を調査すべきではなく、依存関係グラフの一部であってはなりません。

2 つの抽象化（コンパイルルートと、依存関係グラフの展開方法を制御するクラス）を持つ利点は、コアのコンパイルプロセスが特定のコンパイルモード（例: ライブラリをビルドしているか、マルチファイルコンパイルを行っているか）を全く意識しなくてよいことです。詳細は 2 つの抽象化の背後に完全にラップされており、すべてのロジックを一箇所に保ちながら、新しいコンパイルモードの定義や実験に大きな表現力を与えてくれます。例えば、1 つのメソッドのみをコンパイルする単一メソッドコンパイルモードをサポートしています。このモードはコード生成のトラブルシューティングに便利です。コンパイルドライバは、コンパイラ自体を変更することなく、追加のコンパイルモード（例: 単一の型とそれに関連するすべてのメソッドをコンパイルするモード）を定義できます。

関連クラス: `ICompilationRootProvider`, `CompilationModuleGroup`

### 依存関係の種類

依存関係グラフ分析は、ノード間のいくつかの種類の依存関係を扱うことができます:

- **静的依存関係 (Static dependencies)**: 最も一般的な依存関係です。ノード A が依存関係グラフの一部であり、ノード B を必要とすると宣言した場合、ノード B も依存関係グラフの一部になります。
- **条件付き依存関係 (Conditional dependencies)**: ノード A がノード B に依存することを宣言しますが、それはノード C がグラフの一部である場合に限ります。この場合、ノード B は A と C の両方がグラフに含まれている場合にのみグラフの一部になります。
- **動的依存関係 (Dynamic dependencies)**: これらはシステム内で持つことのコストが高いため、まれにしか使用しません。ノードがグラフ内の他のノードを検査し、それらの存在に基づいてノードを注入できます。ほぼジェネリック仮想メソッド (generic virtual methods) の分析にのみ使用されます。

::: tip 💡 初心者向け補足
3 種類の依存関係を身近な例で説明すると:

- **静的依存関係**: 「A を使うなら B も必要」— npm の通常の依存関係と同じ
- **条件付き依存関係**: 「A を使い、かつ C も使うなら B が必要」— npm の peerDependencies に近い
- **動的依存関係**: 「A がグラフ全体を見て、必要に応じて追加のノードを注入する」— 実行時にしか決まらない柔軟な依存関係
  :::

実際の依存関係グラフがどのように見えるかを示すために、コンパイラ内の仮想メソッド使用追跡に関する（オプションの）最適化の例を見てみましょう:

```csharp
abstract class Foo
{
    public abstract void VirtualMethod();
    public virtual void UnusedVirtualMethod() { }
}

class Bar : Foo
{
    public override void VirtualMethod() { }
    public override void UnusedVirtualMethod() { }
}

class Baz : Foo
{
    public override void VirtualMethod() { }
}

class Program
{
    static int Main()
    {
        Foo f = new Bar();
        f.VirtualMethod();
        return f is Baz ? 0 : 100;
    }
}
```

上記プログラムの依存関係グラフは、おおよそ次のようになります:

![依存関係グラフ](./images/simple-dependency-graph.svg)

四角いノードはメソッド本体を、楕円のノードは型を、破線の四角は仮想メソッドの使用を、点線の楕円は未構築型 (unconstructed type) を表します。
破線のエッジは条件付き依存関係で、条件がラベルに記されています。

- `Program::Main` は `Bar` の新しいインスタンスを作成します。そのために、GC ヒープ上にオブジェクトを割り当て、初期化のためにコンストラクタを呼び出します。したがって、`Bar` 型を表すデータ構造と `Bar` のデフォルトコンストラクタが必要です。続いてメソッドは `VirtualMethod` を呼び出します。この単純な例からは、最終的にどの具体的なメソッド本体が呼び出されるかわかります（頭の中で呼び出しを脱仮想化できます）が、一般的には知ることができないため、`Program::Main` は「`Foo::VirtualMethod` の仮想メソッド使用」にも依存すると言います。プログラムの最後の行は型チェックを行います。型チェックを行うために、生成されたコードは `Baz` 型を表すデータ構造を参照する必要があります。型チェックの興味深い点は、型を完全に記述するデータ構造を生成する必要がなく、キャストが成功するかどうかを判定するのに十分な情報だけあればよいということです。そこで、`Program::Main` は `Baz` の「未構築型データ構造 (unconstructed type data structure)」にも依存すると言います。
- `Bar` 型を表すデータ構造には、2 つの重要な種類の依存関係があります。基底型 (`Foo`) への依存（キャストを機能させるためにそのポインタが必要）と、vtable の内容です。vtable のエントリは条件付きです — 仮想メソッドが一度も呼び出されなければ、vtable に配置する必要はありません。グラフ内の状況の結果として、`Bar::VirtualMethod` のメソッド本体はグラフの一部になりますが、`Bar::UnusedVirtualMethod` はグラフに存在しないノードに条件付けられているため、含まれません。
- `Baz` を表すデータ構造は `Bar` とは少し異なります。これを「未構築型 (unconstructed type)」構造と呼びます。未構築型構造は vtable を含まないため、`Baz` には `Foo::VirtualMethod` の使用に条件付けられた `Baz::VirtualMethod` への仮想メソッド使用依存関係がありません。

条件付き依存関係を使用することで、仮想メソッドが一度も使用されていないため `Foo::UnusedVirtualMethod` と `Bar::UnusedVirtualMethod` のメソッド本体のコンパイルを回避できたことに注目してください。また、`Baz` はプログラム内で一度もインスタンス化されていないため、`Baz::VirtualMethod` の生成も回避しました。`Baz` を表すデータ構造は生成しましたが、そのデータ構造はキャストの目的のみに生成されたため、依存関係グラフに `Baz::VirtualMethod` を引き込むような vtable がありません。

なお、「構築済み (constructed)」と「未構築 (unconstructed)」の型ノードは依存関係グラフ内では別々にモデル化されますが、オブジェクトの書き込み時には 1 つに統合されます。グラフが未構築と構築済みの両方の形式で型を持つ場合、構築済みの形式のみが実行可能ファイルに出力され、未構築の形式を参照している箇所は型の同一性を維持するために構築済みの形式にリダイレクトされます。

関連コンパイラスイッチ: `--dgmllog` は依存関係グラフを XML ファイルにシリアライズします。XML ファイルはグラフ内のすべてのノードをキャプチャしますが、ノードにつながる最初のエッジのみをキャプチャします（最初のエッジを知ることがほとんどの目的に十分です）。`--fulllog` はさらに大きな XML ファイルを生成し、すべてのエッジをキャプチャします。

関連ツール: [依存関係分析ビューア](https://github.com/dotnet/runtime/blob/main/src/coreclr/tools/aot/DependencyGraphViewer/README.md) は、マシン上のすべての ILC コンパイラプロセスが生成する ETW イベントをリッスンし、グラフをインタラクティブに探索できるツールです。

## オブジェクトの書き込み

コンパイルの最終フェーズは、出力の書き込みです。コンパイルの出力はターゲット環境に依存しますが、通常は何らかのオブジェクトファイル (object file) になります。オブジェクトファイルは通常、コードまたはデータのブロブ (blob) とそれらの間のリンク（またはリロケーション (relocations)）、およびシンボル (symbols)（ブロブ内の名前付きの位置）で構成されます。リロケーションはシンボルを指し、そのシンボルは同じオブジェクトファイル内で定義されているか、別のモジュールにあります。

オブジェクトファイル形式はターゲットに非常に固有ですが、コンパイラはオブジェクトデータが関連付けられた依存関係ノードをターゲットに関係なく同じ方法で表現します — `ObjectNode` クラスを使用します。`ObjectNode` クラスは、子クラスがデータの配置先セクション（コード、読み取り専用データ、未初期化データなど）と、最も重要なこととして、データ自体（`GetObjectData` メソッドから返される `ObjectData` クラスで表現）を指定できるようにします。

高レベルでは、オブジェクトライタの役割は、グラフ内でマークされたすべての `ObjectNode` を巡回し、それらのデータ、定義済みシンボル、他のシンボルへのリロケーションを取得して、オブジェクトファイルに格納することです。

NativeAOT コンパイラには複数のオブジェクトライタが含まれています:

- LLVM ベースのネイティブオブジェクトライタ — Windows PE、Linux ELF、macOS Mach-O ファイル形式を生成可能
- WebAssembly 向けの LLVM ベースのネイティブオブジェクトライタ
- CoreCLR 向けの Ready to Run 形式で、CIL とネイティブの混合実行可能ファイルを生成する Ready to Run オブジェクトライタ

関連コマンドライン引数: `--map` はオブジェクトファイルに出力されたすべてのオブジェクトノードのマップを生成します。

## 最適化のプラグイン可能性

完全に事前コンパイルされた環境の利点は、コンパイラがコンパイル対象のコードについてクローズドワールド仮定 (closed world assumptions) を行えることです。例えば、実行時に任意の CIL をロードする機能がない場合（`Assembly.Load` や `Reflection.Emit` を通じて）、コンパイラはインターフェースを実装する型が 1 つだけであることを確認すると、プログラム内のすべてのインターフェース呼び出しを直接呼び出しに置き換え、それによって可能になるインライン化 (inlining) などの追加の最適化を適用できます。ターゲット環境が動的コードを許可している場合、このような最適化は無効です。

::: tip 💡 初心者向け補足
クローズドワールド仮定 (closed world assumption) とは、「コンパイル時にプログラムのすべてのコードが分かっている」という前提です。この前提があると、例えばインターフェースの実装が 1 つしかなければ、仮想呼び出し (virtual call) を直接呼び出しに変換して高速化できます。Java の HotSpot JVM でも実行時に類似の最適化（モノモーフィックインライン化など）が行われますが、ILC ではこれをコンパイル時に確定できるのが強みです。
:::

コンパイラはこのような最適化を可能にする構造を持っていますが、最適化をいつ適用すべきかについてはポリシーフリーを維持します。これにより、完全な AOT コンパイルと混合（JIT/インタープリタ）コード実行戦略の両方をサポートできます。ポリシーは常に抽象クラスまたはインターフェースにキャプチャされ、その実装はコンパイルドライバによって選択され、コンパイルビルダに渡されます。これにより高度な柔軟性が得られ、最適化が適用可能な条件をコンパイラにハードコーディングすることなく、コンパイルドライバからコンパイルに大きな影響力を持たせることができます。

このようなポリシーの例として、仮想メソッドテーブル (vtable) 生成ポリシーがあります。コンパイラは vtable を 2 つの方法で構築できます: 遅延的 (lazily) に、または型のメタデータを読み取って型のメソッドリストに存在するすべての新しい仮想メソッドの vtable スロットを生成する方法です。前述の依存関係分析のサンプルグラフは、プログラムが動作するために生成が必要な vtable スロットと仮想メソッド本体を追跡するために条件付き依存関係をどのように使用できるかを説明していました。これはクローズドワールド仮定を必要とする最適化の例です。ポリシーは `VTableSliceProvider` クラスにキャプチャされ、ドライバが型ごとに vtable 生成ポリシーを選択できるようにします。これにより、コンパイルドライバは最適化をいつ許可するかを細かく制御できます（例: JIT が存在する場合でも、AOT コンパイルされていないプログラム部分やリフレクションからアクセス不可/不可視な型に対しては、この最適化を許可できます）。

ドライバで設定可能なポリシーは広範な領域にわたります: リフレクションメタデータの生成、脱仮想化 (devirtualization)、vtable の生成、`Exception.ToString` のスタックトレースメタデータの生成、デバッグ情報の生成、メソッド本体の IL ソースなど。

## IL スキャン

ILC のもう 1 つのコンポーネントは IL スキャナ (IL scanner) です。IL スキャンは、コンパイルの前に実行できるオプションのステップです。多くの点で、IL スキャンは null/ダミーのコード生成バックエンドを持つ別のコンパイルとして動作します。IL スキャナは、ルートから依存関係グラフの一部となるすべてのメソッド本体の IL をスキャンし、それらの依存関係を展開します。IL スキャナはコード生成バックエンドが構築するのと同じ依存関係グラフを構築しますが、メソッド本体を表すグラフ内のノードにはマシンコード命令が関連付けられていません。コード生成が含まれないため、このプロセスは比較的高速ですが、結果のグラフにはコンパイルされたプログラムについて多くの貴重な洞察が含まれています。IL スキャナによって構築される依存関係グラフは、実際のコンパイルによって構築されるグラフの厳密なスーパーセット (superset) です。これは、IL スキャナがインライン化 (inlining) や脱仮想化 (devirtualization) などの最適化をモデル化しないためです。

::: tip 💡 初心者向け補足
IL スキャンは、本番コンパイルの前に行われる「偵察 (reconnaissance)」のようなものです。実際のネイティブコード生成は行わず、IL を高速にスキャンして「どの型やメソッドが必要か」「vtable のスロットはいくつ必要か」といった情報を収集します。この情報を本番コンパイルにフィードバックすることで、vtable のルックアップをインライン化するなど、より高品質なコードを生成できます。ただし、追加のステップのためコンパイル時間は長くなるというトレードオフがあります。
:::

IL スキャナの結果は、後続のコンパイルプロセスに入力されます。例えば、IL スキャナは遅延的な vtable 生成ポリシーを使用して必要なスロットのみで vtable を構築し、スキャン終了時に vtable 内の各スロットにスロット番号を割り当てることができます。スキャン中に遅延的に計算された vtable レイアウトは、その後の実際のコンパイルプロセスで呼び出しサイトにおける vtable ルックアップのインライン化に使用できます。遅延的な vtable 生成ポリシーでは、遅延 vtable の正確なスロット割り当てがコンパイル完了まで安定しないため、呼び出しサイトでの vtable ルックアップのインライン化は不可能です。

IL スキャンプロセスはオプションであり、コンパイルスループットがランタイムのコード品質よりも重要な場合、コンパイルドライバはこれをスキップできます。

関連クラス: `ILScanner`

## 基本クラスライブラリとの結合

コンパイラは、基盤となる基本クラスライブラリ（リポジトリ内の `System.Private.*` ライブラリ）と一定レベルの結合 (coupling) を持っています。結合は二重です:

- 生成されるデータ構造のバイナリ形式
- コアライブラリ内の特定のメソッドの存在に関する期待

コンパイラによって生成され、基本クラスライブラリによって使用されるバイナリ形式の例としては、実行時の型を表すデータ構造（`MethodTable`）の形式や、型に関する非必須情報（型名やメソッドのリストなど）を記述するバイト列の形式があります。これらのデータ構造はコントラクト (contract) を形成し、基本クラスライブラリ内のマネージドコードが実行時にライブラリ API（リフレクション API など）を通じてユーザーコードにリッチなサービスを提供できるようにします。これらのデータ構造の生成はオプションのものもありますが、マネージドコードの実行に必須のものもあります。

コンパイラは、生成されたコードをサポートするために、基本クラスライブラリ内の特定のよく知られたエントリポイント (entrypoints) を呼び出す必要もあります。基本クラスライブラリはこれらのメソッドを定義する必要があります。このようなエントリポイントの例としては、数学演算中に `OverflowException` をスローするヘルパー、配列アクセス中に `IndexOutOfRangeException` をスローするヘルパー、P/Invoke マーシャリングコードの生成を支援するさまざまなヘルパー（例: ネイティブメソッドの呼び出し前後に UTF-16 文字列を ANSI に変換する）があります。

興味深い点として、コンパイラと基本クラスライブラリの結合は比較的疎であることが挙げられます（必須の部分はわずかです）。これにより、ILC で異なる基本クラスライブラリを使用できます。このような基本クラスライブラリは、通常の .NET 開発者が慣れているものとはかなり異なる外観になる可能性があります（例: `ToString` メソッドを持たない `System.Object`）が、通常の .NET が「重すぎる」と見なされる環境で型安全なコードを使用できるようにします。このような軽量コードによるさまざまな実験が過去に行われており、その一部は Windows オペレーティングシステムの一部として出荷されました。

このような代替基本クラスライブラリの例として [Test.CoreLib](https://github.com/dotnet/runtime/tree/main/src/coreclr/nativeaot/Test.CoreLib/) があります。`Test.CoreLib` ライブラリは非常に最小限の API サーフェスを提供します。これは、ほとんど初期化を必要としないという事実と相まって、NativeAOT を新しいプラットフォームに移植する際の優れた助けになります。

## ジェネリクスのコンパイル

### 共有ジェネリクスと正規化

プログラムが同じジェネリックメソッドまたは型を複数の参照型引数で使用する場合（例: `List<string>` と `List<object>`）、ILC はすべての互換性のあるインスタンス化 (instantiations) で共有される単一の _正規 (canonical)_ 形式のコードをコンパイルします。すべての参照型は `__Canon` として知られる正規表現を共有します。例えば、`List<string>` と `List<object>` は両方とも `List<__Canon>` 用にコンパイルされたコードを使用します。

::: tip 💡 初心者向け補足
Java のジェネリクスでは「型消去 (type erasure)」により、`List<String>` も `List<Object>` もコンパイル後は同じ `List` になります。.NET のジェネリクスは通常「具象化 (reification)」— つまり型情報が実行時にも保持されます。しかし NativeAOT ではコードサイズ削減のため、参照型については `__Canon` という共通の正規形式を使ってコードを共有します。`List<int>` のような値型の場合はサイズが異なるため、個別にコードが生成されます。
:::

この共有は参照型のインスタンス化にのみ適用されます。値型のインスタンス化（例: `List<int>`）は、サイズの違いがコード生成に影響するため、個別のネイティブコード本体が必要です。型引数自体が値型と参照型の混合コンポーネントを持つジェネリック型の場合、正規形式はそれを反映します。例えば、`List<KeyValuePair<int, string>>` は `List<KeyValuePair<int, __Canon>>` に正規化されます。

依存関係グラフに `List<string>.Add` のようなメソッドが含まれる場合、ILC は正規メソッド本体 `List<__Canon>.Add` への依存関係を追加し、`List<string>` インスタンス化用の _[ジェネリックディクショナリ (generic dictionary)](./shared-generics)_ を生成します。ILC が RyuJIT を呼び出してメソッドをコンパイルする際、正規形式（例: `List<__Canon>.Add`）を渡します。

### ランタイム決定型

共有ジェネリックコードの依存関係分析には、型の正規形式もインスタンス化されていない形式も単独では不十分です。正規形式はパラメータの同一性を失います（`T` と `U` の両方が `__Canon` になる）。一方、シグネチャ変数（`!!0`、`!!1`）を持つインスタンス化されていない形式は、`sizeof(T)` のような操作に必要な具体的な型情報が不足しています。

これを解決するために、ILC は _ランタイム決定型 (runtime-determined types)_ (`RuntimeDeterminedType`) を使用して、実行時にのみ解決される型を表現します。`RuntimeDeterminedType` は正規型とそれが由来するジェネリックパラメータの両方をキャプチャします: 内部的には `DefType`（例: `__Canon`）と `GenericParameterDesc`（例: `Foo<T>` の `T`）の両方への参照を保持します。

例えば、`List<T>` を参照する `Foo<T>.Method()` を分析する際、ILC はこれを `List<T_System.__Canon>` として表現します。ここで型引数は `__Canon` と `T` を組み合わせた `RuntimeDeterminedType` です。

### ジェネリック仮想メソッド

ジェネリック仮想メソッド (GVM: Generic Virtual Methods) は、ターゲットの実装がオブジェクトの実行時型に依存するため、実行時にメソッドポインタとジェネリックディクショナリ (generic dictionary) の両方を解決する必要があります。次の例を考えてみましょう:

```csharp
abstract class Base
{
    public abstract void Method<T>();
}

class Derived : Base
{
    public override void Method<T>() { }
}
```

`baseRef.Method<string>()` のような呼び出しサイトでは、ランタイムはどの実装を呼び出すかを決定するために、`baseRef` の実行時型と型引数の情報の両方が必要です。

ILC は依存関係グラフで _動的依存関係 (dynamic dependencies)_ を使用して GVM を処理します。コンパイラが GVM 呼び出しを検出すると、呼び出されたメソッドの正規形式に対する `GVMDependenciesNode` を作成します。このノードは動的依存関係を持ち、プログラム内でどの型が構築されているかを観察し、GVM をオーバーライドする可能性のある各型について、適切な実装が確実にコンパイルされるようにします。

例えば、`Base.Method<__Canon>` の `GVMDependenciesNode` が `Derived` が構築されていることを確認すると、`Derived.Method<__Canon>` への依存関係を追加し、ベーススロットから派生実装へのマッピングが記録されることを保証します。実行時には、GVM テーブルにより、オブジェクトの型とメソッドのインスタンス化に基づいて正しい実装をルックアップできます。

これは ILC で動的依存関係が使用される数少ない場所の 1 つです。なぜなら、可能な GVM 実装のセットは、単一のノードを個別に調べるだけでは決定できないからです。

### シャドウメソッドノード

「シャドウ (Shadow)」メソッドノードは、依存関係追跡のみを目的として、部分的または完全にインスタンス化されたジェネリックメソッドを表します。これらのノード自体はコードを生成しません。

コード生成は常にメソッドの正規形式（`List<__Canon>.Add` など）に対して行われます。ただし、`List<string>.Add` や `List<object>.Add` への呼び出しがある場合、コンパイラはインスタンス化固有の依存関係を生成する必要がある場合があります。シャドウメソッドノードは、個別のコードは寄与しないものの、依存関係追跡の目的でこれらの特定のメソッドインスタンス化を表します。

`ShadowConcreteMethodNode` と `ShadowNonConcreteMethodNode` はどちらも `ShadowMethodNode` を拡張しています。`ShadowMethodNode` は正規メソッドの依存関係を調べることで動作します。`INodeWithRuntimeDeterminedDependencies` を実装する依存関係は、シャドウノードの型/メソッド引数で _インスタンス化 (instantiated)_ され、抽象的な依存関係（例: 「`List<T>` の MethodTable」）を具体的なもの（例: 「`List<string>` の MethodTable」）に変換します。これにより、シャドウノードはジェネリックディクショナリに必要な依存関係をオブジェクトファイルに寄与できます。ジェネリックディクショナリノードは依存関係を直接報告できません。なぜなら、コンパイラは同じ辞書を使用するすべてのメソッドを発見するまで、すべての依存関係がわからないからです。シャドウメソッドは、コンパイルされた各メソッドに応じてグラフをインクリメンタルに拡張することを可能にします。

`ShadowConcreteMethodNode` は、依存関係分析のために `List<string>.Add` のような完全にインスタンス化されたメソッドを表します。

`ShadowNonConcreteMethodNode` は、まだ共有されている部分的にインスタンス化されたメソッドを表します。例えば、`Foo<string>.Bar<__Canon>()` は `Foo<__Canon>.Bar<__Canon>()` に裏付けられていますが、`T` が `string` であることを知っています。これにより、メソッドの型パラメータがまだ開いている場合でも、型の型パラメータにのみ関係する依存関係（例: `typeof(T)`、`new T[]`）を解決できます。

## コンパイラ生成メソッド本体

入力アセンブリの形でユーザーが提供するコードのコンパイルに加えて、コンパイラはコンパイラ内で生成されるさまざまなヘルパーもコンパイルする必要があります。ヘルパーは、上位レベルの .NET の構成要素を、基盤となるコード生成バックエンドが理解できる概念に下位変換 (lowering) するために使用されます。これらのヘルパーは、ディスク上のアセンブリの IL に物理的に裏付けられることなく、IL コードとしてその場で出力されます。上位レベルの概念を通常の IL として表現することで、各コード生成バックエンドに上位レベルの概念を実装する必要がなくなります（IL はすべてのバックエンドが理解するものなので、一度だけ実装すればよい）。

ヘルパーは以下のようなさまざまな目的に使用されます:

- デリゲート (delegate) の呼び出しをサポートするヘルパー
- P/Invoke のパラメータと戻り値のマーシャリング (marshalling) をサポートするヘルパー
- `ValueType.GetHashCode` と `ValueType.Equals` をサポートするヘルパー
- リフレクション (reflection) をサポートするヘルパー: 例えば `Assembly.GetExecutingAssembly`

関連クラス: `ILEmitter`, `ILStubMethod`

関連 ILC コマンドラインスイッチ: `--ildump` は、生成されたすべての IL をファイルにダンプし、それにデバッグ情報をマッピングします（実行時に生成された IL をステップ実行してソースデバッグが可能になります）。
