# マネージド型システムの概要

::: info 原文
この章の原文は [Managed Type System Overview](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/managed-type-system.md) です。
:::

著者: Michal Strehovsky ([@MichalStrehovsky](https://github.com/MichalStrehovsky)) - 2016

## はじめに

マネージド型システム (Managed Type System) は、AOT および IL 検証のための新世代の .NET ツールの主要コンポーネントです。プログラム内のモジュール、型、メソッド、およびフィールドを表現し、型システムの利用者がさまざまな興味深い質問に対する回答を得られるよう、より高レベルなサービスを提供します。

マネージド型システムは、[CoreCLR の型システム](./type-system)を C# で書き直したものに相当します。私たちはランタイム機能を C# で実装したいとかねてから考えていました。マネージド型システムは、それを可能にするインフラストラクチャです。

::: tip 💡 初心者向け補足
型システム (Type System) とは、プログラム中の「型」に関する情報を管理する仕組みです。Java でいえば、クラスローダーやリフレクション API が提供する型情報に相当します。.NET のマネージド型システムは、型のメタデータ（フィールド構成、継承関係、インターフェース実装など）を読み取り、ランタイムやコンパイラが必要とする高レベルな情報を計算します。
:::

型システムが提供する高レベルなサービスには、以下のようなものがあります:

- メタデータからの新しい型の読み込み
- 特定の型が実装するインターフェース (interface) の集合の計算
- 静的フィールドおよびインスタンスフィールドのレイアウト (layout) の計算（個々のフィールドへのオフセット割り当て）
- 型の静的およびインスタンス GC レイアウトの計算（オブジェクト/クラスデータ内の GC ポインタの識別）
- VTable レイアウトの計算（仮想メソッドへのスロット割り当て）および仮想メソッドのスロットへの解決
- ある型を別の型の場所に格納できるかどうかの判定

型システムの設計を駆動する3つの主要なテーマがあります:

1. 低オーバーヘッドと高パフォーマンス
2. 並行性 (Concurrency)
3. 拡張性と再利用性

低オーバーヘッドは遅延読み込み (lazy loading) によって達成されます。型にフィールド、各種属性、名前などを先行的に (eagerly) 設定するのではなく、これらは基盤となるデータソース（メタデータ）からオンデマンドで読み取られます。キャッシュは控えめに使用されます。

必要に応じて、ポリモーフィズムやオブジェクト階層の代わりに、パーシャルクラス (partial class)、拡張メソッド (extension method)、およびプラガブルアルゴリズム (pluggable algorithm) が目標 3 を達成するために使用されます。型システムの再利用性はソースレベルで行われます（異なるファイルセットをインクルードして異なる機能を得る）。これにより、目標 1 から離れることなく拡張性を実現できます。

型システムは、その最も純粋な形態（すなわち、パーシャルクラスの拡張なし）では、[ECMA-335 仕様](https://www.ecma-international.org/publications-and-standards/standards/ecma-335)で定義されていない概念の導入を避けようとします。この仕様は、本ドキュメントを読む前に読んでおくことが推奨される前提知識であり、本ドキュメントで使用されるさまざまな用語の定義を提供しています。

## メタデータとの関係

メタデータ (metadata)（ECMA-335 仕様で記述されているファイルフォーマットなど）は型システムと密接な関係がありますが、この2つには明確な違いがあります。メタデータは型の物理的な形状を記述します（例: 型の基底クラスは何か、どのようなフィールドを持つか）が、型システムはその形状の上により高レベルな概念を構築します（例: 型のインスタンスをランタイムで格納するために何バイト必要か、継承されたものを含めて型がどのインターフェースを実装しているか）。

::: tip 💡 初心者向け補足
メタデータと型システムの関係は、設計図と建物の関係に似ています。メタデータ（設計図）は「このクラスにはどんなフィールドがあるか」「基底クラスは何か」といった静的な定義情報を提供します。一方、型システム（建物の施工計画）は、その情報をもとに「実際にメモリ上でどのように配置するか」「どのインターフェースを実装しているか」といった実行時に必要な高レベルの情報を計算します。
:::

型システムは基盤となるメタデータの大部分へのアクセスを提供しますが、その取得方法は抽象化されています。これにより、他のフォーマットのメタデータに裏付けられた型やメンバー、あるいは物理的なフォーマットをまったく持たないもの（配列型のメソッドなど）を、同じ型システムコンテキスト内で表現できるようになっています。

## 型システムのクラス階層

型システム内で型を表すクラスは以下のとおりです:

![クラス階層](./images/typesystem-hierarchy.svg)

この階層のほとんどのクラスは、型システムの利用者が派生させることを想定しておらず、多くはそれを防ぐために sealed になっています。

拡張可能なクラス（実際には抽象クラス）は、上の図で暗い背景で表示されています。具象クラスは、ECMA-335 モジュールファイルからメタデータを読み取るなどのロジックに基づいて、抽象メソッドおよび仮想メソッドの実装を提供する必要があります（型システムは、例えば `EcmaType` において `MetadataType` のそのような実装をすでに提供しています）。理想的には、型システムの利用者は抽象クラスを操作し、具象クラスは新しいインスタンスを作成するときにのみ使用すべきです。`EcmaType` のような具象実装型へのキャストは推奨されません。

## 型システムのクラス

以下のセクションでは、型システム内で型を表すクラスについて簡単に説明します。

### TypeDesc

`TypeDesc` は型システム内のすべての型の基底クラスです。すべてのクラスがサポートしなければならない操作のリストを定義します。すべての操作が `TypeDesc` のすべての子クラスに対して意味を持つわけではありません（例えば、ポインタ型に対してメソッドのリストを要求することは意味がありません）が、各子クラスに対して意味のある実装が提供されるよう配慮されています（すなわち、ポインタ型のメソッドリストは空になります）。

### ParameterizedType (ArrayType, ByRefType, PointerType)

これらは単一のパラメータを持つ構築型 (constructed type) です:

- 配列 (array)（多次元配列、またはベクター (vector) — 暗黙のゼロ下限を持つ1次元配列）
- マネージド参照 (managed reference)
- アンマネージドポインタ型 (unmanaged pointer type)

ランク 1 の多次元配列とベクターの区別は非常に重要であり、型システムの利用者にとって潜在的なバグの原因となります。型システムの利用者は特に注意を払う必要があります。

::: tip 💡 初心者向け補足
「ランク 1 の多次元配列」と「ベクター」の区別は、.NET 特有の重要な概念です。C# で `int[]` と書くとベクター（1次元でインデックスが 0 から始まる配列）が作られますが、`Array.CreateInstance(typeof(int), new int[]{10})` で作った配列はランク 1 の多次元配列であり、型としては異なります。Java には対応する区別はありませんが、.NET の型システムではこの2つを厳密に区別する必要があります。
:::

### DefType (NoMetadataType, MetadataType)

`DefType` は値型 (value type)、インターフェース (interface)、またはクラス (class) を表します。`DefType` のインスタンスのほとんどは `MetadataType`（型を完全に記述する何らかの具体的なメタデータに基づく型）の子クラスのものになりますが、完全なメタデータが利用できなくなるシナリオもあります。その場合、限定的な情報（GC ヒープ上の型のインスタンスが占めるバイト数や、その型が値型かどうかなど）のみが利用可能です。型システムがそのような型に対して操作できることは重要です。例えば、限定的なメタデータを持つ型が完全なメタデータを持つ型の基底型であることが可能であり、フィールドレイアウトアルゴリズムがそのような型のフィールドレイアウトを計算できる必要があります。

### GenericParameter

ジェネリックパラメータ (generic parameter) を、その制約 (constraints) とともに表します。ジェネリック定義 (generic definition) は、ジェネリックパラメータに対するインスタンス化 (instantiation) として表現されます。

.NET リフレクション型システムに詳しい読者への注意: .NET リフレクション型システムはジェネリック定義（例: `List<T>`）とジェネリック型のオープンインスタンス化 (open instantiation)（例: `List<!0>`）を区別しませんが、マネージド型システムはこの2つを区別します。この区別は IL メソッド本体内からのメンバー参照を表現する際に重要です。例えば、LDTOKEN 命令を使用した `List<T>.Add` への IL 参照は常に未インスタンス化の定義を参照すべきですが、`List<!0>.Add` への参照はシグネチャ変数を置換した後の具象メソッドを参照します。

### SignatureVariable (SignatureTypeVariable, SignatureMethodVariable)

シグネチャ変数 (signature variable) は、システム内の他の型によって置換可能な変数を表します。ジェネリックパラメータとは異なります（例えば、制約や変性 (variance) を持たないため）。これらは単に、インスタンス化 (instantiation) と呼ばれるプロセスの一部として他の型に置き換えられるプレースホルダです。シグネチャ変数は、インスタンス化コンテキスト内の位置を参照するインデックスを持ちます。

## その他の型システムクラス

型システムの各使用は、型システムコンテキスト (type system context) の作成から始まります。型システムコンテキストは、すべての型が参照同一性 (reference identity) を共有する型ユニバースを表します（2つの `TypeDesc` オブジェクトが同一の型を表すのは、それらが同じオブジェクトインスタンスである場合に限ります）。型システムコンテキストは、ユニバース内のすべてのモジュールおよび構築型を解決するために使用されます。型システムコンテキストの外で構築型の新しいインスタンスを作成することは不正です。

::: tip 💡 初心者向け補足
型システムコンテキストは、Java でいえば `ClassLoader` の役割に近いものです。あるコンテキスト内では、同じ型は必ず同じオブジェクトインスタンスで表されます（参照同一性）。これは Java の `ClassLoader` が同じクラスに対して同じ `Class` オブジェクトを返すのと似ています。この仕組みにより、型の比較を `==`（参照比較）で高速に行うことができます。
:::

型システム内の他の重要なクラスとして、`MethodDesc`（型システム内のメソッドを表す）と `FieldDesc`（型システム内のフィールドを表す）があります。`ModuleDesc` は単一のモジュールを記述し、そのモジュールがアセンブリである場合はオプションで `IAssemblyDesc` インターフェースを実装できます。`ModuleDesc` は通常、モジュール内の型/メソッド/フィールド定義のオーナーです。それらの参照同一性を維持するのは `ModuleDesc` の責任です。

## プラガブルアルゴリズム

型システムが提供するほとんどのアルゴリズム（例: フィールドレイアウトアルゴリズム）はプラガブル (pluggable) です。型システムコンテキストは、異なる実装を提供することでアルゴリズムの選択に影響を与えることができます。

アルゴリズムは、パーシャルクラスやソースインクルードでは十分でない場所で拡張メカニズムとして使用されます。特定のアルゴリズムの選択は複数の要因に依存する可能性があり、型システムの利用者はランタイムで決定される特定の条件セットに応じて複数のアルゴリズムを使い分けたい場合があります（例: 通常の `DefType` のランタイムインターフェースのリストの計算 vs. 配列型のランタイムインターフェースの計算）。

## 型システム内のハッシュコード

型システムの興味深い特性として、システム内で表現される任意の型やメソッドに対して、コンパイル時とランタイムの両方で確実に計算できるハッシュコードを算出する能力があります。コンパイル時とランタイムの両方で同じハッシュコードが利用できることを活用して、AOT コンパイルされたコードで高パフォーマンスなルックアップテーブルを構築しています。ハッシュコードは型名から計算され、ランタイムデータ構造の一部として保存されるため、コンパイラによって型名が最適化により除去された状況でも利用可能です。

## 型システムからの例外のスロー

型システム内からの例外のスローは、単純な `throw` 文よりもやや複雑です。これは、型システムがさまざまな場所で使用可能なように設計されており、それぞれが例外のスロー方法について異なる要件を持つ可能性があるためです。例えば、型システムがランタイムからインクルードされている場合、型の読み込みに失敗すると `System.TypeLoadException` がスローされるべきです。一方、コンパイラや IL 検証器で型の読み込みエラーが発生した場合、`System.TypeLoadException` はコンパイラを構成するマネージドアセンブリの実際の問題と区別がつかなくなります。したがって、異なる例外がスローされるべきです。

型システム内の例外スローは `ThrowHelper` クラスにラップされています。型システムの利用者がこのクラスとそのメソッドの定義を提供します。メソッドは、どの例外型がスローされるかを制御します。

型システムは、`TypeSystemException` 例外基底クラスから派生した例外をスローする `ThrowHelper` クラスのデフォルト実装を提供しています。このデフォルト実装は、非ランタイムシナリオでの使用に適しています。

例外メッセージには文字列 ID が割り当てられ、スローヘルパーによっても消費されます。この間接化は、コンパイラシナリオをサポートするために必要です。AOT コンパイル中に型の読み込み例外が発生した場合、AOT コンパイラには2つのタスクがあります — これが発生したことをユーザーに警告するための警告を出すことと、問題のある型がアクセスされたときにランタイムでこの例外をスローするメソッド本体を生成する可能性があることです。コンパイラのローカリゼーション (localization) は、コンパイラ出力がリンクするクラスライブラリのローカリゼーションと一致しない場合があります。実際の例外メッセージを文字列 ID を通じて間接化することで、これをラップできます。型システムの利用者は、この機能が必要な型システム外の場所でもスローヘルパーを再利用できます。

## 物理アーキテクチャ

型システムの実装は以下の場所にあります:

- `src/coreclr/tools/Common/TypeSystem/Common`: 共通型システムの大部分がここにあります
- `src/coreclr/tools/Common/TypeSystem/Ecma`: ECMA-335 モジュールファイルからメタデータを読み取る `MetadataType`、`MethodDesc`、`FieldDesc` などの具象実装がここにあります
- `src/coreclr/tools/aot/ILCompiler.TypeSystem.ReadyToRun.Tests`: 型システムの動作と機能について理解を深めることができるユニットテストがここにあります。コードについて学ぶための良い出発点です。

## CoreCLR 型システムとの注目すべき違い

- マネージド型システムでは、`MethodDesc` は可能な場合に正確なジェネリックインスタンス化 (exact generic instantiation) を持ちます。マネージド型システムにおけるコード共有ポリシー (code sharing policy) はプラガブルアルゴリズムの1つであり、`MethodDesc` の同一性 (identity) に影響を与えません。CoreCLR 型システムでは、コード共有ポリシーが `MethodDesc` の同一性と結合しています。この違いがどのように現れるかの例については、[こちらの PR](https://github.com/dotnet/runtime/pull/45744) を参照してください。
