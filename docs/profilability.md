# プロファイラビリティの実装

::: info 原文
この章の原文は [Implementing Profilability](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/profilability.md) です。
:::

本ドキュメントでは、CLR の機能にプロファイラビリティ (profilability) を追加するための技術的な詳細を説明します。これは、自身の機能をプロファイル可能にするためにプロファイリング API を変更する開発者を対象としています。

::: tip 💡 初心者向け補足
「プロファイラビリティ (profilability)」とは、プログラムの実行状況（パフォーマンス、メモリ使用量、関数の呼び出し回数など）を外部ツール（プロファイラー）から観測・分析できるようにする仕組みのことです。CLR に新しい機能を追加する際には、その機能もプロファイラーから正しく監視できるようにする必要があります。Java における JVMTI (JVM Tool Interface) に相当する概念です。
:::

## 設計哲学

## コントラクト

プロファイリング API でどのコントラクト (contract) を使用すべきかの詳細に入る前に、全体的な哲学を理解しておくことが有用です。

CLR 全体（プロファイリング API の外側）におけるデフォルトコントラクト運動の背景にある哲学は、CLR の大部分がスロー (throw) やトリガー (trigger) といった「攻撃的な動作 (aggressive behavior)」に対処できるようにすることです。後述しますが、これはコールバック (ICorProfilerCallback) のコントラクトに関する推奨事項と表裏一体であり、コールバックのコントラクトは一般的に、より許容的（「攻撃的」）なコントラクトの選択を好みます。これにより、プロファイラーはコールバック中に最大限の柔軟性を持つことができます（ICorProfilerInfo を通じてどの CLR 呼び出しが可能かという点で）。

しかし、Info 関数 (ICorProfilerInfo) は正反対です。許容的ではなく、**制限的**であることが好まれます。なぜでしょうか？プロファイラーがこれらの関数を可能な限り多くの場所から安全に呼び出せるようにしたいからです。たとえ、本来望ましいよりも制限的なコールバック（何らかの理由で GC_NOTRIGGER でなければならないコールバックなど）からであってもです。

また、ICorProfilerInfo でより制限的なコントラクトを好むことは、CLR 全体のデフォルトコントラクト哲学と矛盾しません。なぜなら、制限的である必要がある CLR 関数は少数派であると想定されているからです。ICorProfilerInfo は、このカテゴリに該当する呼び出しパスのルートです。プロファイラーはデリケートなタイミングで CLR に呼び出しを行う可能性があるため、これらの呼び出しは可能な限り控えめであることが求められます。これらは CLR のメインストリームの関数ではなく、慎重さが求められる特殊な呼び出しパスのごく少数のものです。

したがって、一般的なガイダンスとしては、可能な限り CLR 全体でデフォルトコントラクトを使用することです。しかし、プロファイラーから発生する呼び出しのパスを切り開く必要がある場合（すなわち ICorProfilerInfo から）、そのパスはコントラクトを明示的に指定し、デフォルトよりも制限的にする必要があります。

::: tip 💡 初心者向け補足
「コントラクト (contract)」とは、CLR の内部コードで使用される一種の「約束事」や「宣言」です。関数がどのような動作をするか（例外をスローするかどうか、GC をトリガーするかどうか、ロックを取得するかどうかなど）を明示的に記述します。Java のアノテーションや、C++ の `noexcept` 指定子に似た概念ですが、CLR ではより広範囲の動作を宣言します。これにより、開発者やツールが関数の安全性を事前にチェックでき、デバッグ時の問題特定が容易になります。
:::

## パフォーマンスか使いやすさか？

どちらも実現できれば理想的です。しかし、トレードオフが必要な場合は**パフォーマンスを優先**してください。プロファイリング API は、CLR とプロファイリング DLL の間の軽量で薄いインプロセス (in-process) レイヤーとなることを意図しています。プロファイラーの開発者はごく少数であり、そのほとんどが高度な技術を持つ開発者です。CLR による入力の簡単なバリデーション (validation) は期待されています。しかし、それにも限度があります。たとえば、すべてのプロファイラー ID を考えてみてください。それらは、直接呼び出される C++ EE オブジェクトインスタンスのキャストされたポインタに過ぎません（AppDomain\*、MethodTable\* など）。プロファイラーが不正な ID を渡すとどうなるでしょうか？CLR がアクセス違反 (AV) を起こします！これは想定された動作です。CLR はルックアップを検証するために ID をハッシュしたりしません。プロファイラーは自分が何をしているか理解していることが前提とされています。

とはいえ、繰り返しますが、CLR による入力の簡単なバリデーションは期待されています。NULL ポインタのチェック、検査対象のクラスが初期化済みであることの確認、「並行パラメータ (parallel parameters)」の一貫性の検証（例：配列ポインタパラメータは、そのサイズパラメータが非ゼロの場合、非 null でなければならない）などです。

## ICorProfilerCallback

このインターフェースは、CLR からプロファイラーへ興味深いイベントを通知するためのコールバック (callback) で構成されます。各コールバックは、EE 内の薄いメソッドでラップされており、そのメソッドがプロファイラーの ICorProfilerCallback(2) の実装を見つけ、対応するメソッドを呼び出す処理を行います。

プロファイラーは、ICorProfilerInfo::SetEventMask() / ICorProfilerInfo::SetEventMask2() の呼び出しで対応するフラグ (flag) を指定することによりイベントをサブスクライブ (subscribe) します。プロファイリング API はこれらの選択を保存し、フラグに対応するビットに対してマスクする特殊なインライン関数 (CORProfiler\*) を通じて CLR に公開します。すると、CLR のあちこちに、イベントの発生時にプロファイラーに通知するため ICorProfilerCallback ラッパーを呼び出すコードがありますが、この呼び出しはフラグが設定されているかどうか（特殊なインライン関数の呼び出しによって判定）を条件としています：

    {
        // プロファイラーがフラグを設定したかチェック
        BEGIN_PROFILER_CALLBACK(CORProfilerTrackModuleLoads());

        // ProfControlBlock ラッパーを通じてプロファイラーのコールバック実装を呼び出す
        // DoOneProfilerIteration 内で EvacuationCounterHolder を通じてプロファイラーを固定 (pin) する
        (&g_profControlBlock)->ModuleLoadStarted((ModuleID) this);
        // コールバック完了後にプロファイラーの固定を解除

        END_PROFILER_CALLBACK();
    }

明確にしておくと、上記のコードはコードベース全体に散りばめられているものです。呼び出される関数（この場合は ModuleLoadStarted()）は、プロファイラーのコールバック実装（この場合は ICorProfilerCallback::ModuleLoadStarted()）に対する私たちのラッパーです。すべてのラッパーは単一のファイル（vm\EEToProfInterfaceImpl.cpp）にあり、以下のセクションで提供されるガイダンスはそれらのラッパーに関するものであり、ラッパーを呼び出す上記のサンプルコードに関するものではありません。

BEGIN_PROFILER_CALLBACK マクロは、引数として渡された式を評価します。式が TRUE の場合、BEGIN_PROFILER_CALLBACK と END_PROFILER_CALLBACK マクロの間のコードが実行され、プロファイラーは ProfControlBlock ラッパーを通じてメモリに固定 (pin) されます（つまり、プロファイラーはプロセスからデタッチできなくなります）。式が FALSE の場合、BEGIN_PROFILER_CALLBACK と END_PROFILER_CALLBACK マクロの間のすべてのコードはスキップされます。BEGIN_PROFILER_CALLBACK と END_PROFILER_CALLBACK マクロの詳細については、コードベース内でその定義を見つけ、そこにあるコメントを読んでください。

## コントラクト

各コールバックラッパーには、先頭にいくつかの共通の定型コードが必要です。以下は例です：

    CONTRACTL
    {
        // Yay!
        NOTHROW;

        // Yay!
        GC_TRIGGERS;

        // Yay!
        MODE_PREEMPTIVE;

        // Yay!
        CAN_TAKE_LOCK;
    }
    CONTRACTL_END;
    CLR_TO_PROFILER_ENTRYPOINT((LF_CORPROF,
                            LL_INFO10,
                            "**PROF: useful logging text here.\n"));

重要なポイント：

- throws、triggers、mode、take_lock、および ASSERT_NO_EE_LOCKS_HELD()（後者はコールバックでのみ必須）の値を明示的に指定する必要があります。これにより、プロファイラー開発者向けのドキュメントを正確に保つことができます。
- 各コントラクトにはそれぞれのコメントが必要です（コントラクトの具体的な詳細は以下を参照）

各コントラクトの種類には「推奨値 (preferred value)」があります。可能であればその値を使用し、「Yay!」とコメントしてください。これにより、コピー＆ペーストする他の開発者にとって何がベストかが分かります。推奨値を使用できない場合は、その理由をコメントしてください。

以下はコールバックの推奨値です。

| 推奨値                                                     | 理由                                                                                                                                                                                                                                                                                                             | 詳細                                                                                                                                                                                                                                                                                                                                                                         |
| ---------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| NOTHROW                                                    | コールバックをあらゆる CLR コンテキストから発行可能にする。Info 関数も NOTHROW であるべきなので、プロファイラーにとって負担にならない。                                                                                                                                                                          | プロファイラーが THROWS の Info 関数をここから呼び出すと、プロファイラーが try/catch で囲んでいても throws 違反が発生する（コントラクトシステムはプロファイラーの try/catch を認識できないため）。そのため、プロファイラーへの呼び出しの直前にスコープされた CONTRACT_VIOLATION(ThrowsViolation) を挿入する必要がある。                                                      |
| GC_TRIGGERS                                                | プロファイラーが呼び出せる Info 関数の柔軟性を最大化する。                                                                                                                                                                                                                                                       | コールバックがデリケートなタイミングで行われ、すべてのオブジェクト参照を保護することがエラーを起こしやすいか、パフォーマンスを大幅に低下させる場合は、GC_NOTRIGGER を使用する（もちろんコメント付きで！）。                                                                                                                                                                  |
| MODE_PREEMPTIVE（可能な場合）、それ以外は MODE_COOPERATIVE | MODE_PREEMPTIVE はプロファイラーが呼び出せる Info 関数の柔軟性を最大化する（ObjectID のために協調モードが必要な場合を除く）。また、MODE_PREEMPTIVE は EE 全体で推奨される「デフォルト」コントラクトであり、コールバックをプリエンプティブモードにすることで、EE の他の場所でもプリエンプティブの使用を促進する。 | ObjectID パラメータをプロファイラーに渡す場合は MODE_COOPERATIVE が妥当。それ以外は MODE_PREEMPTIVE を指定する。コールバックの呼び出し元はすでにプリエンプティブモードにあるはず。そうでない場合は、なぜそうでないかを再検討し、呼び出し元をプリエンプティブに変更することを検討する。それが無理な場合は、コールバック呼び出し前に GCX_PREEMP() マクロを使用する必要がある。 |
| CAN_TAKE_LOCK                                              | プロファイラーが呼び出せる Info 関数の柔軟性を最大化する。                                                                                                                                                                                                                                                       | 特に追加事項なし。                                                                                                                                                                                                                                                                                                                                                           |
| ASSERT_NO_EE_LOCKS_HELD()                                  | プロファイラーが呼び出せる Info 関数にさらなる柔軟性を与える。Info がロックの再取得や順序外のロック取得を試みないことを保証する（再取得すべきロックや順序を壊すロックが取得されていないため）。                                                                                                                  | これは実際にはコントラクトではないが、コントラクトブロックは忘れないための便利な場所である。コントラクトと同様に、これを指定できない場合はその理由をコメントする。                                                                                                                                                                                                           |

注意：EE_THREAD_NOT_REQUIRED / EE_THREAD_REQUIRED はコールバックでは指定する**必要はありません**。GC コールバックはそもそも「REQUIRED」を指定できません（EE スレッドが存在しない可能性がある）し、これらは Info 関数（プロファイラー → CLR）でのみ考慮が必要です。

## エントリポイントマクロ

上記の例のように、コントラクトの後にはエントリポイントマクロ (entrypoint macro) を配置する必要があります。このマクロは、ログの記録、EE スレッドオブジェクトへのコールバック中であるというマーキング、スタックガードの除去、およびいくつかのアサートの処理を行います。使用できるマクロにはいくつかのバリアントがあります：

    CLR_TO_PROFILER_ENTRYPOINT

これが推奨されるマクロであり、通常使用されるマクロです。

他のマクロを使用することもできますが、上記の（推奨される）マクロを使用できない理由を**コメントしなければなりません**。

    *_FOR_THREAD_*

これらのマクロは、ThreadID パラメータの値が必ずしも*現在の* ThreadID と一致しない ICorProfilerCallback メソッドに使用されます。ThreadID をこれらのマクロの最初のパラメータとして指定する必要があります。マクロは GetThread() の代わりに指定された ThreadID を使用して、そのコールバックがその ThreadID に対して現在許可されているかどうか（すなわち、その ThreadID に対してまだ ThreadDestroyed() が発行されていないこと）をアサートします。

## ICorProfilerInfo

このインターフェースは、プロファイラーが CLR に呼び出すために使用するエントリポイント (entrypoint) で構成されます。

## 同期 / 非同期

各 Info 呼び出しは、同期 (synchronous) または非同期 (asynchronous) のいずれかに分類されます。同期関数はコールバック内からのみ呼び出す必要がありますが、非同期関数はいつでも安全に呼び出すことができます。

::: tip 💡 初心者向け補足
ここでの「同期 (synchronous)」と「非同期 (asynchronous)」は、一般的なプログラミングにおける async/await とは異なる意味で使われています。プロファイリング API における「同期」とは、「CLR がプロファイラーにコールバック通知を送っている最中にのみ呼び出せる関数」を意味します。つまり、CLR → プロファイラーのコールバックのスタック上にいるときだけ安全に呼び出せるということです。「非同期」は、プロファイラーがいつでも（コールバック中でなくても）安全に呼び出せる関数を指します。
:::

### 同期

Info 呼び出しの大多数は同期です。プロファイラーがコールバック内で実行している間にのみ呼び出すことができます。言い換えると、同期 Info 関数を呼び出すことが合法であるためには、スタック上に ICorProfilerCallback が存在している必要があります。これは EE スレッドオブジェクトのビットで追跡されます。コールバックが行われるとビットを設定し、コールバックが返されるとビットをリセットします。同期 Info 関数が呼び出されると、このビットをテストし、設定されていなければ呼び出しを拒否します。

#### EE スレッドのないスレッド

上記のビットは EE スレッドオブジェクトを使用して追跡されるため、EE スレッドオブジェクトを持つスレッド上で行われた Info 呼び出しのみが「同期性」を強制されます。EE スレッドではないスレッド上で行われた Info 呼び出しは、即座に合法とみなされます。これは一般的に問題ありません。なぜなら、再入時に問題となる複雑なコンテキストを構築するのは主に EE スレッドだからです。また、正確性を保証するのは最終的にプロファイラーの責任です。前述のように、パフォーマンス上の理由から、プロファイリング API は歴史的に正確性チェックを最小限にとどめ、負荷を増加させないようにしています。通常、プロファイラーが EE スレッドではないスレッド上で行う Info 呼び出しは、以下のカテゴリに分類されます：

- サーバー GC を行っているスレッドでの GC コールバック中に行われる Info 呼び出し。
- プロファイラーが作成したスレッド上で行われる Info 呼び出し（例：サンプリングスレッド。したがってスタック上に CLR コードがない）。

#### Enter / Leave フック

プロファイラーが Enter / Leave フック (hook) を要求し、ファストパス (fast path)（すなわち、介在するプロファイリング API コードなしに、JIT コンパイルされたコードからプロファイラーへの直接関数呼び出し）を使用する場合、Enter / Leave フック内からの Info 関数の呼び出しはすべて非同期とみなされます。これもまた実用的な理由によるものです。プロファイリング API コードが実行される機会がなければ（パフォーマンスのため）、コールバック内で実行中であることを示す EE スレッドビットを設定する機会がありません。これは、プロファイラーが Enter / Leave フック内からは非同期安全な Info 関数のみを呼び出すことに制限されることを意味します。Enter / Leave に直接関数呼び出しを必要とするほどパフォーマンスを重視するプロファイラーは、おそらく Enter / Leave フック内から Info 関数を呼び出すことはないため、これは通常は許容されます。

もう一つの方法は、プロファイラーが引数または戻り値の情報を要求するフラグを設定することです。これにより、プロファイラーの Enter / Leave フックに情報を準備するために介在するプロファイリング API の C 関数が呼び出されることが強制されます。このようなフラグが設定されると、プロファイリング API は、プロファイラーの引数 / 戻り値情報を準備するこの C 関数の内部から EE スレッドビットを設定します。これにより、プロファイラーは Enter / Leave フック内から同期 Info 関数を呼び出すことが可能になります。

### 非同期

非同期 Info 関数は、いつでも（コールバック中であるかどうかに関わらず）安全に呼び出せる関数です。非同期 Info 関数は比較的少数です。これらは、ハイジャッキング型のサンプリングプロファイラー (hijacking sampling profiler)（例：Visual Studio プロファイラー）がサンプル内から呼び出したいものです。非同期とラベル付けされた Info 関数が、あらゆる可能なコールスタックから実行できることは極めて重要です。スレッドは、任意の数のロック（スピンロック (spin lock)、スレッドストアロック (thread store lock)、OS ヒープロック (OS heap lock) など）を保持している最中に割り込まれ、プロファイラーによって非同期 Info 関数を介してランタイムに再入させられる可能性があります。これは容易にデッドロック (deadlock) やデータ破壊 (data corruption) を引き起こし得ます。非同期 Info 関数が自身の安全性を確保する方法は 2 つあります：

- 非常に非常にシンプルにする。ロックを取得しない、GC をトリガーしない、不整合な可能性のあるデータにアクセスしない、など。**または**
- それよりも複雑にする必要がある場合、先頭に十分なチェックを設けて、ロックやデータ構造などが安全な状態にあることを確認してから処理を続行する。
  - 多くの場合、これには現在のスレッドが現在 Forbid Suspend Thread リージョン内にあるかどうかを確認し、そうであればエラーで中止することが含まれるが、すべてのケースで十分なチェックではない。
  - DoStackSnapshot は複雑な非同期関数の例である。チェックの組み合わせ（現在のスレッドが現在 Forbid Suspend Thread リージョン内にあるかどうかの確認を含む）を使用して、処理を続行するか中止するかを判定する。

::: tip 💡 初心者向け補足
「ハイジャッキング (hijacking)」とは、プロファイラーがターゲットスレッドを一時停止し、そのスレッドの命令ポインタを変更して自分のコードを実行させることで、実行の制御を「乗っ取る」手法のことです。サンプリングプロファイラー（Visual Studio のパフォーマンス分析ツールなど）がスレッドの実行状態を定期的にスナップショットするために使用します。この手法では、ターゲットスレッドがあらゆる状態（ロック保持中、GC 中など）にある可能性があるため、ハイジャック中に呼び出される関数は非常に慎重に設計される必要があります。
:::

## コントラクト

各 Info 関数には、先頭にいくつかの共通の定型コードが必要です。以下は例です：

    CONTRACTL
    {
        // Yay!
        NOTHROW;

        // Yay!
        GC_NOTRIGGER;

        // Yay!
        MODE_ANY;

        // Yay!
        EE_THREAD_NOT_REQUIRED;

        // Yay!
        CANNOT_TAKE_LOCK;
    }
    CONTRACTL_END;
    PROFILER_TO_CLR_ENTRYPOINT_SYNC((LF_CORPROF,
                                     LL_INFO1000,
                                     "**PROF: EnumModuleFrozenObjects 0x%p.\n",
                                     moduleID));

以下は、各コントラクトの種類に対する「推奨値」です。これらはコールバックの推奨値とはほとんど異なることに注意してください！混乱した場合は、上記の設計哲学のセクションを読み直してください。

| 推奨値                             | 理由                                                                                                                                     | 詳細                                                                                                                                                                                                                                                                                                          |
| ---------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| NOTHROW                            | プロファイラーにとって呼び出しが容易になる。プロファイラー自身の try / catch が不要。                                                    | 呼び出し先が NOTHROW であれば NOTHROW を使用する。そうでない場合は、自前の try / catch を設定するよりも自身を THROWS とマークするほうが実際には良い。プロファイラーは、複数の Info 呼び出しを共有の try ブロックで囲むことにより、おそらくより効率的に処理できる。                                            |
| GC_NOTRIGGER                       | より多くの状況からプロファイラーが安全に呼び出せる。                                                                                     | トリガーしないように最大限努力する。Info 関数がトリガーする*可能性*がある場合（例：まだロードされていない型をロードする場合）、可能であればプロファイラーがトリガーパスを取ら*ない*ように指定できる手段を確保する（例：FALSE に設定できる fAllowLoad パラメータ）。そして、コントラクトを条件付きで記述する。 |
| MODE_ANY                           | より多くの状況からプロファイラーが安全に呼び出せる。                                                                                     | パラメータまたは戻り値が ObjectID の場合は MODE_COOPERATIVE が妥当。それ以外では MODE_ANY が強く推奨される。                                                                                                                                                                                                  |
| CANNOT_TAKE_LOCK                   | より多くの状況からプロファイラーが安全に呼び出せる。                                                                                     | 呼び出し先がロックを取得しないことを確認する。取得する必要がある場合は、正確にどのロックが取得されるかコメントする。                                                                                                                                                                                          |
| オプション：EE_THREAD_NOT_REQUIRED | プロファイラーが GC コールバックやプロファイラーが起動したスレッド（例：サンプリングスレッド）からこの Info 関数を使用できるようにする。 | これらのコントラクトはまだ強制されていないため、空欄のままにしても問題ない。Info 関数が現在の EE スレッドを必要としない（またはそれを必要とする関数を呼び出さない）と確信できる場合は、スレッドコントラクトが強制されるようになったときのヒントとして EE_THREAD_NOT_REQUIRED を指定できる。                   |

以下は、上記の例ほど「Yay!」ではない関数のコメント付きコントラクトの例です：

    CONTRACTL
    {
        // ModuleILHeap::CreateNew がスローする
        THROWS;

        // AppDomainIterator::Next が AppDomain::Release を呼び出し、AppDomain を破棄する可能性があり、
        // ~AppDomain はコントラクトによるとトリガーする。
        GC_TRIGGERS;

        // 協調モードが必要。そうでないと objectId が無効になる可能性がある
        if (GetThreadNULLOk() != NULL) { MODE_COOPERATIVE;  }

        // Yay!
        EE_THREAD_NOT_REQUIRED;

        // Generics::GetExactInstantiationsFromCallInformation が最終的に
        // メタデータを読み取り、リーダーロックを取得する。
        CAN_TAKE_LOCK;
    }
    CONTRACTL_END;

## エントリポイントマクロ

コントラクトの後には、エントリポイントマクロを配置する必要があります。このマクロは、ログの記録と、同期関数の場合はコールバック状態フラグを参照して本当に同期的に呼び出されているかを強制する処理を担います。Info 関数が同期か、非同期か、または Initialize コールバック内からのみ呼び出し可能かに応じて、以下のいずれかを使用してください：

- PROFILER*TO_CLR_ENTRYPOINT\_**SYNC** *（典型的な選択）\_
- PROFILER_TO_CLR_ENTRYPOINT\_**ASYNC**
- PROFILER_TO_CLR_ENTRYPOINT_CALLABLE_ON_INIT_ONLY

前述のように、非同期 Info メソッドはまれであり、より高い負担が伴います。上記の推奨コントラクトは非同期メソッドの場合「さらに推奨」であり、以下の 2 つは完全に必須です：GC_NOTRIGGER と MODE_ANY。CANNOT_TAKE_LOCK は、非同期関数では同期関数よりもさらに推奨されますが、常に可能なわけではありません。その場合の対処法については、上記の「非同期」セクションを参照してください。

## 変更対象のファイル

メソッドの追加や変更のためにどこに行けばよいかは非常に明快であり、コードを見れば分かるでしょう。以下が訪れるべき場所です。

## corprof.idl

すべてのプロファイリング API インターフェースと型は [src\inc\corprof.idl](https://github.com/dotnet/runtime/blob/main/src/coreclr/inc/corprof.idl) で定義されています。まずここで型とメソッドを定義してください。

## EEToProfInterfaceImpl.\*

プロファイラーの ICorProfilerCallback 実装に対するラッパーは [src\vm\EEToProfInterfaceImpl.\*](https://github.com/dotnet/runtime/tree/main/src/coreclr/vm) にあります。

## ProfToEEInterfaceImpl.\*

ICorProfilerInfo の実装は [src\vm\ProfToEEInterfaceImpl.\*](https://github.com/dotnet/runtime/tree/main/src/coreclr/vm) にあります。
