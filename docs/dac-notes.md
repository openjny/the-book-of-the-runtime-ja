# データアクセスコンポーネント (DAC) ノート

::: info 原文
この章の原文は [Data Access Component (DAC) Notes](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/dac-notes.md) です。
:::

日付: 2007年

マネージドコードのデバッグには、マネージドオブジェクト (managed objects) やマネージド構造体 (managed constructs) に関する特別な知識が必要です。たとえば、オブジェクトにはデータそのものに加えて、さまざまな種類のヘッダー情報があります。ガベージコレクタ (GC) が動作するにつれて、オブジェクトはメモリ内を移動することがあります。型情報の取得にはローダー (loader) の助けが必要な場合があります。エディットアンドコンティニュ (edit-and-continue) を経た関数の正しいバージョンの取得や、リフレクション (reflection) を通じて生成された関数の情報取得には、デバッガが EnC のバージョン番号やメタデータ (metadata) を認識している必要があります。デバッガはアプリケーションドメイン (AppDomain) やアセンブリ (assembly) を区別できなければなりません。VM ディレクトリのコードは、これらのマネージド構造体に必要な知識を具現化しています。これは本質的に、マネージドコードやデータに関する情報を取得するための API が、実行エンジン (execution engine) 自体が実行するものと同じアルゴリズムの一部を実行しなければならないことを意味します。

::: tip 💡 初心者向け補足
DAC は「Data Access Component（データアクセスコンポーネント）」の略で、.NET ランタイムのデバッグ機能を支える重要な仕組みです。通常、デバッガがマネージドコードの内部状態を調べるには、ランタイムの内部構造を理解する必要があります。DAC は、デバッガがプロセス外（out-of-process）からでもランタイムの内部データにアクセスできるようにするためのコンポーネントです。Java で例えるなら、JVM の内部状態をデバッガツール（jmap や jstack など）が読み取る仕組みに相当します。
:::

デバッガは _インプロセス (in-process)_ または _アウトオブプロセス (out-of-process)_ のいずれかで動作できます。インプロセスで実行されるデバッガは、ライブなデータターゲット（デバッグ対象プロセス、デバッギー）を必要とします。この場合、ランタイムがロード済みで、ターゲットは実行中です。デバッギー内のヘルパースレッドが実行エンジンのコードを実行して、デバッガに必要な情報を計算します。ヘルパースレッドはターゲットプロセス内で実行されるため、ターゲットのアドレス空間とランタイムコードに直接アクセスできます。すべての計算はターゲットプロセス内で行われます。これは、デバッガがマネージド構造体を意味のある方法で表現するために必要な情報を取得するシンプルな方法です。それにもかかわらず、インプロセスデバッガには一定の制限があります。たとえば、デバッギーが現在実行されていない場合（デバッギーがダンプファイルの場合など）、ランタイムはロードされておらず（マシン上で利用できない場合もあります）、デバッガには必要な情報を取得するためのランタイムコードを実行する手段がありません。

歴史的に、CLR デバッガはインプロセスで動作してきました。デバッガ拡張である SOS (Son of Strike) や Strike（初期の CLR 時代）を使用して、マネージドコードを検査できます。.NET Framework 4 以降、デバッガはアウトオブプロセスで実行されます。CLR デバッガ API は、SOS の機能の多くと、SOS が提供しないその他の機能を提供します。SOS と CLR デバッグ API の両方が、アウトオブプロセスデバッグを実装するためにデータアクセスコンポーネント (DAC) を使用します。DAC は概念的には、ランタイムの実行エンジンコードのサブセットであり、アウトオブプロセスで実行されます。これは、ランタイムがインストールされていないマシン上であっても、ダンプファイルに対して操作できることを意味します。その実装は主に、マクロとテンプレートのセット、および実行エンジンのコードの条件付きコンパイルで構成されています。ランタイムがビルドされると、clr.dll と mscordacwks.dll の両方が生成されます。CoreCLR ビルドでは、バイナリは若干異なり、coreclr.dll と msdaccore.dll になります。OS X などの他のオペレーティングシステム向けにビルドした場合も、ファイル名は異なります。ターゲットを検査するために、DAC はそのメモリを読み取って mscordacwks の VM コードへの入力を取得できます。その後、ホスト内で適切な関数を実行してマネージド構造体に関する必要な情報を計算し、最終的に結果をデバッガに返します。

DAC は _ターゲットプロセスのメモリ_ を読み取ることに注意してください。デバッガとデバッギーは、別々のアドレス空間を持つ別々のプロセスであることを認識することが重要です。したがって、ターゲットメモリとホストメモリを明確に区別することが重要です。ホストプロセスで実行されるコード内でターゲットアドレスを使用すると、完全に予測不能で一般的に不正な結果になります。DAC を使用してターゲットからメモリを取得する際は、正しいアドレス空間からのアドレスを使用するよう非常に注意する必要があります。さらに、ターゲットアドレスが純粋にデータとして使用される場合もあります。この場合、ホストアドレスを使用することは同様に不正です。たとえば、マネージド関数に関する情報を表示するために、その開始アドレスとサイズをリストしたい場合があります。ここでは、ターゲットアドレスを提供することが重要です。DAC が実行する VM 内のコードを書く際は、ホストアドレスとターゲットアドレスのどちらを使用するかを正しく選択する必要があります。

::: tip 💡 初心者向け補足
**ホストとターゲットの違い**は DAC を理解する上で最も重要な概念です。「ターゲット (target)」はデバッグ対象のプロセス（またはダンプファイル）であり、「ホスト (host)」はデバッガが動作しているプロセスです。これらは異なるアドレス空間を持つ別々のプロセスです。ターゲットのアドレス `0x12345678` に格納されている値は、ホストのアドレス `0x12345678` にある値とはまったく無関係です。DAC はこの2つの間でデータを安全に橋渡しする役割を果たします。
:::

DAC インフラストラクチャ（ホストまたはターゲットのメモリアクセス方法を制御するマクロとテンプレート）は、どのポインタがホストアドレスでどのポインタがターゲットアドレスであるかを区別する特定の規約を提供します。関数が _DAC 化_ (DACized) されると（つまり、DAC インフラストラクチャを使用して関数をアウトオブプロセスで動作させると）、型 `T` のホストポインタは `T *` 型として宣言されます。ターゲットポインタは `PTR_T` 型です。ただし、ホスト対ターゲットの概念は DAC にのみ意味があることを覚えておいてください。非 DAC ビルドでは、アドレス空間は1つだけです。ホストとターゲットは同じ、つまり CLR です。VM 関数内で `T *` 型 _または_ `PTR_T` 型のいずれかの型でローカル変数を宣言した場合、それは「ホストポインタ」になります。clr.dll (coreclr.dll) 内でコードを実行している場合、`T *` 型のローカル変数と `PTR_T` 型のローカル変数の間にはまったく違いがありません。同じソースから mscordacwks.dll (msdaccore.dll) にコンパイルされた関数を実行する場合、`T *` 型で宣言された変数は、デバッガをホストとする真のホストポインタになります。考えてみれば、これは明白です。しかし、これらのポインタを他の VM 関数に渡し始めると、混乱しやすくなります。関数を DAC 化する（つまり、適宜 `T *` を `PTR_T` に変更する）際は、ホスト型とターゲット型のどちらにすべきかを判断するために、ポインタの出所を追跡する必要がある場合があります。

DAC を理解していないと、DAC インフラストラクチャの使用を煩わしく感じやすいものです。`TADDR` や `PTR_this`、`dac_cast` などが、コードを散らかして理解しにくくしているように見えます。しかし、少し学べば、これらが本当は難しくないことがわかるでしょう。ホストとターゲットのアドレスを明示的に異なるものにすることは、実際には厳密な型付け (strong typing) の一形態です。より注意深く行えば行うほど、コードの正しさを確保しやすくなります。

DAC はダンプに対して操作する可能性があるため、mscordacwks.dll (msdaccore.dll) にビルドする VM ソースの部分は非侵襲的 (non-invasive) でなければなりません。具体的には、ターゲットのアドレス空間への書き込みを引き起こすようなことは通常行いたくありませんし、即座のガベージコレクションを引き起こす可能性のあるコードも実行できません。（GC を遅延できる場合は、アロケーションが可能な場合があります。）_ホスト_ の状態は常に変更されます（テンポラリ、スタック値、ローカルヒープ値）。問題となるのは _ターゲット_ 空間の変更のみです。これを強制するために、コードのファクタリング (code factoring) と条件付きコンパイル (conditional compilation) の2つのことを行います。理想的な世界では、VM コードをファクタリングして、侵襲的な操作を非侵襲的な関数とは別の関数に厳密に分離します。

残念ながら、大規模なコードベースがあり、その大部分は DAC のことをまったく考えずに書かれたものです。「検索または作成 (find or create)」のセマンティクスを持つ関数が多数あり、検査のみを行う部分とターゲットに書き込む部分を持つ関数も多数あります。これは関数に渡されるフラグで制御される場合もあります。これはローダーコードなどでよく見られます。DAC を使用する前にすべての VM コードのリファクタリングという膨大な作業を完了させなくても済むように、アウトオブプロセスからの侵襲的コードの実行を防ぐ第二の方法があります。定義済みプリプロセッサ定数 `DACCESS_COMPILE` を使用して、DAC にコンパイルするコードの部分を制御します。`DACCESS_COMPILE` 定数はできるだけ使用を少なくしたいので、新しいコードパスを DAC 化する場合は、可能な限りリファクタリングを優先します。したがって、「検索または作成」のセマンティクスを持つ関数は、2つの関数に分割すべきです。1つは情報を検索しようとする関数、もう1つはそれを呼び出して検索が失敗した場合に作成するラッパーです。そうすれば、DAC コードパスは検索関数を直接呼び出して作成を回避できます。

## DAC はどのように動作するか

前述のとおり、DAC は必要なデータをマーシャリング (marshaling) し、mscordacwks.dll (msdaccore.dll) モジュール内のコードを実行することで動作します。ターゲットアドレス空間から読み取ってターゲットの値を取得し、mscordacwks の関数が操作できるようにホストアドレス空間に格納することでデータをマーシャリングします。これはオンデマンドでのみ行われるため、mscordacwks の関数がターゲットの値を必要としなければ、DAC はそれをマーシャリングしません。

::: tip 💡 初心者向け補足
**マーシャリング (marshaling)** とは、あるプロセスのメモリ空間にあるデータを別のプロセスで使えるようにコピー・変換する処理のことです。Java の RMI (Remote Method Invocation) におけるオブジェクトのシリアライゼーションに似た概念です。DAC の場合、ターゲット（デバッグ対象）のメモリからデータを読み取り、ホスト（デバッガ）のメモリ空間にキャッシュすることで、デバッガが安全にそのデータを参照できるようにします。
:::

### マーシャリングの原則

DAC は読み取ったデータのキャッシュ (cache) を維持します。これにより、同じ値を繰り返し読み取るオーバーヘッドを回避します。もちろん、ターゲットがライブの場合、値は変更される可能性があります。キャッシュされた値が有効であると仮定できるのは、デバッギーが停止したままである間だけです。ターゲットの実行を継続させたら、DAC のキャッシュをフラッシュする必要があります。デバッガがさらなる検査のためにターゲットを停止させたとき、DAC は再び値を取得します。DAC キャッシュのエントリは `DAC_INSTANCE` 型です。これには（他のデータとともに）ターゲットアドレス、データのサイズ、およびマーシャリングされたデータ自体のスペースが含まれます。DAC がデータをマーシャリングすると、このエントリのマーシャリングされたデータ部分のアドレスをホストアドレスとして返します。

DAC がターゲットから値を読み取ると、その値を（型によって決定される）所定のサイズのバイトチャンクとしてマーシャリングします。ターゲットアドレスをキャッシュエントリのフィールドとして保持することで、ターゲットアドレスとホストアドレス（キャッシュ内のアドレス）の間のマッピングを維持します。デバッガセッションの停止と再開の間で、同じ型を使用した後続のアクセスである限り、DAC は要求された各値を一度だけマーシャリングします。（ターゲットアドレスを2つの異なる型で参照する場合、サイズが異なる可能性があるため、DAC は新しい型のための新しいキャッシュエントリを作成します。）値がすでにキャッシュにある場合、DAC はそのターゲットアドレスで検索できます。つまり、同じ型を使用して両方のポインタにアクセスしている限り、2つのホストポインタの等値（不等値）比較を正しく行えます。ただし、このポインタの同一性は型変換をまたいでは保持されません。さらに、別々にマーシャリングされた値がキャッシュ内でターゲットと同じ空間的関係を維持するという保証はないため、2つのホストポインタの大小関係の比較は不正です。オブジェクトのレイアウトはホストとターゲットで同一でなければならないため、ターゲットで使用するのと同じオフセットを使用してキャッシュ内のオブジェクトのフィールドにアクセスできます。マーシャリングされたオブジェクトのポインタフィールドはターゲットアドレスになることを覚えておいてください（通常、`PTR` 型のデータメンバとして宣言されます）。それらのアドレスの値が必要な場合、DAC は参照解除 (dereference) する前にそれらをホストにマーシャリングする必要があります。

この DLL は mscorwks.dll (coreclr.dll) のビルドに使用するのと同じソースからビルドするため、デバッガが使用する mscordacwks.dll (msdaccore.dll) のビルドは mscorwks のビルドと正確に一致する必要があります。ビルド間で使用する型のフィールドを追加または削除する可能性があることを考えると、これが明白に正しいことがわかります。mscorwks 内のオブジェクトのサイズは mscordacwks のサイズと異なり、DAC はオブジェクトを正しくマーシャリングできなくなります。これは考えてみれば明白ですが、見落としやすい影響があります。DAC ビルドにのみ存在する、または非 DAC ビルドにのみ存在するオブジェクト内のフィールドを持つことはできません。したがって、以下のような宣言は不正な動作につながります。

    class Foo
    {
    	...
    	int nCount;

    	// これは絶対にやってはいけない!! DAC ビルドではオブジェクトレイアウトが一致しなければならない
    	#ifndef DACCESS_COMPILE

    		DWORD dwFlags;

    	#endif

    	PTR_Bar pBar;
    	...
    };

### マーシャリングの詳細

DAC のマーシャリングは、DAC ビルドと非 DAC ビルドで一般的に異なる意味を持つ typedef、マクロ、テンプレート型のコレクションを通じて機能します。これらの宣言は [src\inc\daccess.h][daccess.h] にあります。このファイルの冒頭には、DAC を使用するコードを書くために必要な詳細を説明する長いコメントもあります。

[daccess.h]: https://github.com/dotnet/runtime/blob/main/src/coreclr/inc/daccess.h

マーシャリングの仕組みを理解するために、例が役立つかもしれません。一般的なデバッグシナリオは、以下のブロック図に示されています。

![DAC の概要](./images/dac-overview.png)

この図のデバッガは、Visual Studio、MDbg、WinDbg などです。デバッガは、必要な情報を取得するために CLR デバッガインターフェース (DBI) API とやり取りします。ターゲットから取得しなければならない情報は DAC を経由します。デバッガはデータターゲットを実装し、ターゲット内のメモリを読み取るための `ReadVirtual` 関数の実装を担当します。図の点線はプロセス境界を表しています。

デバッガが、マネージドスタックから取得したマネージドアプリケーション内の ngen されたメソッドの開始アドレスを表示する必要があるとします。デバッガは既に DBI から `ICorDebugFunction` のインスタンスを取得していると仮定します。まず DBI API `ICorDebugFunction::GetNativeCode` を呼び出します。これは DAC/DBI インターフェース関数 `GetNativeCodeInfo` を通じて DAC を呼び出し、関数のドメインファイル (domain file) とメタデータトークン (metadata token) を渡します。以下のコードフラグメントは実際の関数の簡略版ですが、余分な詳細を導入せずにマーシャリングを示しています。

    void DacDbiInterfaceImpl::GetNativeCodeInfo(TADDR taddrDomainFile,
                mdToken functionToken,
                NativeCodeFunctionData * pCodeInfo)
    {
    	...

    	DomainFile * pDomainFile = dac_cast<PTR_DomainFile>(taddrDomainFile);
    	Module * pModule = pDomainFile->GetCurrentModule();

    	MethodDesc* pMethodDesc = pModule->LookupMethodDef (functionToken);
    	pCodeInfo->pNativeCodeMethodDescToken = pMethodDesc;

    	// モジュールのロード中で、以前に設定されたブレークポイントをバインドしようとしている場合、
    	// まだメソッド記述子がない可能性があるため、その状況をチェックする
    	if(pMethodDesc != NULL)
    	{
    		pCodeInfo->startAddress = pMethodDesc->GetNativeCode();
    		...
    	}
    }

最初のステップは、マネージド関数が存在するモジュール (module) を取得することです。渡す `taddrDomainFile` パラメータはターゲットアドレスを表しますが、ここでそれを参照解除 (dereference) できる必要があります。つまり、DAC に値をマーシャリングさせる必要があります。`dac_cast` 演算子は、`domainFileTaddr` の値に等しいターゲットアドレスを持つ `PTR_DomainFile` の新しいインスタンスを構築します。これを `pDomainFile` に代入すると、ホストポインタ型への暗黙の変換が行われます。この変換演算子は `PTR` 型のメンバであり、ここでマーシャリングが発生します。DAC はまずそのキャッシュでターゲットアドレスを検索します。見つからない場合、マーシャリングされた `DomainFile` インスタンスのためにターゲットからデータを読み取り、キャッシュにコピーします。最後に、マーシャリングされた値のホストアドレスを返します。

これで、この `DomainFile` のホストインスタンスに対して `GetCurrentModule` を呼び出せます。この関数は `DomainFile::m_pModule` を返すシンプルなアクセサです。`Module *` を返すことに注意してください。これはホストアドレスになります。`m_pModule` の値はターゲットアドレスです（DAC は `DomainFile` インスタンスを生のバイトとしてコピーしたため）。しかし、フィールドの型は `PTR_Module` であるため、関数がそれを返す際、DAC は `Module *` への変換の一部として自動的にマーシャリングします。つまり、戻り値はホストアドレスです。これで正しいモジュールとメソッドトークンが得られたので、`MethodDesc` を取得するために必要なすべての情報があります。

    Module * DomainFile::GetCurrentModule()
    {
    	LEAF_CONTRACT;
    	SUPPORTS_DAC;
    	return m_pModule;
    }

このコードの簡略版では、メソッドトークンがメソッド定義であると仮定しています。次のステップは、`Module` インスタンスに対して `LookupMethodDef` 関数を呼び出すことです。

    inline MethodDesc *Module::LookupMethodDef(mdMethodDef token)
    {
    	WRAPPER_CONTRACT;
    	SUPPORTS_DAC;
    	...
    	return dac_cast<PTR_MethodDesc>(GetFromRidMap(&m_MethodDefToDescMap, RidFromToken(token)));
    }

これは `RidMap` を使用して `MethodDesc` を検索します。この関数の定義を見ると、`TADDR` を返すことがわかります。

    TADDR GetFromRidMap(LookupMap *pMap, DWORD rid)
    {
    	...

    	TADDR result = pMap->pTable[rid];
    	...
    	return result;
    }

これはターゲットアドレスを表しますが、実際にはポインタではなく、単なる数値です（アドレスを表しているとはいえ）。問題は、`LookupMethodDef` が参照解除できる `MethodDesc` のアドレスを返す必要があることです。これを実現するために、関数は `dac_cast` を使用して `TADDR` を `PTR_MethodDesc` に変換します。これは、ターゲットアドレス空間における `void *` から `MethodDesc *` へのキャストの形式と考えることができます。実際、`GetFromRidMap` が `TADDR`（整数セマンティクス）の代わりに `PTR_VOID`（ポインタセマンティクス）を返せば、このコードはわずかにクリーンになるでしょう。ここでも、return 文に暗黙の型変換があることで、DAC がオブジェクトを（必要に応じて）マーシャリングし、DAC キャッシュ内の `MethodDesc` のホストアドレスを返すことが保証されます。

`GetFromRidMap` の代入文は、配列にインデックスを付けて特定の値を取得します。`pMap` パラメータは `MethodDesc` からの構造体フィールドのアドレスです。そのため、DAC は `MethodDesc` インスタンスをマーシャリングした際にフィールド全体をキャッシュにコピーしています。したがって、この構造体のアドレスである `pMap` はホストポインタです。これの参照解除には DAC はまったく関与しません。しかし、`pTable` フィールドは `PTR_TADDR` です。これが示すのは、`pTable` がターゲットアドレスの配列であるが、その型はマーシャリングされた型であることを示しているということです。つまり、`pTable` 自体もターゲットアドレスになります。`PTR` 型のオーバーロードされたインデックス演算子で参照解除します。これにより、配列のターゲットアドレスが取得され、目的の要素のターゲットアドレスが計算されます。インデックスの最後のステップで、配列要素が DAC キャッシュ内のホストインスタンスにマーシャリングされ、その値が返されます。要素（`TADDR`）をローカル変数 result に代入して返します。

最後に、コードアドレスを取得するために、DAC/DBI インターフェース関数は `MethodDesc::GetNativeCode` を呼び出します。この関数は `PCODE` 型の値を返します。この型はターゲットアドレスですが、参照解除できないもの（`TADDR` の単なるエイリアス）であり、特にコードアドレスを指定するために使用します。この値を `ICorDebugFunction` インスタンスに格納し、デバッガに返します。

### PTR 型

DAC はターゲットアドレス空間からホストアドレス空間に値をマーシャリングするため、DAC がターゲットポインタをどのように扱うかを理解することは基本的に重要です。これらのマーシャリングに使用される基本型を総称して「PTR 型」と呼びます。[daccess.h][daccess.h] で、いくつかの派生型を持つ `__TPtrBase` と `__GlobalPtr` の2つのクラスが定義されていることがわかります。これらの型を直接使用することはなく、多くのマクロを通じて間接的にのみ使用します。これらのそれぞれには、値のターゲットアドレスを与える単一のデータメンバが含まれています。`__TPtrBase` の場合、これはフルアドレスです。`__GlobalPtr` の場合、DAC グローバルベースロケーションから参照される相対アドレスです。`__TPtrBase` の「T」は「target（ターゲット）」の略です。ご推察のとおり、データメンバまたはローカルであるポインタには `__TPtrBase` から派生した型を使用し、グローバルやスタティックには `__GlobalPtr` を使用します。

実際には、これらの型をマクロを通じてのみ使用します。[daccess.h][daccess.h] の冒頭コメントには、これらのすべての使用例があります。これらのマクロについて興味深いのは、DAC ビルドではこれらのマーシャリングテンプレートからインスタンス化された型を宣言するように展開されますが、非 DAC ビルドでは何もしない (no-op) ことです。たとえば、以下の定義はメソッドテーブルポインタを表す型として `PTR_MethodTable` を宣言します（規約として、これらの型は `PTR_` プレフィックスで命名されることに注意してください）。

    typedef DPTR(class MethodTable) PTR_MethodTable;

DAC ビルドでは、`DPTR` マクロは `PTR_MethodTable` という名前の `__DPtr<MethodTable>` 型を宣言するように展開されます。非 DAC ビルドでは、マクロは単に `PTR_MethodTable` を `MethodTable *` として宣言します。これは、DAC の機能が非 DAC ビルドで動作の変更やパフォーマンスの低下を引き起こさないことを意味します。

さらに良いことに、DAC ビルドでは、前のセクションの例で見たように、`PTR_MethodTable` 型として宣言された変数、データメンバ、または戻り値を DAC が自動的にマーシャリングします。マーシャリングは完全に透過的です。`__DPtr` 型にはポインタの参照解除と配列のインデックスを再定義するためのオーバーロードされた演算子関数と、ホストポインタ型にキャストする変換演算子があります。これらの操作は、要求された値がすでにキャッシュにあるかどうかを判断し、キャッシュにある場合はすぐに返し、ターゲットから読み取ってキャッシュにロードしてから返す必要があるかどうかを判断します。詳細を理解することに興味がある場合、これらのキャッシュ操作を担当する関数は `DacInstantiateTypeByAddressHelper` です。

`DPTR` で定義された `PTR` 型はランタイムで最も一般的ですが、グローバルおよびスタティックポインタ、制限付き使用の配列、可変サイズオブジェクトへのポインタ、mscordacwks.dll (msdaccore.dll) から呼び出す必要があるかもしれない仮想関数を持つクラスへのポインタ用の `PTR` 型もあります。これらのほとんどはまれであり、必要に応じて [daccess.h][daccess.h] を参照して詳しく学ぶことができます。

`GPTR` マクロと `VPTR` マクロは、ここで特記するに値するほど一般的です。これらの使い方と外部動作は `DPTR` と非常に似ています。ここでも、マーシャリングは自動的かつ透過的です。`VPTR` マクロは、仮想関数を持つクラスのマーシャリングされたポインタ型を宣言します。この特別なマクロが必要なのは、仮想関数テーブル (vtable) が本質的に暗黙の余分なフィールドだからです。DAC はこれを別途マーシャリングする必要があります。関数アドレスはすべてターゲットアドレスであり、DAC がホストアドレスに変換する必要があるためです。これらのクラスをこのように扱うことで、DAC は正しい実装クラスを自動的にインスタンス化し、基底型と派生型の間のキャストを不要にします。`VPTR` 型を宣言する場合、[vptr_list.h][vptr_list.h] にもリストする必要があります。`__GlobalPtr` 型は、`GPTR`、`GVAL`、`SPTR`、`SVAL` マクロを通じて、グローバル変数とスタティックデータメンバの両方をマーシャリングする基本機能を提供します。グローバル変数の実装はスタティックフィールドの実装とほぼ同一であり（両方とも `__GlobalPtr` クラスを使用）、[dacvars.h][dacvars.h] にエントリを追加する必要があります。DAC で使用されるグローバル関数は実装サイトでマクロを必要としませんが、アドレスが DAC で自動的に利用可能になるように [gfunc_list.h][gfunc_list.h] ヘッダで宣言する必要があります。[daccess.h][daccess.h] および [dacvars.h][dacvars.h] のコメントには、これらの型の宣言に関する詳細が記載されています。

[dacvars.h]: https://github.com/dotnet/runtime/blob/main/src/coreclr/inc/dacvars.h
[vptr_list.h]: https://github.com/dotnet/runtime/blob/main/src/coreclr/inc/vptr_list.h
[gfunc_list.h]: https://github.com/dotnet/runtime/blob/main/src/coreclr/inc/gfunc_list.h

グローバルおよびスタティックの値とポインタは、ターゲットアドレス空間へのエントリーポイントを形成するため興味深いものです（DAC の他のすべての使用では、ターゲットアドレスをすでに持っている必要があります）。ランタイム内のグローバルの多くはすでに DAC 化されています。以前は DAC 化されていなかった（または新しく導入された）グローバルを DAC で利用可能にする必要が時折生じます。適切なマクロと [dacvars.h][dacvars.h] エントリを使用することで、DAC テーブルの仕組み（[dactable.cpp] にあります）がグローバルのアドレスを coreclr.dll からエクスポートされるテーブルに保存できるようにします。DAC はこのテーブルを実行時に使用して、コードがグローバルにアクセスする際にターゲットアドレス空間のどこを見ればよいかを判断します。

[dactable.cpp]: https://github.com/dotnet/runtime/blob/main/src/coreclr/debug/ee/dactable.cpp

### VAL 型

ポインタ型に加えて、DAC はスタティックおよびグローバルの値（スタティックまたはグローバルポインタによって参照される値とは対照的に）もマーシャリングする必要があります。このために `?VAL_*` マクロのコレクションがあります。グローバル値には `GVAL_*`、スタティック値には `SVAL_*` を使用します。[daccess.h][daccess.h] ファイルのコメントには、これらのさまざまな形式の使用方法を示す表と、DAC 化されたコードで使用するグローバルおよびスタティックの値（およびグローバルおよびスタティックのポインタ）の宣言方法の説明が含まれています。

### 純粋アドレス (Pure Addresses)

DAC の操作の例で紹介した `TADDR` 型と `PCODE` 型は、純粋なターゲットアドレスです。これらは実際にはポインタではなく、整数型です。これにより、ホスト内のコードが誤ってそれらを参照解除することを防ぎます。DAC もこれらをポインタとして扱いません。具体的には、型やサイズの情報がないため、参照解除やマーシャリングを行うことができません。これらを主に2つの状況で使用します。ターゲットアドレスを純粋なデータとして扱う場合と、ターゲットアドレスでポインタ演算を行う必要がある場合です（`PTR` 型でもポインタ演算は可能です）。もちろん、`TADDR` が指定するターゲットロケーションに型情報がないため、アドレス演算を行う場合はサイズを明示的に考慮する必要があります。

マーシャリングを伴わない特別なクラスの `PTR` もあります。`PTR_VOID` と `PTR_CVOID` です。これらはそれぞれ `void *` と `const void *` のターゲット等価物です。`TADDR` は単なる数値であるため、ポインタセマンティクスを持ちません。つまり、`void *` を `TADDR` に変換して DAC 化する場合（過去にはよく行われていました）、DAC 用にコンパイルされないコードであっても、追加のキャストやその他の変更が必要になることがよくあります。`PTR_VOID` を使用すると、`void *` に期待されるセマンティクスを保持したまま、`void *` を使用するコードをより簡単かつクリーンに DAC 化できます。`PTR_VOID` や `PTR_CVOID` を使用する関数を DAC 化する場合、どれだけのデータを読む必要があるかわからないため、これらのアドレスからデータを直接マーシャリングすることはできません。つまり、参照解除はできません（ポインタ演算もできません）が、これは `void *` のセマンティクスと同一です。`void *` の場合と同様に、使用する必要がある場合は通常、より具体的な `PTR` 型にキャストします。`PTR_BYTE` 型もあり、これは標準的なマーシャリングされたターゲットポインタです（ポインタ演算などをサポートします）。一般的に、コードを DAC 化する際は、期待どおり `void *` は `PTR_VOID` に、`BYTE *` は `PTR_BYTE` になります。[daccess.h][daccess.h] には、`PTR_VOID` 型の使用とセマンティクスに関する詳細なコメントがあります。

レガシーコードが `void *` などのホストポインタ型にターゲットアドレスを格納していることがあります。これは常にバグであり、コードの推論を非常に困難にします。クロスプラットフォーム対応（ポインタ型のサイズが異なる場合）でも壊れます。DAC ビルドでは、`void *` 型はターゲットアドレスを格納すべきではないホストポインタです。代わりに `PTR_VOID` を使用すると、void ポインタ型がターゲットアドレスであることを示すことができます。このような使用をすべて排除しようとしていますが、一部はコード内に広く浸透しており、完全に排除するにはしばらくかかります。

### 変換 (Conversions)

以前の CLR バージョンでは、型間のキャストに C スタイルの型キャスト、マクロ、およびコンストラクタを使用していました。たとえば、`MethodIterator::Next` では以下のようになっていました。

    if (methodCold)
    {
    	PTR_CORCOMPILE_METHOD_COLD_HEADER methodColdHeader
    	            = PTR_CORCOMPILE_METHOD_COLD_HEADER((TADDR)methodCold);

    	if (((TADDR)methodCode) == PTR_TO_TADDR(methodColdHeader->hotHeader))
    	{
    		// コールドコードに一致
    		m_pCMH = PTR_CORCOMPILE_METHOD_COLD_HEADER((TADDR)methodCold);
    		...

methodCold と methodCode はどちらも `BYTE *` として宣言されていますが、実際にはターゲットアドレスを保持しています。4行目で、methodCold は `TADDR` にキャストされ、`PTR_CORCOMPILE_METHOD_COLD_HEADER` のコンストラクタへの引数として使用されます。この時点で、`methodColdHeader` は明示的にターゲットアドレスです。6行目では、`methodCode` の別の C スタイルのキャストがあります。`methodColdHeader` の hotHeader フィールドは `PTR_CORCOMPILE_METHOD_HEADER` 型です。`PTR_TO_TADDR` マクロは、この `PTR` 型から生のターゲットアドレスを抽出して `methodCode` に代入します。最後に9行目で、`PTR_CORCOMPILE_METHOD_COLD_HEADER` 型の別のインスタンスが構築されます。ここでも、`methodCold` はこのコンストラクタに渡すために `TADDR` にキャストされています。

このコードが過度に複雑で混乱するように見えるなら、それは良いことです。実際にそうなのです。さらに悪いことに、ホストとターゲットのアドレスの分離を保護する機能を提供しません。`methodCold` と `methodCode` の宣言からは、これらをターゲットアドレスとして解釈する特別な理由はありません。これらのポインタが DAC ビルドで本当にホストポインタであるかのように参照解除された場合、プロセスはおそらくアクセス違反 (AV) を起こすでしょう。このスニペットは、任意のポインタ型（`PTR` 型とは対照的に）が `TADDR` にキャストできることを示しています。これら2つの変数が常にターゲットアドレスを保持することを考えると、`BYTE *` ではなく `PTR_BYTE` 型であるべきです。

異なる `PTR` 型間でキャストするための規律ある手段もあります。`dac_cast` です。`dac_cast` 演算子は、C++ の `static_cast` 演算子の DAC 対応バージョンです（CLR コーディング規約では、ポインタ型のキャスト時に C スタイルのキャストの代わりに `static_cast` を使用することが規定されています）。`dac_cast` 演算子は、以下のいずれかを行います。

1. `TADDR` から `PTR` 型を作成する
2. ある `PTR` 型を別の `PTR` 型に変換する
3. 以前に DAC キャッシュにマーシャリングされたホストインスタンスから `PTR` を作成する
4. `PTR` 型から `TADDR` を抽出する
5. 以前に DAC キャッシュにマーシャリングされたホストインスタンスから `TADDR` を取得する

::: tip 💡 初心者向け補足
`dac_cast` は C++ の `static_cast` のような型変換演算子ですが、DAC のホスト／ターゲットアドレスの区別を意識した安全なキャストです。たとえば、`dac_cast<PTR_MethodDesc>(someAddress)` と書くと、ターゲットアドレス `someAddress` にある `MethodDesc` を安全にマーシャリングして使えるようにしてくれます。C スタイルのキャスト `(MethodDesc*)ptr` とは違い、`dac_cast` はアドレス空間の混同を検出してコンパイルエラーやランタイムエラーを出してくれるため、バグの早期発見に役立ちます。
:::

さて、methodCold と methodCode の両方が `PTR_BYTE` 型として宣言されていると仮定すると、上記のコードは以下のように書き直すことができます。

    if (methodCold)
    {
    	PTR_CORCOMPILE_METHOD_COLD_HEADER methodColdHeader
    	            = dac_cast<PTR_CORCOMPILE_METHOD_COLD_HEADER>(methodCold);

    	if (methodCode == methodColdHeader->hotHeader)
    	{
    		// コールドコードに一致
    		m_pCMH = methodColdHeader;

このコードはまだ複雑で混乱するように見えるかもしれませんが、少なくともキャストとコンストラクタの数を大幅に削減しました。また、ホストポインタとターゲットポインタの分離を維持する構造を使用しているため、コードをより安全にしました。特に、`dac_cast` は間違ったことをしようとすると、コンパイラエラーまたはランタイムエラーを生成することがよくあります。一般的に、変換には `dac_cast` を使用するべきです。

## DAC 化 (DACizing)

### いつ DAC 化が必要か？

新しい機能を追加する場合はいつでも、そのデバッグ可能性のニーズを考慮し、機能をサポートするためにコードを DAC 化する必要があります。また、バグ修正やコードのクリーンアップなどの他の変更が、必要に応じて DAC のルールに準拠していることを確認する必要があります。そうでないと、変更がデバッガや SOS を壊すことになります。（新しい機能を実装するのではなく）既存のコードを単に変更する場合、変更する関数に `SUPPORTS_DAC` コントラクト (contract) が含まれていれば、DAC について心配する必要があると一般的に判断できます。このコントラクトには `SUPPORTS_DAC_WRAPPER` や `LEAF_DAC_CONTRACT` などのいくつかのバリエーションがあります。[contract.h][contract.h] にはこれらの違いを説明するコメントがあります。関数内に多くの DAC 固有の型が見つかる場合は、そのコードが DAC ビルドで実行されると仮定すべきです。

[contract.h]: https://github.com/dotnet/runtime/blob/main/src/coreclr/inc/contract.h

DAC 化は、エンジン内のコードが DAC と正しく動作することを保証します。ターゲットからホストに値を正しくマーシャリングするために DAC を正しく使用することが重要です。ホストから不正に使用されたターゲットアドレス（またはその逆）は、マップされていないアドレスを参照する可能性があります。アドレスがマップされている場合、値は期待される値とはまったく無関係になります。その結果、DAC 化は主に、DAC がマーシャリングする必要があるすべての値に `PTR` 型を使用することを保証することになります。もう1つの主要なタスクは、DAC ビルドで侵襲的なコードの実行を許可しないことを保証することです。実際には、コードのリファクタリングや `DACCESS_COMPILE` プリプロセッサディレクティブの追加が必要になることがあります。また、適切な `SUPPORTS_DAC` コントラクトを追加することも重要です。このコントラクトの使用は、関数が DAC と連携して動作することを開発者に示します。これが重要な理由は2つあります。

1. 後で別の `SUPPORTS_DAC` 関数からこの関数を呼び出す場合、それが DAC セーフであることがわかっているため、DAC 化について心配する必要がありません。
2. 関数に変更を加える場合、それらが DAC セーフであることを確認する必要があります。この関数から別の関数への呼び出しを追加する場合、それが DAC セーフであること、または非 DAC ビルドでのみ呼び出されることを確認する必要もあります。
