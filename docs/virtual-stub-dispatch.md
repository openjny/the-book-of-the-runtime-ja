# 仮想スタブディスパッチ (Virtual Stub Dispatch)

::: info 原文
この章の原文は [Virtual Stub Dispatch](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/virtual-stub-dispatch.md) です。
:::

著者: Simon Hall ([@snwbrdwndsrf](https://github.com/snwbrdwndsrf)) - 2006

## はじめに

仮想スタブディスパッチ (VSD: Virtual Stub Dispatch) は、従来の仮想メソッドテーブル (vtable) の代わりにスタブ (stub) を使用して仮想メソッド呼び出しを行う技術です。以前のインターフェースディスパッチでは、インターフェースにプロセス全体で一意な識別子が必要であり、読み込まれたすべてのインターフェースをグローバルなインターフェース仮想テーブルマップに追加する必要がありました。この要件により、すべてのインターフェースおよびインターフェースを実装するすべてのクラスは、NGEN シナリオにおいてランタイム時にリストアされなければならず、起動時のワーキングセットの大幅な増加を引き起こしていました。スタブディスパッチの動機は、関連するワーキングセットの多くを排除し、残りの処理をプロセスのライフタイム全体に分散させることでした。

VSD は仮想インスタンスメソッド呼び出しとインターフェースメソッド呼び出しの両方をディスパッチすることが可能ですが、現在はインターフェースディスパッチにのみ使用されています。

::: tip 💡 初心者向け補足
**仮想メソッドテーブル (vtable)** とは、オブジェクト指向言語において仮想メソッド（オーバーライド可能なメソッド）の呼び出し先を解決するための従来の仕組みです。Java の vtable に相当します。各クラスがメソッドへのポインタの配列を持ち、メソッド呼び出し時にはこのテーブルを参照して実際の呼び出し先を決定します。

VSD はこの vtable を「スタブ」と呼ばれる小さなコード片に置き換えることで、メモリ使用量（ワーキングセット）を削減しようとする最適化技術です。
:::

## 依存関係

### コンポーネントの依存関係

スタブディスパッチのコードは、ランタイムの他の部分からは比較的独立して存在しています。依存コンポーネントが使用できる API を提供しており、以下に挙げる依存関係は比較的小さな接触面を構成しています。

#### コードマネージャー (Code Manager)

VSD は事実上、コードマネージャーに依存してメソッドの状態に関する情報を取得します。特に、特定のメソッドが最終状態に遷移したかどうかの情報であり、VSD がスタブの生成やターゲットのキャッシングなどの詳細を決定するために必要です。

#### 型とメソッド (Types and Methods)

MethodTable は、任意の VSD コールサイトのターゲットコードアドレスを決定するために使用されるディスパッチマップ (dispatch map) へのポインタを保持しています。

#### 特殊な型 (Special Types)

COM インターオプ型への呼び出しは、特殊なターゲット解決を持つため、カスタムディスパッチされなければなりません。

### このコンポーネントに依存するコンポーネント

#### コードマネージャー (Code Manager)

コードマネージャーは、JIT コンパイラにインターフェース呼び出しのコールサイトターゲットを提供するために VSD に依存しています。

#### クラスビルダー (Class Builder)

クラスビルダーは、ディスパッチマッピングコードが公開する API を使用して、型の構築時にディスパッチマップを作成します。このマップはディスパッチ時に VSD コードによって使用されます。

## 設計の目標と非目標

### 目標

#### ワーキングセットの削減

インターフェースディスパッチは以前、プロセス全体のインターフェース識別子を扱う大きくやや疎な vtable ルックアップマップを使用して実装されていました。目標は、ディスパッチスタブを必要に応じて生成することでコールドワーキングセットの量を削減し、理論的には関連するコールサイトとそのディスパッチスタブを互いに近くに配置してワーキングセット密度を高めることでした。

::: tip 💡 初心者向け補足
**ワーキングセット** とは、プロセスが実際にメモリ上に保持しているページの集合をいいます。**コールドワーキングセット** はめったにアクセスされないが確保されたままのメモリ領域を指します。ワーキングセットが大きいと、アプリケーションの起動が遅くなったり、メモリ使用量が増えたりします。VSD は「必要になったときだけスタブを生成する」ことで、このメモリ使用量を削減しています。
:::

VSD のコールサイトあたりの初期ワーキングセットは、システムの実行中に作成・収集されるさまざまなスタブを追跡するために必要なデータ構造のせいで高くなることに注意が必要です。しかし、アプリケーションが定常状態に達すると、これらのデータ構造は単純なディスパッチには必要なくなるため、ページアウトされます。残念ながら、クライアントアプリケーションではこれは起動時間の遅延に等しく、仮想メソッドに対する VSD を無効にする要因の一つとなりました。

#### スループットの同等性

インターフェースおよび仮想メソッドのディスパッチを、以前の vtable ディスパッチメカニズムと償却的に同等のスループットに保つことが重要でした。

インターフェースディスパッチではこれが達成可能であることはすぐに明らかでしたが、仮想メソッドディスパッチではやや遅いことが判明し、これが仮想メソッドに対する VSD を無効にする要因の一つとなりました。

## トークン表現とディスパッチマップの設計

ディスパッチトークン (dispatch token) はランタイムで割り当てられるネイティブワードサイズの値であり、内部的にはインターフェースとスロットを表すタプルで構成されています。

この設計では、割り当てられた型識別子の値とスロット番号の組み合わせを使用します。ディスパッチトークンはこれら2つの値の組み合わせで構成されます。ランタイムとの統合を容易にするため、この実装はクラシックな vtable レイアウトと同じ方法でスロット番号を割り当てます。これは、ランタイムが MethodTable、MethodDesc、スロット番号をまったく同じ方法で扱えることを意味しますが、この抽象化を処理するために vtable に直接アクセスする代わりにヘルパーメソッドを介してアクセスする必要があります。

_スロット (slot)_ という用語は、常にクラシックな vtable レイアウトにおけるスロットインデックス値のコンテキストで使用され、マッピングメカニズムによって作成・解釈されるものです。これは、ランタイムで以前実装されていた、仮想メソッドスロットの後に非仮想メソッドスロットが続くクラシックなメソッドテーブルレイアウトを想像した場合のスロット番号です。ランタイムコード内ではスロットがクラシックな vtable 構造へのインデックスとしての意味と、vtable 内のポインタのアドレスとしての意味の両方で使われるため、この区別を理解することが重要です。変更点は、スロットがインデックス値のみとなり、コードポインタアドレスは実装テーブル (implementation table)（後述）に格納されるようになったことです。

動的に割り当てられる型識別子の値については後述します。

### メソッドテーブル (Method Table)

#### 実装テーブル (Implementation Table)

これは、型によって導入された各メソッドボディに対して、そのメソッドのエントリポイントへのポインタを持つ配列です。メンバーは以下の順序で配置されます。

- 導入された (newslot) 仮想メソッド
- 導入された非仮想（インスタンスおよびスタティック）メソッド
- オーバーライドする仮想メソッド

この形式の理由は、クラシックな vtable レイアウトの自然な拡張を提供するためです。その結果、スロットマップ (slot map)（後述）の多くのエントリは、この順序やクラスの仮想・非仮想の総数などの詳細から推論できます。

仮想インスタンスメソッドのスタブディスパッチが無効になっている場合（現在無効になっています）、実装テーブルは存在せず、真の vtable に置き換えられます。すべてのマッピング結果は、実装テーブルではなく vtable のスロットとして表現されます。このドキュメント全体で実装テーブルに言及する場合は、この点を念頭に置いてください。

#### スロットマップ (Slot Map)

スロットマップは、0個以上の <_type_, [<_slot_, _scope_, (_index | slot_)>]> エントリのテーブルです。_type_ は上述の動的に割り当てられた識別番号であり、現在のクラスを示すセンチネル値（仮想インスタンスメソッドの呼び出し）か、現在のクラスが実装するインターフェース（またはその親の1つによって暗黙的に実装されるもの）の識別子のいずれかです。サブマップ（角括弧内）には1つ以上のエントリがあります。各エントリ内で、最初の要素は常に _type_ 内のスロットを示します。2番目の要素 _scope_ は、3番目の要素が実装の _index_ であるかスロット番号であるかを指定します。_scope_ は、次の番号が仮想スロット番号として解釈されるべきことを示す既知のセンチネル値であり、_this.slot_ として仮想的に解決されるべきものです。_scope_ は、現在のクラスの継承階層における特定のクラスを識別することもでき、その場合、3番目の引数は _scope_ で示されるクラスの実装テーブルへの _index_ であり、_type.slot_ の最終的なメソッド実装です。

::: tip 💡 初心者向け補足
スロットマップは、「どのインターフェースのどのメソッドが、どのクラスのどの実装に対応するか」を記録するテーブルです。Java における「インターフェースメソッドから具体的なクラスの実装メソッドへの対応表」に相当します。

例えば、インターフェース `IFoo` のメソッド `Bar()` がクラス `MyClass` のどのメソッドに対応するかを、このスロットマップが管理しています。
:::

#### 例

以下は、小さなクラス構造（C# でモデル化）と、各クラスの実装テーブルおよびスロットマップがどうなるかを示しています。

![図1](./images/virtualstubdispatch-fig1.png)

このマップを見ると、スロットマップのサブマップの最初の列が、クラシックな仮想テーブルビューのスロット番号に対応していることがわかります（System.Object は独自に4つの仮想メソッドを提供しますが、明確さのために省略されています）。メソッド実装の検索は常にボトムアップで行われます。したがって、型 _B_ のオブジェクトがあり _I.Foo_ を呼び出したい場合、_B_ のスロットマップから _I.Foo_ のマッピングを探し始めます。そこで見つからなければ、_A_ のスロットマップを探し、そこで見つかります。それは _I_ の仮想スロット 0（_I.Foo_ に対応）が仮想スロット 4 によって実装されていることを示しています。次に _B_ のスロットマップに戻って仮想スロット 4 の実装を検索し、それが _B_ 自身の実装テーブルのスロット 1 によって実装されていることを見つけます。

### その他の用途

このマッピング技術は、仮想スロットの methodimpl 再マッピング（つまり、インターフェーススロットが仮想スロットにマッピングされるのと同様に、現在のクラスのマップにおける仮想スロットマッピング）を実装するために使用できることに注意が必要です。マップのスコーピング機能により、非仮想メソッドも参照できます。これは、ランタイムが非仮想メソッドによるインターフェースの実装をサポートしたい場合に有用です。

### 最適化

スロットマップはビットエンコードされており、デルタ値を使用して典型的なインターフェース実装パターンを活用することで、マップサイズを大幅に削減しています。さらに、新しいスロット（仮想・非仮想の両方）は、実装テーブル内の順序から暗示できます。テーブルに新しい仮想スロット、次に新しいインスタンススロット、その後にオーバーライドが含まれている場合、適切なスロットマップエントリは、実装テーブル内のインデックスと親クラスから継承された仮想の数を組み合わせることで暗示できます。このような暗示されたマップエントリはすべて (\*) で示されています。現在のデータ構造のレイアウトは以下のパターンを使用しており、DispatchMap は実装テーブルの順序から完全に暗示できない場合にのみ存在します。

    MethodTable -> [DispatchMap ->] ImplementationTable

## 型 ID マップ (Type ID Map)

型を ID にマッピングします。ID は、以前にマッピングされていない型が検出されるたびに単調増加する値として割り当てられます。現在、そのような型はすべてインターフェースです。

現在、これは HashMap を使用して実装されており、両方向のルックアップのエントリを含んでいます。

## ディスパッチトークン (Dispatch Tokens)

ディスパッチトークンは <_typeID_, _slot_> タプルです。インターフェースの場合、型はそのインターフェースに割り当てられたインターフェース ID になります。仮想メソッドの場合、スロットがディスパッチ対象の型内で仮想的に解決されるべきことを示す定数値（_this_ に対する仮想メソッド呼び出し）になります。この値のペアは、ほとんどの場合、プラットフォームのネイティブワードサイズに収まります。x86 では、各値の下位 16 ビットを連結したものになる可能性が高いです。これは、ランタイムの _TypeHandle_ が _MethodTable_ ポインタまたは <_TypeHandle, TypeHandle_> ペアのいずれかになり得るのと同様に、センチネルビットで2つのケースを区別することでオーバーフロー問題を処理するように一般化できます。これが必要かどうかはまだ決定されていません。

## 仮想スタブディスパッチの設計

## ディスパッチトークンから実装への解決

トークンと型が与えられると、トークンを型の実装テーブルインデックスにマッピングすることで実装が見つかります。実装テーブルは型の MethodTable から到達可能です。このマップは BuildMethodTable で作成されます。MethodTable を構築している型が実装するすべてのインターフェースを列挙し、その型が実装またはオーバーライドするすべてのインターフェースメソッドを決定します。この情報を追跡することで、インターフェースディスパッチ時にトークンとターゲットオブジェクト（MethodTable とトークンマッピングを取得できる）からターゲットコードを決定することが可能になります。

## スタブ (Stubs)

インターフェースディスパッチの呼び出しはスタブを経由します。これらのスタブはすべてオンデマンドで生成され、すべてトークンとオブジェクトを実装にマッチさせ、その実装に呼び出しを転送することを最終的な目的としています。

現在、3種類のスタブがあります。以下の図は、これらのスタブ間の一般的な制御フローを示しており、以下で説明します。

![図2](./images/virtualstubdispatch-fig2.png)

### ジェネリックリゾルバ (Generic Resolver)

これは実際にはすべてのスタブの最終的なフェイルパスとして機能する C 関数です。<_token_, _type_> タプルを受け取り、ターゲットを返します。ジェネリックリゾルバは、必要に応じてディスパッチスタブやリゾルバスタブの作成、より良いスタブが利用可能になったときの間接セル (indirection cell) のパッチ、結果のキャッシング、およびすべてのブックキーピングも担当します。

### ルックアップスタブ (Lookup Stubs)

これらのスタブは、インターフェースディスパッチのコールサイトに最初に割り当てられるものであり、JIT がインターフェースコールサイトをコンパイルするときに作成されます。JIT は最初の呼び出しが行われるまでトークンを満たすために使用される型の知識を持っていないため、このスタブはトークンと型を引数としてジェネリックリゾルバに渡します。必要であれば、ジェネリックリゾルバはディスパッチスタブとリゾルブスタブも作成し、コールサイトをディスパッチスタブにバックパッチして、ルックアップスタブがもう使用されないようにします。

ルックアップスタブは、一意のトークンごとに1つ作成されます（つまり、同じインターフェーススロットへのコールサイトは同じルックアップスタブを使用します）。

::: tip 💡 初心者向け補足
**バックパッチ (back patch)** とは、コールサイト（メソッド呼び出し箇所）の呼び出し先を、より効率的なスタブに書き換えることです。最初はルックアップスタブが使われますが、一度呼び出しが行われて型が判明すると、より高速なディスパッチスタブに切り替わります。これは JIT コンパイラの自己最適化の一種です。
:::

### ディスパッチスタブ (Dispatch Stubs)

これらのスタブは、コールサイトが単態的 (monomorphic) な振る舞いをすると考えられる場合に使用されます。これは、特定のコールサイトで使用されるオブジェクトが通常同じ型である（つまり、呼び出されるオブジェクトがほとんどの場合、同じサイトで前回呼び出されたオブジェクトと同じ型である）ことを意味します。ディスパッチスタブは呼び出されるオブジェクトの型 (MethodTable) を取得し、キャッシュされた型と比較して、成功すればキャッシュされたターゲットにジャンプします。x86 では、これは通常「比較、条件付き失敗ジャンプ、ターゲットへのジャンプ」というシーケンスになり、すべてのスタブの中で最高のパフォーマンスを提供します。スタブの型比較が失敗した場合、対応するリゾルブスタブ（後述）にジャンプします。

ディスパッチスタブは、一意の <_token_, _type_> タプルごとに1つ作成されますが、コールサイトのルックアップスタブが呼び出されたときに遅延的にのみ作成されます。

### リゾルブスタブ (Resolve Stubs)

多態的 (polymorphic) なコールサイトはリゾルブスタブによって処理されます。これらのスタブは、キーペア <_token_, _type_> を使用してグローバルキャッシュ内のターゲットを解決します。ここで _token_ は JIT 時に既知であり、_type_ は呼び出し時に決定されます。グローバルキャッシュに一致するエントリがない場合、リゾルブスタブの最終ステップはジェネリックリゾルバを呼び出し、返されたターゲットにジャンプすることです。ジェネリックリゾルバが <_token_, _type_, _target_> タプルをキャッシュに挿入するため、同じ <_token_, _type_> タプルでの次の呼び出しはキャッシュ内でターゲットを正常に見つけます。

ディスパッチスタブが十分な頻度で失敗すると、コールサイトは多態的とみなされ、リゾルブスタブはコールサイトをリゾルブスタブに直接ポイントするようにバックパッチして、一貫して失敗するディスパッチスタブのオーバーヘッドを回避します。同期ポイント（現在は GC の終了時）では、多態的なサイトが単態的なコールサイトにランダムに昇格されます。これは、コールサイトの多態的な属性は通常一時的であるという仮定に基づいています。この仮定が特定のコールサイトに対して正しくない場合、すぐにバックパッチがトリガーされて再び多態的に降格されます。

リゾルブスタブはトークンごとに1つ作成されますが、すべてグローバルキャッシュを使用します。トークンごとに1つのスタブとすることで、<_token_, _type_> タプルの変化しないコンポーネントから導出された事前計算ハッシュを使用した高速で効果的なハッシュアルゴリズムが可能になります。

::: tip 💡 初心者向け補足
**単態的 (monomorphic)** とは、ある呼び出し箇所で常に同じ型のオブジェクトが使われることを意味します。**多態的 (polymorphic)** とは、複数の異なる型のオブジェクトが使われることを意味します。

例えば、`IAnimal animal = new Dog();` と常に `Dog` 型だけが来るなら単態的、`Dog` や `Cat` が混在するなら多態的です。VSD は単態的なケースを高速化するためにディスパッチスタブを使い、多態的なケースにはリゾルブスタブ＋グローバルキャッシュで対応します。
:::

### コードシーケンス

以前のインターフェース仮想テーブルディスパッチメカニズムは、以下のようなコードシーケンスを生成していました。

![図3](./images/virtualstubdispatch-fig3.png)

典型的なスタブディスパッチシーケンスは以下の通りです。

![図4](./images/virtualstubdispatch-fig4.png)

ここで expectedMT、failure、target はスタブにエンコードされた定数です。

典型的なスタブシーケンスは、以前のインターフェースディスパッチメカニズムと同じ数の命令を持ち、メモリの間接参照が少ないため、より小さなワーキングセット寄与で高速に実行できる可能性があります。また、作業の大部分がコールサイトではなくスタブ内にあるため、JIT されるコードも小さくなります。これはコールサイトがめったに呼び出されない場合にのみ有利です。失敗分岐は、x86 の分岐予測が成功ケースを追うように配置されていることに注意してください。

## 現在の状態

現在、VSD はインターフェースメソッド呼び出しに対してのみ有効であり、仮想インスタンスメソッド呼び出しには有効ではありません。これにはいくつかの理由があります。

- **起動:** 大量の初期スタブを生成する必要があるため、起動時のワーキングセットと速度が阻害されていました。
- **スループット:** インターフェースディスパッチは VSD で一般的に高速になりますが、仮想インスタンスメソッド呼び出しは許容できない速度低下を受けていました。

仮想インスタンスメソッド呼び出しに対する VSD を無効にした結果、すべての型は仮想インスタンスメソッドのための vtable を持ち、上述の実装テーブルは無効化されています。インターフェースメソッドのディスパッチを可能にするため、ディスパッチマップは引き続き存在しています。

## 物理アーキテクチャ

ディスパッチトークンとマップの実装の詳細については、[clr/src/vm/contractImpl.h](https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/contractimpl.h) および [clr/src/vm/contractImpl.cpp](https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/contractimpl.cpp) を参照してください。

仮想スタブディスパッチの実装の詳細については、[clr/src/vm/virtualcallstub.h](https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/virtualcallstub.h) および [clr/src/vm/virtualcallstub.cpp](https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/virtualcallstub.cpp) を参照してください。
