# 型システム

::: info 原文
この章の原文は [Type System](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/type-system.md) です。
:::

著者: David Wrighton ([@davidwrighton](https://github.com/davidwrighton)) — 2010

## はじめに

CLR の型システムは、ECMA 仕様に記述された型システムとその拡張をランタイム内部で表現するものです。

### 概要

型システムは、一連のデータ構造と、それらを操作・生成するアルゴリズムから構成されています。これはリフレクションを通じて公開される型システムでは**ありません**。ただし、リフレクションの型システムはこのシステムに依存しています。

::: tip 💡 初心者向け補足
「型システム」とは、`int`、`string`、`List<T>` などの型に関する情報を管理する仕組みです。C# のコードで `typeof(string)` や `is` 演算子を使うと、裏ではこの型システムが動いています。リフレクション（`Type.GetType()` など）は、この内部型システムの上に構築された別のレイヤーです。
:::

型システムが管理する主要なデータ構造は以下のとおりです：

- **MethodTable**
- **EEClass**
- **MethodDesc**
- **FieldDesc**
- **TypeDesc**
- **ClassLoader**

型システムに含まれる主要なアルゴリズムは以下のとおりです：

- **型ローダー (Type Loader):** 型を読み込み、型システムの主要なデータ構造の大部分を生成するために使用されます。
- **CanCastTo および類似機能:** 型同士を比較する機能です。
- **LoadTypeHandle:** 主に型の検索に使用されます。
- **シグネチャ解析 (Signature Parsing):** メソッドやフィールドの情報を比較・収集するために使用されます。
- **GetMethod/FieldDesc:** メソッド/フィールドを検索・読み込みするために使用されます。
- **Virtual Stub Dispatch:** インターフェースへの仮想呼び出しの宛先を見つけるために使用されます。

これら以外にも、CLR の他の部分にさまざまな情報を提供する補助的なデータ構造やアルゴリズムが多数存在しますが、システム全体の理解においてはそれほど重要ではありません。

## コンポーネントアーキテクチャ

型システムのデータ構造は、一般にさまざまなアルゴリズムによって共通的に使用されます。本ドキュメントでは型システムのアルゴリズム自体は詳しく説明しません（他の Book of the Runtime のドキュメントで説明されている、またはされるべきものです）が、以下に主要なデータ構造を説明します。

### 依存関係

型システムは一般に CLR の多くの部分にサービスを提供しており、ほとんどのコアコンポーネントは型システムの動作に何らかの形で依存しています。

#### 型システムの依存先

型システムの主な依存先は以下のとおりです：

- **ローダー:** 作業に必要な正しいメタデータを取得するために必要です。
- **メタデータシステム:** 情報を収集するためのメタデータ API を提供します。
- **セキュリティシステム:** 特定の型システム構造（例：継承）が許可されるかどうかを型システムに通知します。
- **AppDomain:** 型システムのデータ構造のメモリ割り当て動作を処理するための LoaderAllocator を提供します。

#### 型システムに依存するコンポーネント

型システムに依存する主要なコンポーネントは 3 つあります：

- **JIT インターフェース** および JIT ヘルパーは、主に型・メソッド・フィールドの検索機能に依存しています。型システムオブジェクトが見つかると、JIT が必要とする情報を提供できるように調整されたデータ構造が返されます。
- **リフレクション** は、型システムを利用して、CLR の型システムデータ構造に取り込まれた ECMA 標準化された概念への比較的シンプルなアクセスを提供します。
- **一般的なマネージドコードの実行** では、型比較ロジックや Virtual Stub Dispatch のために型システムを使用する必要があります。

## 型システムの設計

コアとなる型システムのデータ構造は、実際に読み込まれた型を表すデータ構造（TypeHandle、MethodTable、MethodDesc、TypeDesc、EEClass など）と、読み込まれた型を検索可能にするデータ構造（ClassLoader、Assembly、Module、RidMap など）に分類されます。

型を読み込むためのデータ構造とアルゴリズムについては、Book of the Runtime の [型ローダー](type-loader.md) の章および [MethodDesc](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/method-descriptor.md) の章で説明されています。

これらのデータ構造を結びつけるのが、JIT / リフレクション / 型ローダー / スタックウォーカーが既存の型やメソッドを検索できるようにする一連の機能です。基本的な考え方は、これらの検索が ECMA CLI 仕様で規定されたメタデータトークンやシグネチャによって容易に駆動できるようにすることです。

そして最終的に、適切な型システムのデータ構造が見つかると、型から情報を収集したり、2 つの型を比較したりするアルゴリズムがあります。この種のアルゴリズムの特に複雑な例は、Book of the Runtime の [Virtual Stub Dispatch](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/virtual-stub-dispatch.md) の章で見ることができます。

## 設計目標と非目標

### 目標

- 実行中の（リフレクション以外の）コードが実行時に必要な情報に高速にアクセスできること。
- コンパイル時にコード生成に必要な情報への簡便なアクセスを提供すること。
- ガベージコレクタ / スタックウォーカーが、ロックを取得したりメモリを割り当てたりせずに必要な情報にアクセスできること。
- 最小限の型だけが一度に読み込まれること。
- 型の読み込み時に、その型の最小限の部分だけが読み込まれること。
- 型システムのデータ構造を NGEN イメージに保存できること。

::: tip 💡 初心者向け補足
NGEN (Native Image Generator) は、.NET アセンブリを事前にネイティブコードにコンパイルしておく仕組みです（現在は ReadyToRun が後継）。型システムのデータをこのイメージに保存できるようにすることで、アプリケーションの起動時間を短縮できます。
:::

### 非目標

- メタデータ内のすべての情報が CLR のデータ構造に直接反映されること。
- リフレクションのすべての使用が高速であること。

## 実行時アルゴリズムの典型的な設計 — キャストアルゴリズム

キャスト（型変換）アルゴリズムは、マネージドコードの実行中に頻繁に使用される型システムのアルゴリズムの典型です。

このアルゴリズムには少なくとも **4 つの異なるエントリポイント** があります。各エントリポイントは、可能な限り最高のパフォーマンスを達成するために、異なるファストパスを提供するように選ばれています。

1. オブジェクトを特定の、型等価でなく配列でない型にキャストできるか？
2. オブジェクトをジェネリック変性を実装しないインターフェース型にキャストできるか？
3. オブジェクトを配列型にキャストできるか？
4. ある型のオブジェクトを任意の他のマネージ型にキャストできるか？

最後のもの以外の各実装は、完全に汎用的でないことを代償に、より高速に動作するように最適化されています。

::: tip 💡 初心者向け補足
C# で `(string)obj` や `obj is string` のようなキャストを行うと、内部的にはこのキャストアルゴリズムが呼び出されます。よくあるケースを高速に処理するために、専用の最適化された経路が複数用意されています。
:::

例えば、「親の型にキャストできるか」の確認は、「特定の型等価でない非配列型へのキャスト」の変形であり、単方向リンクリストを辿る単一のループで実装されています。これは可能なキャスト操作のサブセットしか検索できませんが、キャストが強制しようとしている型を調べることで、それが適切なセットかどうかを判定できます。このアルゴリズムは JIT ヘルパー `JIT_ChkCastClass_Portable` に実装されています。

**前提:**

- 専用目的のアルゴリズム実装は、一般的にパフォーマンスの向上をもたらします。
- アルゴリズムの追加バージョンは、克服できないメンテナンス上の問題を引き起こしません。

## 型システムにおける典型的な検索アルゴリズムの設計

型システムには、共通のパターンに従うアルゴリズムが多数あります。

型システムは型を見つけるために一般的に使用されます。これは JIT、リフレクション、シリアライゼーション、リモーティングなど、さまざまな入力によってトリガーされます。

これらのケースにおける型システムへの基本的な入力は以下のとおりです：

- 検索を開始するコンテキスト（Module またはアセンブリのポインタ）
- 初期コンテキストにおいて目的の型を記述する識別子。通常はトークン、またはアセンブリが検索コンテキストの場合は文字列

アルゴリズムはまず識別子をデコードする必要があります。

型検索のシナリオでは、トークンは TypeDef トークン、TypeRef トークン、TypeSpec トークン、または文字列のいずれかです。これらの異なる識別子は、それぞれ異なる形式の検索を引き起こします。

- **TypeDef トークン** は、Module の RidMap での検索を引き起こします。これは単純な配列インデックスです。
- **TypeRef トークン** は、この TypeRef トークンが参照するアセンブリを見つけるための検索を引き起こし、その後、見つかったアセンブリポインタと TypeRef テーブルから取得した文字列を使用して型検索アルゴリズムが再度開始されます。
- **TypeSpec トークン** は、型を見つけるためにシグネチャを解析する必要があることを示します。シグネチャを解析して型の読み込みに必要な情報を取得します。これにより、さらなる型検索が再帰的にトリガーされます。
- **名前 (文字列)** は、アセンブリ間のバインディングに使用されます。TypeDef / ExportedTypes テーブルで一致するものが検索されます。注：この検索はマニフェストモジュールオブジェクトのハッシュテーブルによって最適化されています。

::: tip 💡 初心者向け補足
メタデータトークンとは、.NET アセンブリ（DLL/EXE）のメタデータ内で型・メソッド・フィールドなどを一意に識別する 32 ビットの値です。TypeDef は同じモジュール内の型定義、TypeRef は別モジュールの型への参照、TypeSpec はジェネリック型のインスタンス化など複雑な型を表します。
:::

この設計から、型システムの検索アルゴリズムの共通的な特徴がいくつか明らかになります：

- 検索はメタデータと密接に結合した入力を使用します。特に、メタデータトークンや文字列名が一般的に受け渡されます。また、これらの検索は Module に紐づけられており、Module は .dll ファイルや .exe ファイルに直接対応します。
- パフォーマンスを向上させるためにキャッシュされた情報を使用します。RidMap やハッシュテーブルは、これらの検索を改善するために最適化されたデータ構造です。
- アルゴリズムは通常、入力に基づいて 3〜4 つの異なるパスを持ちます。

この一般的な設計に加えて、いくつかの追加要件が重ねられています：

- **前提:** 既に読み込まれている型の検索は、GC で停止中に実行しても安全です。
- **不変条件:** 既に読み込まれた型は、検索すれば必ず見つかります。
- **課題:** 検索ルーチンはメタデータの読み取りに依存しています。これは一部のシナリオでは不十分なパフォーマンスをもたらす可能性があります。

この検索アルゴリズムは、JIT 中に使用されるルーチンの典型です。以下のような共通の特徴があります：

- メタデータを使用します。
- 多くの場所でデータを探す必要があります。
- データ構造におけるデータの重複は比較的少ないです。
- 通常、深い再帰やループはありません。

これにより、IL ベースの JIT で作業するために必要なパフォーマンス要件と特性を満たすことができます。

## ガベージコレクタが型システムに求める要件

ガベージコレクタは、GC ヒープに割り当てられた型のインスタンスに関する情報を必要とします。これは、すべてのマネージドオブジェクトの先頭にある型システムデータ構造 (MethodTable) へのポインタを通じて行われます。MethodTable には、型のインスタンスの GC レイアウトを記述するデータ構造が付属しています。このレイアウトには 2 つの形式があります（通常の型およびオブジェクト配列用と、値型の配列用）。

::: tip 💡 初心者向け補足
GC ヒープ上のすべてのオブジェクトには、先頭に MethodTable へのポインタが格納されています。GC はこのポインタを使って、そのオブジェクトがどの型のインスタンスであるかを識別し、オブジェクト内のどのフィールドが他のオブジェクトへの参照を持つかを判断します。
:::

- **前提:** 型システムのデータ構造は、その型システムデータ構造で記述された型のマネージドオブジェクトよりも長い寿命を持ちます。
- **要件:** ガベージコレクタには、ランタイムがサスペンドされた状態でスタックウォーカーを実行する要件があります。これについては次のセクションで説明します。

## スタックウォーカーが型システムに求める要件

スタックウォーカー / GC スタックウォーカーは、以下の 2 つのケースで型システムの入力を必要とします：

- スタック上の値型のサイズを調べるため。
- スタック上の値型内の報告すべき GC ルートを見つけるため。

型の遅延読み込みの要求や、（関連する GC 情報のみが異なる）コードの複数バージョン生成の回避に関するさまざまな理由から、CLR は現在、スタック上にあるメソッドのシグネチャのウォーキングを要求しています。この必要性はめったに発生しませんが（スタックウォーカーが非常に特定のタイミングで実行される必要があるため）、信頼性の目標を達成するために、シグネチャウォーカーはスタックウォーキング中に機能できなければなりません。

スタックウォーカーはおよそ 3 つのモードで実行されます：

1. セキュリティまたは例外処理の理由で、現在のスレッドのスタックをウォークする場合。
2. GC のために全スレッドのスタックをウォークする場合（全スレッドが EE によってサスペンドされている）。
3. プロファイラーのために特定のスレッドのスタックをウォークする場合（そのスレッドがサスペンドされている）。

GC スタックウォーキングの場合およびプロファイラーによるスタックウォーキングの場合は、スレッドのサスペンションにより、メモリを割り当てたりほとんどのロックを取得したりすることは安全ではありません。

::: tip 💡 初心者向け補足
スタックウォーカーとは、スレッドの呼び出しスタックを順番に辿っていく仕組みです。GC がオブジェクトの参照を正しく追跡するためには、スタック上にある値型の中にもオブジェクトへの参照（GC ルート）がないかを調べる必要があります。しかし GC の実行中は他のスレッドが停止しているため、ロックの取得やメモリの割り当てが許されない厳しい制約の下で動作しなければなりません。
:::

このことから、型システムには上記の要件に従うことが保証できる経路が開発されています。

型システムがこの目標を達成するために必要なルールは以下のとおりです：

- メソッドが呼び出された場合、そのメソッドのすべての値型パラメータは、プロセス内のいずれかの AppDomain に読み込まれている必要があります。
- シグネチャを持つアセンブリから型を実装するアセンブリへのアセンブリ参照は、スタックウォークの一部としてシグネチャのウォーキングが必要になる前に解決されている必要があります。

これは、型ローダー、NGEN イメージ生成プロセス、および JIT 内の広範かつ複雑な一連の強制によって実現されています。

- **課題:** 型システムに対するスタックウォーカーの要件は**非常に脆弱**です。
- **課題:** 型システムにおけるスタックウォーカー要件の実装は、読み込み済みの型を検索中に触れる可能性のある型システムのすべての関数に、一連のコントラクト違反を必要とします。
- **課題:** 実行されるシグネチャのウォークは、通常のシグネチャウォーキングコードで行われます。このコードはシグネチャをウォークしながら型を読み込むように設計されていますが、このケースでは実際には型の読み込みがトリガーされないという前提で型の読み込み機能が使用されます。
- **課題:** スタックウォーカーの要件は、型システムだけでなくアセンブリローダーからのサポートも必要とします。ローダーは、型システムのこのニーズを満たすにあたって多くの問題を抱えています。

## 静的変数

CoreCLR における静的変数は、「静的ベース」の取得と、そこからオフセットを加算して実際の値へのポインタを得るという組み合わせによって処理されます。
静的ベースは、各フィールドに対して非 GC または GC のいずれかとして定義されます。
現在、非 GC 静的変数はプリミティブ型（byte、sbyte、char、int、uint、long、ulong、float、double、各種ポインタ）および列挙型で表される静的変数です。
GC 静的変数はクラスまたは非プリミティブ値型で表される静的変数です。
GC 静的変数である値型の静的変数の場合、静的変数は実際にはその値型のボックス化されたインスタンスへのポインタです。

### 型ごとの静的変数情報

.NET 9 以降、静的変数のベースはすべてそれぞれの型に関連付けられるようになりました。
静的変数のデータは、`MethodTable` を起点として、`DynamicStaticsInfo` を取得して静的変数ポインタを得るか、`ThreadStaticsInfo` を取得して TLSIndex を得て、そこからスレッド静的変数システムを使用して実際のスレッド静的変数ベースを取得することでアクセスできます。

上記の構造では、非 GC と GC の静的変数、およびスレッド静的変数と通常の静的変数に対して別々のフィールドがあります。
通常の静的変数については、ポインタサイズのフィールドを 1 つ使用し、クラスコンストラクタが実行されたかどうかもエンコードしています。
これは、静的フィールドのアドレス取得とクラスコンストラクタのトリガーが必要かどうかの判定の両方を、ロックフリーなアトミックアクセスで行えるようにするためです。
TLS 静的変数については、クラスコンストラクタの実行済み検出はスレッド静的変数インフラストラクチャの一部として説明される、より複雑なプロセスです。
`DynamicStaticsInfo` および `ThreadStaticsInfo` 構造体はロックなしでアクセスされるため、メモリ順序のティアリング問題を避けるために、これらの構造体のフィールドへのアクセスが単一のメモリアクセスで行えることが重要です。

また、ジェネリック型の場合、各フィールドには型インスタンスごとに割り当てられる `FieldDesc` があり、複数の正規インスタンス間で共有されません。

### コレクティブルアセンブリの静的変数のライフタイム管理

CoreCLR ランタイムにはコレクティブルアセンブリ（収集可能なアセンブリ）の概念があるため、静的変数のライフタイム管理が必要です。
選択されたアプローチは、ランタイムのデータ構造が GC ヒープ上のマネージドオブジェクトの内部へのポインタを持てるように、特殊な GC ハンドル型を構築することです。

ここでの動作要件は、静的変数が自身のコレクティブルアセンブリを存続させてはならないということです。そのため、コレクティブル静的変数は、コレクティブルアセンブリが最終的に収集される前に存在してファイナライズされ得るという特殊な性質を持っています。復活シナリオがある場合、これは非常に予想外の動作につながる可能性があります。

### スレッド静的変数

スレッド静的変数は、静的変数を含む型のライフタイムと、静的変数がアクセスされるスレッドのライフタイムのうち、短い方として定義されるライフタイムを持つ静的変数です。
型の静的変数に `[System.Runtime.CompilerServices.ThreadStaticAttribute]` を付与することで作成されます。
一般的な仕組みとしては、すべてのスレッドで同一の「インデックス」を型に割り当て、各スレッドではこのインデックスによって効率的にアクセスできるデータ構造を保持するというものです。

::: tip 💡 初心者向け補足
スレッド静的変数は `[ThreadStatic]` 属性が付いた静的フィールドで、スレッドごとに独立した値を持ちます。例えば、各スレッドが独自のキャッシュやコンテキスト情報を保持する場合に使用されます。通常の静的変数はプロセス全体で共有されますが、スレッド静的変数はスレッドごとに別々のストレージが確保されます。
:::

このアプローチにはいくつかの特殊な点があります：

1. コレクティブルと非コレクティブルのスレッド静的変数を分離しています（`TLSIndexType::NonCollectible` と `TLSIndexType::Collectible`）。
2. ネイティブ CoreCLR コードとマネージドコードの間で非 GC スレッド静的変数を共有する機能を提供しています（`TLSIndexType::DirectOnThreadLocalData` のサブセット）。
3. 少数の非 GC スレッド静的変数に対して、非常に効率的なアクセス手段を提供しています（`TLSIndexType::DirectOnThreadLocalData` の残りの用途）。

#### スレッド静的変数のアクセスパターン

`DirectOnThreadLocalData` でないスレッド静的変数に対して JIT が使用するパターンは以下のとおりです：

0. 何らかの方法で TLS インデックスを取得する。
1. 現在のスレッドの OS 管理 TLS ブロックへの TLS ポインタを取得する。すなわち `pThreadLocalData = &t_ThreadStatics`。
2. 整数値を 1 つ読み取る：`pThreadLocalData->cCollectibleTlsData` または `pThreadLocalData->cNonCollectibleTlsData`。
3. `cTlsData` を検索しようとしているインデックスと比較する：`if (cTlsData < index.GetIndexOffset())`。
4. インデックスが範囲外の場合、ステップ 11 にジャンプする。
5. TLS ブロックからポインタ値を 1 つ読み取る：`pThreadLocalData->pCollectibleTlsArrayData` または `pThreadLocalData->pNonCollectibleTlsArrayData`。
6. TLS 配列内からポインタを 1 つ読み取る：`pTLSBaseAddress = *(intptr_t*)(((uint8_t*)pTlsArrayData) + index.GetIndexOffset())`。
7. ポインタが NULL の場合、ステップ 11 にジャンプする。
8. TLS インデックスが Collectible インデックスでない場合、`pTLSBaseAddress` を返す。
9. `ObjectFromHandle((OBJECTHANDLE)pTLSBaseAddress)` が NULL の場合、ステップ 11 にジャンプする。
10. `ObjectFromHandle((OBJECTHANDLE)pTLSBaseAddress)` を返す。
11. ヘルパーをテールコールする：`return GetThreadLocalStaticBase(index)`。

`DirectOnThreadLocalData` 上のスレッド静的変数に対して JIT が使用するパターンは以下のとおりです：

0. 何らかの方法で TLS インデックスを取得する。
1. 現在のスレッドの OS 管理 TLS ブロックへの TLS ポインタを取得する。すなわち `pThreadLocalData = &t_ThreadStatics`。
2. ThreadLocalData 構造体の先頭にインデックスオフセットを加算する：`pTLSBaseAddress = ((uint8_t*)pThreadLocalData) + index.GetIndexOffset()`。

#### スレッド静的変数のライフタイム管理

効率性のために、コレクティブルと非コレクティブルのスレッド静的変数を区別しています。

非コレクティブルなスレッド静的変数は、ランタイムによって収集できない型に定義されたスレッド静的変数です。これは実際に観測されるほとんどのスレッド静的変数に該当します。`DirectOnThreadLocalData` 静的変数は、特別に最適化された形式を持ち GC 報告を必要としない、このカテゴリのサブセットです。非コレクティブルスレッド静的変数の場合、`ThreadLocalData` 内のポインタ（`pNonCollectibleTlsArrayData`）は、`object[]`、`byte[]`、または `double[]` 配列を指すマネージド `object[]` へのポインタです。GC スキャン時には、最初の `object[]` へのポインタだけを GC に報告すればよいです。

コレクティブルなスレッド静的変数は、ランタイムによって収集可能な型に定義されたスレッド静的変数です。`ThreadLocalData` 内のポインタ（`pCollectibleTlsArrayData`）は `malloc` で割り当てられたメモリチャンクへのポインタであり、`object[]`、`byte[]`、または `double[]` 配列へのポインタを保持します。GC スキャン時には、型とスレッドの両方がまだ生きている場合にのみ、各マネージドオブジェクトを個別に存続させる必要があります。これにはいくつかの状況を適切に処理する必要があります：

1. コレクティブルアセンブリが参照されなくなっても、それに関連するスレッド静的変数にファイナライザがある場合、オブジェクトはファイナライゼーションキューに移動する必要があります。
2. コレクティブルアセンブリに関連するスレッド静的変数が一連のオブジェクト参照を通じてコレクティブルアセンブリの `LoaderAllocator` を参照している場合、コレクティブルアセンブリが参照されていると見なされる理由を提供してはなりません。
3. コレクティブルアセンブリが収集された場合、関連する静的変数はもはや存在せず、そのコレクティブルアセンブリに関連する TLSIndex 値は再利用可能になります。
4. スレッドが実行を終了した場合、そのスレッドに関連するすべてのスレッド静的変数は存続させません。

選択されたアプローチは、2 つの異なるハンドル型を使用することです。効率的なアクセスのために、動的に調整される配列に格納されるハンドル型は WeakTrackResurrection GCHandle です。このハンドルインスタンスは正確なインスタンス化ではなく TLS データ内のスロットに関連付けられているため、関連するコレクティブルアセンブリが収集された後にスロットが再利用される場合に再利用できます。さらに、使用中の各スロットにはオブジェクトを `LoaderAllocator` が解放されるまで存続させる `LOADERHANDLE` があります。この `LOADERHANDLE` は `LoaderAllocator` が収集された場合に放棄されますが、`LOADERHANDLE` は `LoaderAllocator` が収集されない場合にのみクリーンアップが必要なため問題ありません。スレッドの破棄時には、TLS 配列内の各コレクティブルスロットについて、正しい `LoaderAllocator` 上の `LOADERHANDLE` を明示的に解放します。

## 主要なデータ構造

### MethodTable

MethodTable は、型システムにおける中心的な実行時データ構造です。すべてのマネージドオブジェクトの先頭にはこのデータ構造へのポインタが格納されており、ランタイムが型に関する情報に素早くアクセスするために必要なすべての情報を含んでいます。

::: tip 💡 初心者向け補足
MethodTable は型ごとに 1 つだけ存在し、その型のすべてのインスタンス（オブジェクト）から共有されます。例えば `string` 型のオブジェクトが 1000 個あっても、MethodTable は 1 つだけです。各オブジェクトの先頭にある MethodTable ポインタが、GC やキャストなどの操作で型を識別するために使用されます。
:::

MethodTable には以下のような情報が含まれます：

- 親の型（基底クラス）への参照
- 実装するインターフェースのリスト
- 仮想メソッドテーブル（v-table）
- GC レイアウト情報
- 型のサイズやフラグなどの基本情報

### EEClass

EEClass は、型の読み込み、JIT コンパイル、リフレクションに必要だが、実行時の高速パスでは不要な「コールド」データを格納するデータ構造です。

::: tip 💡 初心者向け補足
「コールド」データとは、アクセス頻度の低いデータのことです。MethodTable にすべての情報を詰め込むとメモリ効率が悪くなるため、アクセス頻度の低い情報は EEClass に分離されています。同じジェネリック型の異なるインスタンス化（例：`List<int>` と `List<string>`）は、EEClass を共有する場合があります。
:::

### MethodDesc

MethodDesc は個々のメソッドを記述するデータ構造です。メソッドのメタデータトークン、メソッドの属性、ネイティブコードへのエントリポイントなどの情報を含みます。

### FieldDesc

FieldDesc は個々のフィールドを記述するデータ構造です。フィールドのオフセット、型、属性などの情報を含みます。

### TypeDesc

TypeDesc は MethodTable だけでは表現できない型を記述するために使用されるデータ構造です。具体的には以下の型が含まれます：

- **ByRef 型:** 参照渡しパラメータ（`ref int` など）
- **ポインタ型:** アンマネージドポインタ（`int*` など）
- **関数ポインタ型:** 関数ポインタ
- **ジェネリック型変数:** `T` や `U` などのジェネリックパラメータ

### ClassLoader

ClassLoader は型を読み込むために使用されるコンポーネントです。メタデータから型情報を読み取り、上記のデータ構造を生成します。詳細は [型ローダー](type-loader.md) の章を参照してください。

## 物理アーキテクチャ

型システムの主要部分は以下のソースファイルに含まれています：

- **Class.cpp/inl/h** – EEClass の関数、および BuildMethodTable
- **MethodTable.cpp/inl/h** – MethodTable の操作関数
- **TypeDesc.cpp/inl/h** – TypeDesc の検査関数
- **MetaSig.cpp / SigParser** – シグネチャ関連のコード
- **FieldDesc / MethodDesc** – これらのデータ構造の検査関数
- **Generics** – ジェネリクス固有のロジック
- **Array** – 配列処理に必要な特殊ケースの処理コード
- **VirtualStubDispatch.cpp/h/inl** – Virtual Stub Dispatch のコード
- **VirtualCallStubCpu.hpp** – Virtual Stub Dispatch のプロセッサ固有コード
- **threadstatics.cpp/h** – スレッド静的変数の処理

主要なエントリポイントは `BuildMethodTable`、`LoadTypeHandleThrowing`、`CanCastTo*`、`GetMethodDescFromMemberDefOrRefOrSpecThrowing`、`GetFieldDescFromMemberRefThrowing`、`CompareSigs`、および `VirtualCallStubManager::ResolveWorkerStatic` です。

## 関連資料

- [ECMA CLI 仕様](https://www.ecma-international.org/publications-and-standards/standards/ecma-335/)
- [型ローダー](type-loader.md) — Book of the Runtime の章
- [Virtual Stub Dispatch](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/virtual-stub-dispatch.md) — Book of the Runtime の章
- [MethodDesc](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/method-descriptor.md) — Book of the Runtime の章
