# 型ローダー

::: info 原文
この章の原文は [Type Loader](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/type-loader.md) です。
:::

## はじめに

クラスベースのオブジェクト指向システムでは、型はインスタンスが含むデータと提供する機能を記述するテンプレートです。型を定義せずにオブジェクトを作成することはできません。2つのオブジェクトが同じメンバーのセットを定義していても、同じ型のインスタンスでない限り、関連性はありません。

CLR に不可欠な追加機能は、完全なランタイム型情報の利用可能性です。マネージドコードを「管理」し型安全な環境を提供するために、ランタイムは任意の時点で任意のオブジェクトの型を知る必要があります。型の同一性クエリは頻繁に行われるため（例：すべての型キャストは型の同一性を検証する必要がある）、型情報は大規模な計算なしに即座に利用可能でなければなりません。

::: tip 💡 初心者向け補足
「型ローダー」は、プログラムで使われる型（クラスや構造体など）の情報をメモリ上に構築するコンポーネントです。C# で `new MyClass()` と書くと、裏側では型ローダーが `MyClass` の情報（メソッド、フィールド、継承関係など）をメモリ上に準備しています。
:::

## 設計目標

型ローダーの究極の目的は、ロードを要求された型を表すデータ構造を構築することです。型ローダーが持つべき特性は以下の通りです：

- **高速な型検索**: [モジュール, トークン] → ハンドル、[アセンブリ, 名前] → ハンドルの検索が高速であること
- **最適化されたメモリレイアウト**: ワーキングセットサイズ、キャッシュヒット率、JIT コード性能が良好であること
- **型安全性**: 不正な型はロードされず、`TypeLoadException` がスローされること
- **並行性**: マルチスレッド環境で良好にスケールすること

## 型ローダーのアーキテクチャ

型ローダーへのエントリポイントは比較的少数です。それぞれのエントリポイントは、メタデータ**トークン**または**名前**文字列の形式で型/メンバーの指定、トークンのスコープ（**モジュール**または**アセンブリ**）、およびフラグなどの追加情報を受け取ります。ロードされたエンティティは**ハンドル**の形式で返されます。

::: tip 💡 初心者向け補足
メタデータトークンとは、.NET のアセンブリ（DLL/EXE）内で型やメソッドを識別するための番号のことです。JIT コンパイラがコードをコンパイルする際、IL コード中のトークンを型ローダーに渡して、実際の型情報を取得します。
:::

### JIT コンパイル時の型ロード

JIT コンパイル中には通常、型ローダーへの多くの呼び出しが発生します。例えば：

```csharp
object CreateClass()
{
    return new MyClass();
}
```

IL 内で `MyClass` はメタデータトークンを使って参照されます。`JIT_New` ヘルパーへの呼び出しを生成するために、JIT は型ローダーに型のロードとハンドルの返却を要求します。このハンドルは JIT コンパイルされたコードに即値として直接埋め込まれます。

## 主要なデータ構造

- **`TypeHandle`** - CLR における最も普遍的な型の指定。`MethodTable`（通常の型）または `TypeDesc`（byref、ポインタ、関数ポインタ、ジェネリック変数）へのポインタを抽象化したもの。
- **`MethodTable`** - ランタイムの中心的なデータ構造。親型、実装インターフェース、v-table など、迅速な検索が必要なすべての情報を含む。
- **`EEClass`** - 型ロード、JIT、リフレクションで必要な「コールド」データを格納。ジェネリック型の間で共有される。
- **`MethodDesc`** - メソッドを記述する構造体。
- **`FieldDesc`** - フィールドを記述する構造体。
- **`TypeDesc`** - byref 型、ポインタ型、関数ポインタ型、ジェネリック変数を表現。

::: tip 💡 初心者向け補足
`MethodTable` と `EEClass` の分離は、パフォーマンスのための設計です。頻繁にアクセスされる「ホット」なデータ（`MethodTable`）と、たまにしかアクセスされない「コールド」なデータ（`EEClass`）を分けることで、CPU キャッシュの効率を向上させています。
:::

## ロードレベル

型ローダーは型を一度にすべてロードするのではなく、段階的にロードします。これは型が通常、他の型に依存するためです。例えば：

```csharp
class A<T> : C<B<T>> { }
class B<T> : C<A<T>> { }
class C<T> { }
```

`A` は `B` に依存し、`B` は `A` に依存しています。ローダーは最初に他の型をロードせずに取得できるデータで構造を初期化し、その後段階的に情報を追加していきます。

ロードレベルは `CLASS_LOAD_BEGIN` から始まり、`CLASS_LOADED` で終わり、間にいくつかの中間レベルがあります。

## ジェネリクス

### 用語

- **ジェネリックパラメータ**: 他の型で置換されるプレースホルダー。`List<T>` の `T`。
- **ジェネリック引数**: ジェネリックパラメータに置換される型。`List<int>` の `int`。
- **ジェネリック制約**: ジェネリック引数に対する要件（参照型制約 `class`、値型制約 `struct`、コンストラクタ制約 `new()`、基底型制約、インターフェース制約）。
- **インスタンス化**: ジェネリックパラメータに置換されたジェネリック引数のリスト。
- **典型的インスタンス化**: 型自身のパラメータのみで構成されるインスタンス化。
- **正規インスタンス化**: すべてのジェネリック引数が `System.__Canon` であるインスタンス化。共有情報の代表として使用。

### 共有

ジェネリクスの導入により、ロードされる型の数は増加する傾向があります。しかし、異なるインスタンス化（例：`List<string>` と `List<object>`）間で多くの情報を共有できます。

現在、参照型を含むすべてのインスタンス化は同じ `EEClass` と `MethodDesc` を共有しています。すべての参照は同じサイズ（4バイトまたは8バイト）であるため、これらの型のレイアウトは同じになります。値型のみを含むインスタンス化は共有されず、独自の `EEClass` を持ちます。

::: tip 💡 初心者向け補足
`List<string>` と `List<object>` は異なる型ですが、内部的には多くの情報を共有しています。これは、参照型（クラス）のポインタサイズがすべて同じであるためです。一方、`List<int>` と `List<double>` は値型のサイズが異なるため、共有できません。この「共有」の仕組みにより、ジェネリクスを多用してもメモリの消費を抑えることができます。
:::
