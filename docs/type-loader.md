# 型ローダーの設計

::: info 原文
この章の原文は [Type Loader Design](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/type-loader.md) です。
:::

著者: Ladi Prosek - 2007

## はじめに

クラスベースのオブジェクト指向システムでは、型 (type) は個々のインスタンスが含むデータと提供する機能を記述するテンプレートです。型を定義せずにオブジェクトを作成することはできません<sup>1</sup>。2つのオブジェクトが同じ型であるとは、同じ型のインスタンスである場合に限ります。まったく同じメンバーのセットを定義していても、同じ型のインスタンスでなければ、それらは何の関連性も持ちません。

前述の内容は、典型的な C++ のシステムにも当てはまります。CLR に不可欠な追加機能は、完全なランタイム型情報の利用可能性です。マネージドコードを「管理」し型安全な環境を提供するために、ランタイムは任意の時点で任意のオブジェクトの型を知る必要があります。型の同一性クエリは頻繁に行われることが予想されるため（例：すべての型キャストはキャストが安全かつ実行可能かを検証するために型の同一性を問い合わせます）、このような型情報は大規模な計算なしに即座に利用可能でなければなりません。

::: tip 💡 初心者向け補足
「型ローダー」は、プログラムで使われる型（クラスや構造体など）の情報をメモリ上に構築するコンポーネントです。C# で `new MyClass()` と書くと、裏側では型ローダーが `MyClass` の情報（メソッド、フィールド、継承関係など）をメモリ上に準備しています。Java の「クラスローダー」に似た役割ですが、CLR ではクラスだけでなく値型も含むすべての型を扱います。
:::

このパフォーマンス要件により、辞書検索のようなアプローチは除外され、以下の高レベルアーキテクチャが導かれます。

![図1](./images/typeloader-fig1.png)

図1 抽象的な高レベルオブジェクト設計

実際のインスタンスデータの他に、各オブジェクトは型を表す構造体への単純なポインタである型 ID を含みます。この概念は C++ の v-table ポインタに似ていますが、ここで TYPE と呼び後ほどより正確に定義する構造体は、v-table 以上のものを含みます。例えば、「is-a」包含関係の質問に答えるために階層に関する情報を含む必要があります。

<sup>1</sup> C# 3.0 の「匿名型 (anonymous types)」機能では、型への明示的な参照なしに、フィールドを直接列挙するだけでオブジェクトを定義できます。しかしこれに惑わされないでください。実際にはコンパイラが裏側で型を作成しています。

## 1.1 関連資料

[1] Martin Abadi, Luca Cardelli, A Theory of Objects, ISBN 978-0387947754

[2] Andrew Kennedy ([@andrewjkennedy](https://github.com/andrewjkennedy)), Don Syme ([@dsyme](https://github.com/dsyme)), [Design and Implementation of Generics for the .NET Common Language Runtime][generics-design]

[generics-design]: http://research.microsoft.com/apps/pubs/default.aspx?id=64031

[3] [ECMA Standard for the Common Language Infrastructure (CLI)](https://www.ecma-international.org/publications-and-standards/standards/ecma-335)

## 1.2 設計目標

型ローダー（クラスローダーと呼ばれることもありますが、厳密には正しくありません。クラスは型のサブセット、すなわち参照型のみを指し、ローダーは値型もロードするためです）の究極の目的は、ロードを要求された型を表すデータ構造を構築することです。型ローダーが持つべき特性は以下の通りです：

- **高速な型検索**: [モジュール, トークン] → ハンドル、および [アセンブリ, 名前] → ハンドルの検索が高速であること。
- **最適化されたメモリレイアウト**: ワーキングセットサイズ、キャッシュヒット率、JIT コンパイル済みコードの性能が良好であること。
- **型安全性**: 不正な形式の型はロードされず、`TypeLoadException` がスローされること。
- **並行性 (concurrency)**: マルチスレッド環境で良好にスケールすること。

## 2 型ローダーのアーキテクチャ

型ローダーへのエントリポイントは比較的少数です。各エントリポイントのシグネチャはわずかに異なりますが、いずれも同様のセマンティクスを持ちます。メタデータ**トークン**または**名前**文字列の形式で型/メンバーの指定、トークンのスコープ（**モジュール**または**アセンブリ**）、およびフラグなどの追加情報を受け取ります。ロードされたエンティティは**ハンドル**の形式で返されます。

::: tip 💡 初心者向け補足
メタデータトークン (metadata token) とは、.NET のアセンブリ（DLL/EXE）内で型やメソッドを識別するための番号のことです。JIT コンパイラがコードをコンパイルする際、IL コード中のトークンを型ローダーに渡して、実際の型情報を取得します。Java でいえば、クラスファイル内の「コンスタントプール」のインデックスに似た概念です。
:::

JIT コンパイル中には通常、型ローダーへの多くの呼び出しが発生します。以下の例を考えてみましょう：

```csharp
object CreateClass()
{
    return new MyClass();
}
```

IL 内で `MyClass` はメタデータトークンを使って参照されます。実際のインスタンス化を処理する `JIT_New` ヘルパーへの呼び出しを生成するために、JIT は型ローダーに型のロードとハンドルの返却を要求します。このハンドルは JIT コンパイルされたコードに即値 (immediate value) として直接埋め込まれます。型やメンバーが通常、実行時ではなく JIT 時に解決・ロードされるという事実は、以下のようなコードで遭遇しやすい、時に混乱を招く動作を説明しています：

```csharp
object CreateClass()
{
    try {
        return new MyClass();
    } catch (TypeLoadException) {
        return null;
    }
}
```

もし `MyClass` がロードに失敗した場合（例えば、別のアセンブリで定義されるはずが最新のビルドで誤って削除された場合）、このコードは依然として `TypeLoadException` をスローします。catch ブロックがキャッチしなかった理由は、そもそも実行されなかったからです！例外は JIT コンパイル中に発生し、`CreateClass` を呼び出して JIT コンパイルを引き起こしたメソッドでのみキャッチ可能です。さらに、インライン化により JIT コンパイルがどの時点でトリガーされるかは必ずしも明らかではないため、ユーザーは決定論的な動作を期待したり依存したりすべきではありません。

::: tip 💡 初心者向け補足
上記の `try-catch` の例は重要なポイントです。JIT コンパイルはメソッドが初めて呼び出されるタイミングで行われます。つまり、`new MyClass()` の型ロードエラーはメソッドの実行時ではなく JIT コンパイル時に発生するため、メソッド内の `catch` ブロックでは捕捉できません。Java のクラスローダーと異なり、.NET の型ロードは JIT コンパイルの一部として事前に行われることに注意してください。
:::

## 主要データ構造

CLR における最も普遍的な型の指定は `TypeHandle` です。`TypeHandle` は、`MethodTable`（`System.Object` や `List<string>` のような「通常の」型を表す）または `TypeDesc`（byref、ポインタ、関数ポインタ、ジェネリック変数を表す）のいずれかへのポインタをカプセル化する抽象的なエンティティです。`TypeHandle` は型の同一性 (identity) を構成し、2つのハンドルが等しいのはそれらが同じ型を表す場合に限ります。領域を節約するため、`TypeHandle` が `TypeDesc` を含むという事実は、追加のフラグを使う代わりにポインタの最下位から2番目のビットを1に設定する（すなわち `(ptr | 2)`）ことで示されます<sup>2</sup>。`TypeDesc` は「抽象的」であり、以下の継承階層を持ちます。

![図2](./images/typeloader-fig2.png)

図2 TypeDesc の階層

**`TypeDesc`**

抽象的な型記述子 (type descriptor)。具象的な記述子の種類はフラグによって決定されます。

**`TypeVarTypeDesc`**

型変数を表します。すなわち `List<T>` の `T` や `Array.Sort<T>` の `T` です（後述のジェネリクスの項を参照）。型変数は複数の型やメソッド間で共有されることはなく、各変数にはただ1つの所有者があります。

**`FnPtrTypeDesc`**

関数ポインタ (function pointer) を表します。本質的には戻り値の型とパラメータを参照する型ハンドルの可変長リストです。元々はマネージド C++ でのみ使用されていましたが、C# 9 以降では C# でもサポートされています。

**`ParamTypeDesc`**

byref 型とポインタ型を表す記述子です。byref は C# のメソッドパラメータに適用される `ref` および `out` キーワードの結果であり<sup>3</sup>、ポインタ型はアンセーフ C# およびマネージド C++ で使用されるデータへのアンマネージドポインタです。

**`MethodTable`**

これはランタイムの中心的なデータ構造です。上記のカテゴリのいずれにも該当しない型を表します（プリミティブ型、および「オープン」と「クローズド」の両方のジェネリック型を含みます）。親型、実装インターフェース、v-table など、迅速な検索が必要な型に関するすべての情報を含みます。

**`EEClass`**

`MethodTable` のデータは、ワーキングセットとキャッシュの利用効率を向上させるために「ホット」と「コールド」の構造体に分割されています。`MethodTable` 自体はプログラムの定常状態で必要な「ホット」データのみを格納することを意図しています。`EEClass` は型ロード、JIT コンパイル、またはリフレクションでのみ一般的に必要とされる「コールド」データを格納します。各 `MethodTable` は1つの `EEClass` を指します。

さらに、`EEClass` はジェネリック型間で共有されます。複数のジェネリック型の `MethodTable` が1つの `EEClass` を指すことが可能です。この共有により、`EEClass` に格納できるデータに追加の制約が生じます。

::: tip 💡 初心者向け補足
`MethodTable` と `EEClass` の分離は、パフォーマンスのための設計パターンです。頻繁にアクセスされる「ホット」なデータ（v-table、インターフェースマップなど）と、たまにしかアクセスされない「コールド」なデータ（リフレクション情報など）を分けることで、CPU キャッシュの効率を向上させています。この「ホット/コールド分離」は、データベースのインデックス設計や Web アプリケーションのキャッシュ戦略と同じ発想です。
:::

**`MethodDesc`**

この構造体がメソッドを記述することは驚くに値しません。実際にはいくつかのバリエーションがあり、対応する `MethodDesc` のサブタイプが存在しますが、そのほとんどはこのドキュメントの範囲外です。ジェネリクスにおいて重要な役割を果たす `InstantiatedMethodDesc` というサブタイプが1つあることだけを述べておきます。詳細については [**メソッド記述子の設計**](method-descriptor.md) を参照してください。

**`FieldDesc`**

`MethodDesc` と同様に、この構造体はフィールドを記述します。特定の COM 相互運用 (COM interop) シナリオを除いて、EE はプロパティやイベントをまったく気にしません。なぜならそれらは結局のところメソッドとフィールドに帰着し、コンパイラとリフレクションが構文糖 (syntactic sugar) のような体験を提供するためにそれらを生成・解釈するだけだからです。

<sup>2</sup> これはデバッグに有用です。`TypeHandle` の値が 2、6、A、または E で終わる場合、それは `MethodTable` ではなく、`TypeDesc` を正常に検査するためには余分なビットをクリアする必要があります。

<sup>3</sup> `ref` と `out` の違いはパラメータ属性にあるだけです。型システムに関する限り、それらは両方とも同じ型です。

## 2.1 ロードレベル

型ローダーが指定された型のロードを要求されたとき（例えば typedef/typeref/typespec **トークン** と **モジュール** によって識別される型）、すべての作業を一度にアトミックに行うわけではありません。ロードは段階的に行われます。その理由は、型は通常他の型に依存しており、他の型から参照される前に完全にロードされることを要求すると、無限再帰やデッドロックが発生するためです。以下の例を考えてみましょう：

```csharp
class A<T> : C<B<T>>
{ }

class B<T> : C<A<T>>
{ }

class C<T>
{ }
```

これらは有効な型であり、明らかに `A` は `B` に依存し、`B` は `A` に依存しています。

ローダーは最初に型を表す構造体を作成し、他の型をロードせずに取得できるデータで初期化します。この「依存関係なし」の作業が完了すると、構造体は他の場所から参照可能になります（通常は他の構造体にポインタを挿入することによって）。その後、ローダーはインクリメンタルなステップで進行し、構造体にますます多くの情報を追加して、最終的に完全にロードされた型に到達します。上記の例では、`A` と `B` の基底型は最初に他の型を含まない近似で置き換えられ、後で本物に置換されます。

正確な半ロード状態は、いわゆるロードレベル (load level) によって記述されます。`CLASS_LOAD_BEGIN` から始まり、`CLASS_LOADED` で終わり、間にいくつかの中間レベルがあります。個々のロードレベルに関する豊富で有用なコメントが [classloadlevel.h](https://github.com/dotnet/runtime/blob/main/src/coreclr/vm/classloadlevel.h) ソースファイルにあります。

ロードレベルのより詳細な説明については、[Design and Implementation of Generics for the .NET Common Language Runtime][generics-design] を参照してください。

::: tip 💡 初心者向け補足
ロードレベルは、型の「準備状態」を段階的に表す仕組みです。型同士が相互に依存する場合（例：`A` が `B` を継承し、`B` も `A` を参照する）、すべてを一度にロードすると無限ループに陥ります。そのため、CLR は型を「大まかな情報だけ準備」→「詳細な情報を追加」→「完全にロード完了」と段階的に構築します。これは、ビルシステムにおける循環依存の解決と同じ考え方です。
:::

### 2.1.1 型ローダー内でのロードレベルの使用

型ローダー内で、型ローダーのさまざまな部分で動作している間、どのロードレベルを使用できるかについてさまざまな異なるルールが適用されます。

#### 2.1.1.1 `ClassLoader::CreateTypeHandleForTypeDefThrowing` および `MethodTableBuilder::BuildMethodTableThrowing` 内のコード

`ClassLoader::CreateTypeHandleForTypeDefThrowing` 内のコードを `MethodTableBuilder::BuildMethodTableThrowing` の呼び出し前に実行している間、ロード中の型の `MethodTable` に依存するロジックは使用できません。これは、これらのルーチンが `MethodTable` を構築するルーチンであるという詳細に起因します。

これにはさまざまな影響がありますが、最も明白なのは、ロード中の型の基底型と関連するインターフェースまたはフィールド型を `CLASS_LOAD_APPROXPARENTS` を超えてロードすると、`TypeLoadException` をトリガーするリスクが生じるということです。例えば、基底型を `CLASS_LOAD_EXACTPARENTS` までロードした場合、`B<A>` から派生する型 `A` をロードできなくなります。このルールの例外は存在し、型ロードプロセスを実際に実装するために必要ですが、一般的には避けるべきです。なぜならそれらは ECMA 仕様と一致しない動作を引き起こすためです。

#### 2.1.1.2 `ClassLoader::DoIncrementalLoad` 内のコード

`DoIncrementalLoad` 中に実行されるコードは、一般的に、インクリメンタルにロードしようとしているレベルか、ロード中の型が既に到達しているレベルのいずれかへの型ロードを要求することが許可されています。ここでの区別は、型間の関係が循環的 (circular) か非循環的 (non-circular) かという点です。型パラメータとの関係のような循環的関係は、目標のロードレベルより低いレベルにのみロードできます。非循環的関係は、インクリメンタル操作が最終的に到達するロードレベルまでロードすることを要求できます。

例えば、型からその基底型への関係は非循環的です。型が推移的に自身の正確な基底型になることはできないためです。しかし、型からその基底型のインスタンス化引数への関係は循環的になり得ます。

上記のルールの例として、`class A : B<A> {}` という型を考えてみましょう。クラス `A` を `CLASS_LOAD_EXACTPARENTS` までロードするとき、基底型 `B<A>` を `CLASS_LOAD_EXACTPARENTS` までロードすることを要求できます（非循環的関係であるため）。しかし、`B<A>` を `CLASS_LOAD_EXACTPARENTS` までロードするとき、型 `A` を `CLASS_LOAD_EXACTPARENTS` までロードすることを要求することはできません（循環性の問題が生じるため）。したがって、`B<A>` を `CLASS_LOAD_EXACTPARENTS` までロードする際には、`A` は `CLASS_LOAD_APPROXPARENTS` までしかロードを強制できません。

`ClassLoader::DoIncrementalLoad` で実行されるコードは、比較的単純なパターンに従います。コードは型が特定のロードレベルまでロードされていることに依存でき、インクリメンタルロードプロセスが特定のレベルで完了すると、ロード中の型のロードレベルがインクリメントされます。

#### 2.1.1.3 `PushFinalLevels` 内のコード

型ロードの最後の2つのレベルは、異なるルールセットに従う `PushFinalLevels` によって処理されます。`PushFinalLevels` はレベルを上げるために、他の型が目標レベルよりも低いレベルまでロードされていることにのみ依存できるコードを実行します。しかし、型がより高いレベルに到達したとマークする前に、`PushFinalLevels` は他の型にも新しいレベルへの `PushFinalLevels` アルゴリズムの完了を要求できます。すべての型が新しいレベルに到達したことが確認された場合にのみ、型のセット全体が新しいレベルに到達したとマークできます。

### 2.1.2 型ローダー外でのロードレベルの使用

一般的な場合、型ローダーの一部ではないコードを操作する際にはロードレベルを単に無視し、完全にロードされた型を要求することが望ましいです。これがデフォルトであり、常に機能的に正しい選択です。ただし、パフォーマンス上の理由から、部分的にロードされた型のみを要求することも可能です。その場合、型の使用者は自分のコードが完全にロードされた状態に依存していないことを確認する必要があります。

## 2.2 ジェネリクス

ジェネリクスのない世界では、すべてがシンプルで問題はありません。なぜなら、すべての通常の（`TypeDesc` で表されない）型は1つの `MethodTable` を持ち、それが関連する `EEClass` を指し、`EEClass` は `MethodTable` を指し返すからです。型のすべてのインスタンスは、最初のフィールドとしてオフセット0に（すなわち参照値として見えるアドレスに）`MethodTable` へのポインタを含みます。領域を節約するため、型が宣言したメソッドを表す `MethodDesc` は、`EEClass` が指すチャンクのリンクリストに組織化されます<sup>4</sup>。

![図3](./images/typeloader-fig3.png)

図3 非ジェネリック型と非ジェネリックメソッド

<sup>4</sup> もちろん、マネージドコードが実行される際、チャンク内のメソッドを検索して呼び出すわけではありません。メソッドの呼び出しは非常に「ホット」な操作であり、通常は `MethodTable` 内の情報にのみアクセスする必要があります。

### 2.2.1 用語

**ジェネリックパラメータ (Generic Parameter)**

他の型で置換されるプレースホルダー。`List<T>` の宣言における `T` です。仮型パラメータ (formal type parameter) とも呼ばれます。ジェネリックパラメータには名前とオプションのジェネリック制約 (generic constraints) があります。

**ジェネリック引数 (Generic Argument)**

ジェネリックパラメータに置換される型。`List<int>` の `int` です。ジェネリックパラメータは引数としても使用できることに注意してください。以下を考えてみましょう：

```csharp
List<T> GetList<T>()
{
    return new List<T>();
}
```

このメソッドには1つのジェネリックパラメータ `T` があり、これがジェネリックリストクラスのジェネリック引数として使用されています。

**ジェネリック制約 (Generic Constraint)**

ジェネリックパラメータがその潜在的なジェネリック引数に課すオプションの要件です。必要な特性を持たない型はジェネリックパラメータに置換できず、型ローダーによって強制されます。ジェネリック制約には3種類あります：

1. 特殊制約 (special constraints)
   - 参照型制約 (reference type constraint) — ジェネリック引数は参照型（値型ではない）でなければなりません。C# ではこの制約を表現するために `class` キーワードが使用されます。

     ```csharp
     public class A<T> where T : class
     ```

   - 値型制約 (value type constraint) — ジェネリック引数は `System.Nullable<T>` とは異なる値型でなければなりません。C# では `struct` キーワードが使用されます。

     ```csharp
     public class A<T> where T : struct
     ```

   - デフォルトコンストラクタ制約 (default constructor constraint) — ジェネリック引数はパブリックな引数なしコンストラクタを持たなければなりません。C# では `new()` で表現されます。

     ```csharp
     public class A<T> where T : new()
     ```

2. 基底型制約 (base type constraints) — ジェネリック引数は指定された非インターフェース型から派生している（または直接その型である）必要があります。基底型制約として使用する参照型は0個または1個のみが理にかなっています。

   ```csharp
   public class A<T> where T : EventArgs
   ```

3. 実装インターフェース制約 (implemented interface constraints) — ジェネリック引数は指定されたインターフェース型を実装している（または直接その型である）必要があります。0個以上のインターフェースを指定できます。

   ```csharp
   public class A<T> where T : ICloneable, IComparable<T>
   ```

上記の制約は暗黙的な AND で結合されます。つまり、ジェネリックパラメータは指定された型から派生し、複数のインターフェースを実装し、デフォルトコンストラクタを持つように制約できます。宣言する型のすべてのジェネリックパラメータを制約の表現に使用でき、パラメータ間の相互依存関係を導入します。例えば：

```csharp
public class A<S, T, U>
	where S : T
	where T : IList<U> {
    void f<V>(V v) where V : S {}
}
```

**インスタンス化 (Instantiation)**

ジェネリック型またはメソッドのジェネリックパラメータに置換されたジェネリック引数のリストです。ロードされた各ジェネリック型およびメソッドにはそのインスタンス化があります。

**典型的インスタンス化 (Typical Instantiation)**

型またはメソッド自身の型パラメータのみで構成され、パラメータが宣言された順序と同じ順序のインスタンス化です。各ジェネリック型およびメソッドには正確に1つの典型的インスタンス化が存在します。通常、オープンジェネリック型について話すとき、典型的インスタンス化を念頭に置いています。例：

```csharp
public class A<S, T, U> {}
```

C# の `typeof(A<,,>)` は ``ldtoken A`3`` にコンパイルされ、ランタイムに ``A`3`` を `S`、`T`、`U` でインスタンス化してロードさせます。

**正規インスタンス化 (Canonical Instantiation)**

すべてのジェネリック引数が `System.__Canon` であるインスタンス化です。`System.__Canon` は **corlib** で定義された内部型であり、その役割はジェネリック引数として使用される可能性のある他のどの型とも異なる、よく知られた型であることです。正規インスタンス化を持つ型/メソッドは、すべてのインスタンス化の代表として使用され、すべてのインスタンス化で共有される情報を保持します。`System.__Canon` はそれぞれのジェネリックパラメータが持つ制約を明らかに満たせないため、制約チェックは `System.__Canon` に関して特別扱いされ、これらの違反を無視します。

::: tip 💡 初心者向け補足
`System.__Canon` は CLR 内部で使われる特殊な型で、「すべての参照型の代表」として機能します。例えば `List<string>` と `List<object>` は異なる型ですが、内部的には `List<System.__Canon>` という共通のテンプレートを共有しています。これにより、参照型引数を使うジェネリック型ごとにメソッドコードを再生成する必要がなくなり、メモリ使用量が削減されます。Java のジェネリクスが型消去 (type erasure) で実装されているのに対し、.NET は具象化 (reification) されたジェネリクスをこのような共有の仕組みで効率的に実現しています。
:::

### 2.2.2 共有

ジェネリクスの登場により、ランタイムがロードする型の数は多くなる傾向があります。異なるインスタンス化を持つジェネリック型（例：`List<string>` と `List<object>`）はそれぞれ固有の `MethodTable` を持つ異なる型ですが、共有できる情報がかなりの量あることが判明しています。この共有はメモリフットプリントにプラスの影響を与え、結果としてパフォーマンスも向上します。

![図4](./images/typeloader-fig4.png)

図4 非ジェネリックメソッドを持つジェネリック型 — 共有された EEClass

現在、参照型を含むすべてのインスタンス化は同じ `EEClass` とその `MethodDesc` を共有しています。すべての参照は同じサイズ（4バイトまたは8バイト）であるため、これらすべての型のレイアウトは同じになり、これが共有を実現可能にしています。上の図は `List<object>` と `List<string>` についてこれを示しています。正規の `MethodTable` は最初の参照型インスタンス化がロードされる前に自動的に作成され、ホットだがインスタンス化固有ではないデータ（非仮想スロットなど）を含みます。値型のみを含むインスタンス化は共有されず、そのようなインスタンス化された型はそれぞれ独自の非共有 `EEClass` を持ちます。

::: tip 💡 初心者向け補足
`List<string>` と `List<object>` は異なる型ですが、内部的には多くの情報を共有しています。これは、参照型（クラス）のポインタサイズがすべて同じ（32ビット環境で4バイト、64ビット環境で8バイト）であるためです。一方、`List<int>` と `List<double>` は値型のサイズが異なるため共有できず、それぞれ独自のデータ構造を持ちます。この「共有」の仕組みにより、ジェネリクスを多用してもメモリの消費を抑えることができます。
:::

これまでにロードされたジェネリック型を表す `MethodTable` は、そのローダーモジュールが所有するハッシュテーブルにキャッシュされます<sup>5</sup>。このハッシュテーブルは新しいインスタンス化が構築される前に参照され、同じ型を表す2つ以上の `MethodTable` インスタンスが存在しないことを保証します。

ジェネリック共有の詳細については、[Design and Implementation of Generics for the .NET Common Language Runtime][generics-design] を参照してください。

<sup>5</sup> NGEN イメージからロードされた型については、状況はもう少し複雑になります。
