# CLR ABI

::: info 原文
この章の原文は [CLR ABI](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/clr-abi.md) です。
:::

本ドキュメントでは、.NET 共通言語ランタイム (Common Language Runtime, CLR) のソフトウェア規約 (ABI、「Application Binary Interface」) について説明します。x64 (AMD64)、ARM (ARM32 または Thumb-2)、および ARM64 プロセッサアーキテクチャの ABI に焦点を当てています。x86 の ABI に関するドキュメントはやや少ないですが、呼び出し規約 (calling convention) の基本に関する情報は本ドキュメントの末尾に含まれています。

::: tip 💡 初心者向け補足
ABI (Application Binary Interface) とは、コンパイルされたプログラム同士が連携するための「契約」のようなものです。関数の呼び出し方、引数の渡し方、戻り値の受け取り方、レジスタの使い方、スタックメモリの管理方法などを定めたルールです。たとえば Java では JVM がこうした詳細を隠蔽しますが、CLR のような低レベルのランタイムでは、JIT コンパイラが生成するネイティブコードとランタイム (VM) の間でこれらの約束事を正確に守る必要があります。ABI が異なると、同じ CPU 上であっても関数を正しく呼び出すことができません。
:::

本ドキュメントでは、JIT (Just-In-Time) コンパイラが VM に課す要件、およびその逆について説明します。

JIT コードベースに関する補足: JIT32 は、もともと x86 コードを生成し、その後 ARM コード生成に移植されたオリジナルの JIT コードベースを指します。JIT64 は、AMD64 をサポートするレガシーな .NET Framework のコードベースを指します。RyuJIT コンパイラは JIT32 から発展し、現在はすべてのプラットフォームとアーキテクチャをサポートしています。RyuJIT の歴史の詳細については[こちらの記事](https://devblogs.microsoft.com/dotnet/the-ryujit-transition-is-complete)を参照してください。

NativeAOT は、事前コンパイル (AOT: Ahead-Of-Time compilation) に最適化されたランタイムを指します。NativeAOT の ABI は、プラットフォーム間での簡潔性と一貫性のために、いくつかの詳細が異なります。

# はじめに

Windows および非 Windows の ABI ドキュメントに記載されている内容をすべて読んでください。CLR はそれらの基本規約に従います。本ドキュメントでは、CLR 固有の事項、またはそれらのドキュメントからの例外のみを説明します。

## Windows の ABI ドキュメント

AMD64: [x64 Software Conventions](https://learn.microsoft.com/cpp/build/x64-software-conventions) を参照してください。

ARM: [Overview of ARM32 ABI Conventions](https://learn.microsoft.com/cpp/build/overview-of-arm-abi-conventions) を参照してください。

ARM64: [Overview of ARM64 ABI conventions](https://learn.microsoft.com/cpp/build/arm64-windows-abi-conventions) を参照してください。

## 非 Windows の ABI ドキュメント

Arm 社の ABI ドキュメント (ARM32 および ARM64 向け) は[こちら](https://developer.arm.com/architectures/system-architectures/software-standards/abi)と[こちら](https://github.com/ARM-software/abi-aa)にあります。
Apple の ARM64 呼び出し規約の差異については[こちら](https://developer.apple.com/documentation/xcode/writing-arm64-code-for-apple-platforms)を参照してください。

Linux System V x86_64 ABI は [System V Application Binary Interface / AMD64 Architecture Processor Supplement](https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-1.0.pdf) に文書化されており、ドキュメントのソース資料は[こちら](https://gitlab.com/x86-psABIs/x86-64-ABI)にあります。

LoongArch64 の ABI ドキュメントは[こちら](https://github.com/loongson/LoongArch-Documentation/blob/main/docs/LoongArch-ELF-ABI-EN.adoc)にあります。

RISC-V ABI 仕様: [最新リリース](https://github.com/riscv-non-isa/riscv-elf-psabi-doc/releases/latest)、[最新ドラフト](https://github.com/riscv-non-isa/riscv-elf-psabi-doc/releases)、[ドキュメントソースリポジトリ](https://github.com/riscv-non-isa/riscv-elf-psabi-doc)。

Web Assembly Basic C ABI: [Basic C ABI](https://github.com/WebAssembly/tool-conventions/blob/main/BasicCABI.md)

# 一般的なアンワインド/フレームレイアウト

::: tip 💡 初心者向け補足
「アンワインド (unwind)」とは、スタックフレーム (stack frame) を巻き戻す操作のことです。関数を呼び出すたびにスタック上に「フレーム」と呼ばれる領域が積み重なります。例外が発生したり、ガベージコレクション (GC) が実行されたりする際、ランタイムは現在のスタック状態を理解するためにフレームを一つずつ辿って戻る必要があります。この巻き戻し操作をアンワインドと呼びます。Java での例外発生時にスタックトレースが表示されるのと同様に、.NET ランタイムもスタックを正確にたどれる必要があります。
:::

x86 以外のすべてのプラットフォームでは、ガベージコレクタ (GC) がアンワインドできるように、すべてのメソッドがアンワインド情報を持つ必要があります (ネイティブコードでは、リーフメソッドのアンワインド情報は省略可能です)。

ARM および ARM64: マネージドメソッドは、リターンアドレスハイジャック (return address hijacking) によってメソッドを適切にハイジャックできるように、常に LR をスタックにプッシュし、最小限のフレームを作成する必要があります。

## フレームポインタチェーン (Frame pointer chains)

フレームポインタチェーン (frame pointer chain) とは、フレームポインタレジスタ (frame pointer register) がスタック上の位置を指し、その位置に保存された前のフレームポインタ値 (現在の関数の呼び出し元のもの) のアドレスが格納されている状態を指します。このチェーンは、以下のような特定のシナリオで必要です：

1. Linux 上の gdb デバッガによるスタックウォーキング。
2. ETW イベントトレースによるスタックウォーキング。

考慮すべき点が 2 つあります：

1. フレームポインタレジスタをスタックウォーキング用に予約し、汎用的なコード生成など他の目的に使用しないこと。
2. フレームチェーンを作成すること。

関数がフレームチェーンに追加されていなくても、その関数がフレームポインタを変更しない限り、既存のフレームチェーンは引き続き有効です。ただし、チェーンをたどる際にその関数は表示されません。JIT は、フレームチェーンが作成されていなくても、例外処理ファンクレット (funclet) 内からメインの関数ローカル変数にアクセスするためなどの理由で、フレームポインタレジスタを作成・使用する場合があります。

フレームポインタレジスタは、各アーキテクチャで以下のとおりです: ARM: r11、ARM64: x29、x86: EBP、x64: RBP。

JIT は、Windows x64 _以外_ のすべてのプラットフォームでほとんどの場合フレームチェーンを作成します。非常に単純な関数は、フレームセットアップコストを削減してパフォーマンスを向上させる目的で、フレームチェーンに追加されない場合があります (この選択のヒューリスティクスは `Compiler::rpMustCreateEBPFrame()` にあります)。Windows x64 では、アンワインドは常に生成されたアンワインドコードを使用して行われ、単純なフレームチェーンのトラバーサルは使用されません。

追加リンク:

- ARM64 のフレーム設計に関するドキュメントは [ARM64 JIT frame layout](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/jit/arm64-jit-frame-layout.md) を参照してください。
- Unix x64 で常に RBP チェーンを作成するようにした CoreCLR の変更は[こちら](https://github.com/dotnet/coreclr/pull/4019)です (議論を含む Issue は[こちら](https://github.com/dotnet/runtime/issues/4651))。

# 特殊パラメータ/追加パラメータ

::: tip 💡 初心者向け補足
呼び出し規約 (calling convention) とは、関数がどのように引数を受け取り、戻り値を返すかを定義するルールのことです。たとえば、「最初の引数はレジスタ RCX に入れる」「戻り値は RAX に入れる」といったルールです。CLR はネイティブ（OS やハードウェアが定める）ABI の規約に加えて、ガベージコレクション (GC) やジェネリクスなどをサポートするために、いくつかの **特殊なパラメータ** を追加しています。この章では、そうした CLR 独自の追加パラメータについて説明します。
:::

## `this` ポインタ

マネージド `this` ポインタは、ネイティブ ABI ではカバーされない新しい種類の引数として扱われます。そのため、常に最初の引数として (AMD64) `RCX` または (ARM, ARM64) `R0` で渡すことにしています。

AMD64 のみ：.NET Framework 4.5 までは、マネージド `this` ポインタはネイティブの `this` ポインタと同じように扱われていました（つまり、呼び出しがリターンバッファ (return buffer) を使用する場合は第 2 引数となり、RCX ではなく RDX で渡されていました）。.NET Framework 4.5 以降は、常に最初の引数として渡されます。

## 可変長引数 (Varargs)

可変長引数 (Varargs) とは、関数呼び出しにおいて可変個の引数を渡したり受け取ったりすることを指します。

::: tip 💡 初心者向け補足
可変長引数 (varargs) とは、関数に渡す引数の数が固定されていない仕組みのことです。C 言語の `printf` 関数のように、呼び出すたびに異なる数の引数を渡せます。C# では `params` キーワードを使った可変長引数がよく使われますが、これは内部的には固定長の引数と同じ扱いです。一方、ここで説明するマネージド可変長引数 (`__arglist` など) は、よりローレベルな仕組みで、C++ の可変長引数に近い動作をします。
:::

C# の可変長引数は `params` キーワードを使用しますが、IL レベルでは固定数のパラメータを持つ通常の呼び出しにすぎません。

マネージド可変長引数（C# の疑似ドキュメント化された `...`、`__arglist` などを使用）は、C++ の可変長引数とほぼ同じように実装されています。最大の違いは、JIT がオプションのリターンバッファとオプションの `this` ポインタの後、かつ他のユーザー引数の前に「vararg クッキー (vararg cookie)」を追加することです。呼び出し先 (callee) は、このクッキーとそれ以降のすべての引数をホームロケーション (home location) にスピル (spill) しなければなりません。これらはクッキーをベースとしたポインタ演算でアドレスされる可能性があるためです。このクッキーは、ランタイムがパースできるシグネチャへのポインタであり、(1) 引数の可変部分に含まれる GC ポインタを報告する、または (2) ArgIterator を通じて取り出された引数の型チェック（および適切なウォークオーバー）を行うために使用されます。これは `IMAGE_CEE_CS_CALLCONV_VARARG` で示されますが、`IMAGE_CEE_CS_CALLCONV_NATIVEVARARG` と混同しないでください。後者はまさにネイティブの可変長引数そのもの（クッキーなし）であり、PInvoke IL スタブでのみ使用されるべきもので、ピン留め (pinning) やその他の GC マジック (GC magic) を適切に処理します。

AMD64 では、ネイティブと同様に、浮動小数点レジスタで渡される浮動小数点引数（固定引数を含む）は、整数レジスタにシャドウ（つまり複製）されます。

ARM および ARM64 では、ネイティブと同様に、浮動小数点レジスタには何も配置されません。

ただし、ネイティブの可変長引数とは異なり、すべての浮動小数点引数が double (`R8`) に昇格されるわけではなく、元の型 (`R4` または `R8`) が維持されます（ただし、managed C++ のような IL ジェネレータが呼び出し元でアップキャストを明示的に挿入し、呼び出し元のシグネチャを適切に調整することを妨げるものではありません）。これにより、ネイティブ C++ を C# に移植したり、managed C++ のさまざまなバリアントで管理したりする場合に、予期しない動作が生じることがあります。

マネージド可変長引数は Windows でのみサポートされています。

マネージド/ネイティブ可変長引数は Windows でのみサポートされています。非 Windows プラットフォームでのマネージド/ネイティブ可変長引数のサポートは [この Issue](https://github.com/dotnet/runtime/issues/82081) で追跡されています。

## ジェネリクス (Generics)

_共有ジェネリクス (Shared generics)_。コードアドレスがメソッドのジェネリックインスタンス化 (generic instantiation) を一意に識別できない場合、「ジェネリックインスタンス化パラメータ (generic instantiation parameter)」が必要になります。多くの場合、`this` ポインタがインスタンス化パラメータとしても兼用できます。`this` ポインタがジェネリックパラメータでない場合、ジェネリックパラメータは追加の引数として渡されます。ARM と AMD64 では、オプションのリターンバッファとオプションの `this` ポインタの後、かつユーザー引数の前に渡されます。ARM64 と RISC-V では、ジェネリックパラメータはオプションの `this` ポインタの後、かつユーザー引数の前に渡されます。x86 では、`this` ポインタを含むすべての関数の引数が引数レジスタ (ECX と EDX) に収まり、かつまだ使用可能な引数レジスタがある場合、隠し引数は次に使用可能な引数レジスタに格納されます。それ以外の場合は、最後のスタック引数として渡されます。ジェネリックメソッド（型ではなくメソッド自体に型パラメータがある場合）では、ジェネリックパラメータは現在 MethodDesc ポインタ（おそらく InstantiatedMethodDesc）です。静的メソッド（`this` ポインタがない場合）では、ジェネリックパラメータは MethodTable ポインタ/TypeHandle です。

::: tip 💡 初心者向け補足
共有ジェネリクスとは、`List<int>` と `List<string>` のように異なる型引数で使われるジェネリック型やメソッドが、可能な場合には同じコンパイル済みコードを共有する最適化のことです。しかし、共有コードは実行時にどの型引数で呼ばれているかを知る必要があるため、「ジェネリックインスタンス化パラメータ」という隠しパラメータを追加で渡します。たとえば、インスタンスメソッドの場合は `this` ポインタから型情報を取得できますが、静的メソッドでは `this` がないため、MethodTable へのポインタを別途渡す必要があります。
:::

VM が JIT にジェネリクスパラメータの報告と存続を要求する場合があります。この場合、パラメータはスタック上のどこかに保存し、プロローグ (prolog) とエピローグ (epilog) を除くメソッド全体にわたって通常の GC 報告で存続させなければなりません（MethodDesc や MethodTable ではなく `this` ポインタだった場合）。また、パラメータをホームに配置するコードは、GC 情報でプロローグとして報告されるコード範囲内になければなりません（これはアンワインド情報 (unwind info) でプロローグとして報告される範囲とは異なる可能性があります）。

ジェネリックパラメータと可変長引数クッキーの間に定義された/強制された/宣言された順序はありません。ランタイムがその組み合わせをサポートしていないためです。VM と JIT の中にはその組み合わせをサポートしているように見えるコードがいくつかありますが、別の場所ではアサートして禁止しているため、何もテストされておらず、バグや相違（たとえば、ある JIT が別の JIT や VM とは異なる順序を使用している、など）があるものと推測されます。

### 例

```
call(["this" pointer] [return buffer pointer] [generics context|varargs cookie] [userargs]*)
```

## 非同期 (Async)

非同期呼び出し規約 (Async calling convention) は、サポートされている場合に他の呼び出し規約に対して追加的に適用されます。対象となるシナリオは通常の静的/仮想呼び出しに限定されており、たとえば PInvoke や可変長引数はサポートしません。最低限、通常の静的呼び出し、`this` パラメータ付きの呼び出し、ジェネリック隠しパラメータ付きの呼び出しがサポートされます。

非同期呼び出し規約は、追加の `Continuation` パラメータと追加の戻り値を加えます。この戻り値は `null` でない場合に意味的に優先されます。戻り時に `Continuation` が非 `null` であることは、計算がまだ完了しておらず正式な結果が準備できていないことを示します。引数として非 `null` が渡されることは、関数が再開中であり、`Continuation` から状態を復元して（他のすべての引数を無視して）実行を継続すべきであることを意味します。

`Continuation` はマネージドオブジェクトであり、それに応じて追跡する必要があります。GC 情報には、非同期呼び出しサイトにおいて継続結果がライブとして含まれます。

### `Continuation` の返却

`Continuation` を返すには、実際の結果を返すために使用できない volatile/callee-trash レジスタを使用します。

| アーキテクチャ | `REG_ASYNC_CONTINUATION_RET` |
| -------------- | ---------------------------- |
| x86            | ecx                          |
| x64            | rcx                          |
| arm            | r2                           |
| arm64          | x2                           |
| risc-v         | a2                           |

### `Continuation` 引数の受け渡し

`Continuation` パラメータは、ジェネリックインスタンス化パラメータと同じ位置、または両方が存在する場合はその直後に渡されます。x86 では引数の順序が逆になります。

```
call(["this" pointer] [return buffer pointer] [generics context] [continuation] [userargs])   // x86 以外

call(["this" pointer] [return buffer pointer] [userargs] [continuation] [generics context])   // x86
```

## AMD64 のみ：値渡しの値型

ネイティブと同様に、AMD64 には暗黙的な参照渡し (implicit-byrefs) があります。サイズが 1、2、4、8 バイトでない（つまり 3、5、6、7、または 9 バイト以上の）構造体（IL 用語では値型 (value type)）が値渡しで宣言されている場合、代わりに参照渡しされます。JIT が生成するコードの場合は、ネイティブ ABI に従い、渡される参照はスタック上のコンパイラが生成した一時ローカルへのポインタです。ただし、リモーティングやリフレクション内で stackalloc が困難すぎるケースがあり、GC ヒープ内のポインタを渡す場合があります。そのため、JIT されたコードは、呼び出し先がこれらのリフレクションパスのいずれかである場合に備えて、暗黙的な byref パラメータをインテリアポインタ (interior pointer)（JIT 用語では BYREF）として報告しなければなりません。同様に、すべての書き込みにはチェック付きライトバリア (checked write barrier) を使用する必要があります。

AMD64 のネイティブ呼び出し規約（Windows 64 および System V）では、リターンバッファのアドレスを呼び出し先 (callee) が RAX で返すことを要求しています。JIT もこのルールに従います。

## RISC-V のみ：ハードウェア浮動小数点呼び出し規約に従った構造体の受け渡し/返却

ネイティブと同様のハードウェア浮動小数点呼び出し規約に従った構造体の受け渡し/返却は、現在 [16 バイトまでのみサポート](https://github.com/dotnet/runtime/issues/107386)されています。それより大きい構造体は標準 ABI と異なり、整数呼び出し規約（暗黙的な参照渡し）に従って受け渡し/返却されます。

## リターンバッファ (Return buffers)

.NET 10 以降、リターンバッファは常に呼び出し元 (caller) がスタック上に確保する必要があります。呼び出しの後、呼び出し元は必要に応じてライトバリア (write barrier) を使用してリターンバッファを最終的な送り先にコピーする責任があります。JIT はリターンバッファが常にスタック上にあると想定でき、GC ポインタをリターンバッファに書き込む際のライトバリアの省略など、それに応じた最適化を行えます。さらに、バッファの内容はエイリアスされたりクロススレッドから可視であったりしてはならないため、メソッド内での一時ストレージとしての使用が許可されています。

ARM64 のみ：メソッドが 16 バイトより大きい構造体を返す場合、呼び出し元は結果を保持するのに十分なサイズとアラインメントを持つリターンバッファを確保します。バッファのアドレスは `R8`（JIT では `REG_ARG_RET_BUFF` として定義）でメソッドの引数として渡されます。呼び出し先は `R8` に格納された値を保持する必要はありません。

## 隠しパラメータ (Hidden parameters)

_スタブディスパッチ (Stub dispatch)_ - 仮想呼び出しが VSD スタブを使用する場合、呼び出しコードをバックパッチ（または逆アセンブル）する代わりに、JIT は呼び出しターゲットをロードするために使用されるスタブのアドレス、すなわち「スタブ間接セル (stub indirection cell)」を (x86) `EAX` / (AMD64) `R11` / (ARM) `R4` / (ARM NativeAOT ABI) `R12` / (ARM64) `R11` に配置しなければなりません。JIT では、これは `VirtualStubParamInfo` クラスにカプセル化されています。

_Calli PInvoke_ - VM は PInvoke のアドレスを (AMD64) `R10` / (ARM) `R12` / (ARM64) `R14`（JIT では `REG_PINVOKE_TARGET_PARAM`）に、シグネチャ（PInvoke クッキー）を (AMD64) `R11` / (ARM) `R4` / (ARM64) `R15`（JIT では `REG_PINVOKE_COOKIE_PARAM`）に必要とします。

_通常の PInvoke_ - VM はシグネチャに基づいて IL スタブを共有しますが、コールスタックと例外に正しいメソッドを表示させたいため、正確な PInvoke の MethodDesc が (x86) `EAX` / (AMD64) `R10` / (ARM, ARM64) `R12`（JIT では `REG_SECRET_STUB_PARAM`）で渡されます。その後、IL スタブ内で JIT が `CORJIT_FLG_PUBLISH_SECRET_PARAM` を受け取ると、レジスタをコンパイラの一時変数に移動しなければなりません。この値はイントリンシック (intrinsic) `NI_System_StubHelpers_GetStubContext` で返されます。

## 小さなプリミティブ型の戻り値

32 ビット未満のプリミティブ値型は 32 ビットに拡張されます。符号付き小型は符号拡張 (sign extend) され、符号なし小型はゼロ拡張 (zero extend) されます。これは、リターンレジスタの未使用ビットの状態を未定義のままにする標準呼び出し規約とは異なる場合があります。

## 小さなプリミティブ型の引数

小さなプリミティブ型の引数は、上位ビットが未定義です。これは、正規化 (normalization) を要求する標準呼び出し規約（例：ARM32 や Apple ARM64）とは異なる場合があります。

RISC-V では、小さなプリミティブ型の引数は標準呼び出し規約に従って拡張されます。

# PInvoke

::: tip 💡 初心者向け補足
PInvoke (Platform Invoke) とは、マネージド .NET コードからネイティブ（アンマネージド）コード（C/C++ の DLL など）を呼び出すための仕組みです。Java における JNI (Java Native Interface) に相当するものです。PInvoke を使うと、OS の API やサードパーティのネイティブライブラリをマネージドコードから直接呼び出すことができます。
:::

規約として、InlinedCallFrame を持つメソッド（IL スタブまたはインライン PInvoke を含む通常のメソッド）は、プロローグ/エピローグでそれぞれすべての不揮発性 (non-volatile) 整数レジスタの保存/復元を行います。これにより、InlinedCallFrame にはリターンアドレス、スタックポインタ、フレームポインタだけを格納すればよくなります。そしてこれら3つの値だけを使って、通常の RtlVirtualUnwind によるフルスタックウォークを開始できます。

JIT は PInvoke に遭遇すると、GC 遷移 (GC transition) を抑制すべきかどうかを VM に問い合わせます。GC 遷移の抑制は、PInvoke 定義に属性を追加することで示されます。VM が GC 遷移を抑制すべきと指示した場合、IL スタブまたはインラインのどちらのシナリオでも PInvoke フレームは省略され、アンマネージド呼び出しサイトの近くに GC ポール (GC Poll) が挿入されます。囲んでいる関数に複数のインライン PInvoke が含まれていても、すべてが GC 遷移の抑制を要求しているわけではない場合、他のインライン PInvoke に対しては引き続き PInvoke フレームが構築されます。

AMD64 では、InlinedCallFrame を持つメソッドはフレームレジスタとして RBP を使用しなければなりません。

ARM および ARM64 では、常にフレームポインタ (R11) を使用します。これは部分的にはフレームチェーンの要件によるものですが、VM も InlinedCallFrame を持つ PInvoke に対してこれを要求しています。

ARM では、VM は `REG_SAVED_LOCALLOC_SP` にも依存しています。

これらの依存関係はすべて `InlinedCallFrame::UpdateRegDisplay` の実装に現れています。

JIT32 は、現在のメソッドに PInvoke/InlinedCallFrame がある場合、エピローグを1つだけ生成し（すべての return をそこへ分岐させ）ます。

## フレームごとの PInvoke 初期化

InlinedCallFrame は、IL スタブの先頭で1回、およびインライン PInvoke を行う各パスで1回初期化されます。

JIT64 では、実際に呼び出しを含むブロックで初期化が行われますが、ランディングパッドを持つループの外に押し出し、その後ドミネーターブロックを探します。IL スタブおよび EH を持つメソッドの場合は、諦めて最初のブロックに初期化を配置します。

RyuJIT/JIT32 (ARM) では、すべてのメソッドが JIT64 の IL スタブと同様に扱われます（つまり、フレームごとの初期化はプロローグの直後に1回だけ行われます）。

JIT は、InlinedCallFrame のアドレスと、NULL または IL スタブ用のシークレットパラメータを渡して `CORINFO_HELP_INIT_PINVOKE_FRAME` を呼び出すコードを生成します。`JIT_InitPInvokeFrame` は InlinedCallFrame を初期化し、現在の Frame チェーンの先頭を指すように設定します。そして、現在のスレッドのネイティブ Thread オブジェクトを返します。

AMD64 では、JIT は RSP と RBP を InlinedCallFrame に保存するコードを生成します。

IL スタブの場合のみ、フレームごとの初期化には `Thread->m_pFrame` を InlinedCallFrame に設定すること（事実上 Frame を「プッシュ」すること）が含まれます。

## 呼び出しサイトごとの PInvoke 作業

以下は、GC 遷移が抑制されていない場合に実行されます。

1. 直接呼び出しの場合、JIT 生成コードは `InlinedCallFrame->m_pDatum` を呼び出し先の MethodDesc に設定します。
   - JIT64 では、IL スタブ内の間接呼び出しはシークレットパラメータに設定します（これは冗長に見えますが、フレームごとの初期化以降に変更された可能性があります）。
   - JIT32 (ARM) の間接呼び出しでは、コメントによるとプッシュされた引数のサイズをこのメンバーに設定します。ただし、実装では常に 0 が渡されていました。
2. JIT64/AMD64 のみ: 次に非 IL スタブの場合、`Thread->m_pFrame` を InlinedCallFrame を指すように設定することで InlinedCallFrame を「プッシュ」します（フレームごとの初期化で既に `InlinedCallFrame->m_pNext` が前の先頭を指すように設定されていることを思い出してください）。IL スタブの場合、この手順はフレームごとの初期化で完了しています。
3. `InlinedCallFrame->m_pCallerReturnAddress` を設定することで Frame をアクティブにします。
4. 次に、`Thread->m_fPreemptiveGCDisabled = 0` を設定することで GC モードを切り替えます。
5. ここから先、GC ポインタがレジスタ内で生存していてはなりません。RyuJIT の LSRA は、アンマネージド呼び出しおよび特殊ヘルパーの前に特殊な refPosition `RefTypeKillGCRefs` を追加することでこの要件を満たします。
6. ここで実際の呼び出し/PInvoke が行われます。
7. `Thread->m_fPreemptiveGCDisabled = 1` を設定することで GC モードを元に戻します。
8. 次に、`g_TrapReturningThreads` が設定されている（非ゼロ）かどうかを確認します。設定されている場合、`CORINFO_HELP_STOP_FOR_GC` を呼び出します。
   - ARM では、このヘルパー呼び出しはリターンレジスタ `R0`、`R1`、`S0`、`D0` を保持します。
   - AMD64 では、生成されたコードは PInvoke の戻り値を不揮発性レジスタまたはスタック上の場所に移動して手動で保持する必要があります。
9. ここから先、GC ポインタは再びレジスタ内で生存することが許されます。
10. `InlinedCallFrame->m_pCallerReturnAddress` を 0 にクリアします。
11. JIT64/AMD64 のみ: 非 IL スタブの場合、`Thread->m_pFrame` を `InlinedCallFrame.m_pNext` に戻すことで Frame チェーンを「ポップ」します。

すべての不揮発性レジスタの保存/復元は、現在のフレームで未使用のレジスタが親フレームからの生存中の GC ポインタ値を誤って保持してしまうことを防ぐのに役立ちます。引数レジスタとリターンレジスタは「安全」です。なぜなら、それらは GC 参照にはなり得ないからです。参照は他の場所でピン留めされ、代わりにネイティブポインタとして渡されるべきです。

IL スタブの場合、Frame チェーンは呼び出しサイトでポップされないため、代わりにエピローグの直前および jmp 呼び出しの直前にポップする必要があります。PInvoke IL スタブからのテールコールはサポートされていないようです。

# 例外処理

このセクションでは、マネージド例外処理 (EH) を実装するコードを生成する際に JIT が従うべき規約について説明します。正しい実装のために、JIT と VM はこれらの規約について合意していなければなりません。

## ファンクレット (funclet)

::: tip 💡 初心者向け補足
ファンクレット (funclet) とは、例外ハンドラ（catch、finally、fault、filter など）から抽出された独立したコード片です。OS からは独立した関数として扱われますが、CLR 上では親関数の一部として管理されます。たとえば、`try { ... } catch { ... } finally { ... }` のような構文がある場合、catch ブロックと finally ブロックの中身がそれぞれ別のファンクレットとして抽出されます。
:::

すべてのプラットフォームにおいて、マネージド EH ハンドラ (finally、fault、filter、filter-handler、catch) は独自の「ファンクレット」に抽出されます。OS にとっては、これらは第一級の関数として扱われます（個別の PDATA と XDATA (`RUNTIME_FUNCTION` エントリ) など）。CLR は現在、多くの点でこれらを親関数の一部として扱っています。メイン関数とすべてのファンクレットは、単一のコード割り当て内に配置されなければなりません（ホット/コールド分割を参照）。これらは GC 情報を「共有」します。ホットパッチできるのはメイン関数のプロローグのみです。

ハンドラのファンクレットに入る唯一の方法は呼び出しを通じてです。例外の場合、呼び出しは例外ディスパッチ/アンワインドの一環として VM の EH サブシステムから行われます。例外でない場合、これはローカルアンワインド (local unwind) または非ローカル終了 (non-local exit) と呼ばれます。C# では、try 本体からフォールスルーする/出る、または明示的な goto によって実現されます。IL では、try 本体内の LEAVE オペコードで、try 本体外の IL オフセットをターゲットにすることで常に実現されます。このような場合、呼び出しは親関数の JIT 生成コードから行われます。

## クローン化された finally

RyuJIT は、「通常の」制御フロー（C# のフォールスルーで非例外的に try 本体を離れる場合）に沿って呼び出される finally を「インライン化」することで、通常の制御フローを高速化しようとします。この最適化はすべてのアーキテクチャでサポートされています。

## finally の呼び出し / 非ローカル終了

適切な前進保証 (forward progress) と `Thread.Abort` のセマンティクスのために、call-to-finally を配置できる場所と、呼び出しサイトの見た目に制約があります。リターンアドレスは、対応する try 本体内にあっては**なりません**（さもないと VM は finally が自身を保護していると考えてしまいます）。リターンアドレスは、外側の保護領域内になければ**なりません**（finally 本体からの例外が正しく処理されるように）。

RyuJIT はジャンプアイランドに似た仕組みを作成します。try 本体の外にあるコードブロックが finally を呼び出し、その後 leave/非ローカル終了の最終ターゲットに分岐します。このジャンプアイランドは、EH テーブルではクローン化された finally であるかのようにマークされます。クローン化された finally 句により、ハンドラに入る前に Thread.Abort が発火することを防ぎます。リターンアドレスを try 本体の外に配置することで、もう1つの制約も満たします。

## ThreadAbortException の考慮事項

::: tip 💡 初心者向け補足
ThreadAbortException は、あるスレッドから別のスレッドを中断 (abort) できるようにする .NET 固有のメカニズムです。デスクトップ .NET Framework では利用可能で、ASP.NET などで多用されていましたが、.NET Core / 現在の .NET ではサポートされていません。それにもかかわらず、JIT は互換性のためにすべてのプラットフォームで ThreadAbort 対応コードを生成します。
:::

スレッドアボートには3種類あります: (1) ルードスレッドアボート (rude thread abort) — 停止できず、（すべての？）ハンドラを実行しないもの、(2) `Thread.Abort()` API の呼び出し、(3) 別のスレッドから注入される非同期スレッドアボートです。

ThreadAbortException はデスクトップフレームワークでは完全に利用可能であり、たとえば ASP.NET で頻繁に使用されていました。しかし、.NET Core、CoreCLR、Windows 8 の「モダンアプリプロファイル」ではサポートされていません。それにもかかわらず、JIT はすべてのプラットフォームで ThreadAbort 互換のコードを生成します。

非ルードスレッドアボートの場合、VM はスタックをウォークし、ThreadAbortException をキャッチする catch ハンドラ（または System.Exception や System.Object などの親クラス）を実行し、finally を実行します。ThreadAbortException には非常に特殊な特性が1つあります。catch ハンドラが ThreadAbortException をキャッチし、Thread.ResetAbort() を呼び出さずに例外処理から戻った場合、VM は _ThreadAbortException を自動的に再発生させます_。そのために、catch ハンドラが返したレジュームアドレスを、再発生が発生したと見なされる実効アドレスとして使用します。これは catch ハンドラ内の LEAVE オペコードで指定されたラベルのアドレスです。JIT は合成的な「ステップブロック」を挿入して、このラベルが適切な外側の "try" リージョン内に収まるようにし、再発生が外側の catch ハンドラによってキャッチされるようにしなければならない場合があります。

例:

```cs
try { // try 1
    try { // try 2
        System.Threading.Thread.CurrentThread.Abort();
    } catch (System.Threading.ThreadAbortException) { // catch 2
        ...
        LEAVE L;
    }
} catch (System.Exception) { // catch 1
     ...
}
L:
```

この場合、catch 2 で返されたラベル L に対応するアドレスが try 1 の外にあると、VM によって再発生された ThreadAbortException は catch 1 にキャッチされません（期待通り）。JIT は効果的に以下のようなコード生成になるようにブロックを挿入する必要があります:

```cs
try { // try 1
    try { // try 2
        System.Threading.Thread.CurrentThread.Abort();
    } catch (System.Threading.ThreadAbortException) { // catch 2
        ...
        LEAVE L';
    }
    L': LEAVE L;
} catch (System.Exception) { // catch 1
     ...
}
L:
```

同様に、ThreadAbortException の自動再発生アドレスは finally ハンドラ内にあってはなりません。さもないと VM は再発生を中止し、例外を飲み込んでしまいます。これは、上述のように「クローン化された finally」としてマークされた call-to-finally サンクにより発生する可能性があります。例（これは擬似アセンブリコードであり、C# ではありません）:

```cs
try { // try 1
    try { // try 2
        System.Threading.Thread.CurrentThread.Abort();
    } catch (System.Threading.ThreadAbortException) { // catch 2
        ...
        LEAVE L;
    }
} finally { // finally 1
     ...
}
L:
```

これは以下のようなコードを生成します:

```asm
	// beginning of 'try 1'
	// beginning of 'try 2'
	System.Threading.Thread.CurrentThread.Abort();
	// end of 'try 2'
	// beginning of call-to-finally 'cloned finally' region
L1:	call finally1
	nop
	// end of call-to-finally 'cloned finally' region
	// end of 'try 1'
	// function epilog
	ret

Catch2:
	// do something
	lea rax, &L1; // load up resume address
	ret

Finally1:
	// do something
	ret
```

JIT は finally が呼び出されるように「ステップ」ブロックを挿入する必要がありますが、これだけでは ThreadAbortException の処理をサポートするには不十分です。なぜなら "L1" が「クローン化された finally」としてマークされているからです。この場合、JIT は "try 1" 内かつクローン化された finally ブロックの外にある別のステップブロックを挿入して、正しい再発生セマンティクスを可能にする必要があります。例:

```asm
	// beginning of 'try 1'
	// beginning of 'try 2'
	System.Threading.Thread.CurrentThread.Abort();
	// end of 'try 2'
L1':	nop
	// beginning of call-to-finally 'cloned finally' region
L1:	call finally1
	nop
	// end of call-to-finally 'cloned finally' region
	// end of 'try 1'
	// function epilog
	ret

Catch2:
	// do something
	lea rax, &L1'; // load up resume address
	ret

Finally1:
	// do something
	ret
```

JIT64 はこれを正しく実装していないことに注意してください。C# コンパイラはかつて常に必要なすべての「ステップ」ブロックを挿入していました。Roslyn C# コンパイラは一時期これを行わなくなりましたが、その後再び挿入するように変更されました。

## ファンクレットのパラメータ

catch、filter、filter-handler は、引数として例外オブジェクト (GC 参照) を受け取ります (`REG_EXCEPTION_OBJECT`)。AMD64 では RCX (Windows ABI) または RSI (Unix ABI) で渡されます。ARM および ARM64 では、これは最初の引数であり R0 で渡されます。

## ファンクレットの戻り値

filter ファンクレットは、通常のリターンレジスタ (x86: `EAX`、AMD64: `RAX`、ARM/ARM64: `R0`) に単純なブール値を返します。非ゼロは、対応する filter-handler が例外を処理する（つまり第2パスを開始する）ことを VM/EH サブシステムに示します。ゼロは、例外が処理**されない**ことを VM/EH サブシステムに示し、別の filter または catch の検索を続行すべきことを意味します。

catch および filter-handler のファンクレットは、通常のリターンレジスタにコードアドレスを返します。これは、スタックのアンワインドと例外のクリーンアップ後に VM が実行を再開すべき場所を示します。このアドレスは、親ファンクレット内のどこか（catch や filter-handler が他のファンクレット内にネストされていない場合はメイン関数内）にあるべきです。IL の 'leave' オペコードは任意のネストのファンクレットと try 本体から抜け出すことができるため、JIT はしばしばステップブロックの挿入を求められます。これらは中間的な分岐ターゲットであり、ネイティブ ABI の制約により実際のターゲットに直接到達できるようになるまで、次の最も外側のターゲットに分岐します。これらのステップブロックは finally を呼び出すこともできます（*finally の呼び出し / 非ローカル終了*を参照）。

finally および fault のファンクレットには戻り値はありません。

## レジスタの値と例外処理

例外処理は、例外処理を含む関数におけるレジスタの使用に一定の制約を課します。

CoreCLR と「デスクトップ」CLR は同じ動作をします。Windows と非 Windows の CLR 実装は共にこれらの規則に従います。

いくつかの定義:

_不揮発性 (Non-volatile)_（別名 _callee-saved_ または _preserved_）レジスタとは、ABI により関数呼び出し後も保持されるレジスタです。不揮発性レジスタには、フレームポインタとスタックポインタなどが含まれます。

_揮発性 (Volatile)_（別名 _caller-saved_ または _trashed_）レジスタとは、ABI により関数呼び出し後に保持されないレジスタであり、関数が戻った時点で異なる値になっている可能性があります。

### ファンクレット入場時のレジスタ

例外が発生すると、VM が何らかの処理を行うために呼び出されます。例外が "try" リージョン内にある場合、最終的に対応するハンドラを呼び出します（filter の呼び出しも含まれます）。関数内の例外発生場所は、"throw" 命令が実行される場所、ヌルポインタ参照やゼロ除算などのプロセッサ例外の発生点、または呼び出し先が例外をスローしたがキャッチしなかった呼び出しの発生点のいずれかです。

VM はフレームレジスタを親関数と同じ値に設定します。これにより、ファンクレットはフレーム相対アドレスを使用してローカル変数にアクセスできます。

filter ファンクレットの場合、対応する "try" リージョンの例外発生点に存在していたその他すべてのレジスタ値は、ファンクレットへの入場時に破壊されます。つまり、既知の値を持つレジスタはファンクレットのパラメータとフレームレジスタのみです。

その他のファンクレットの場合、すべての不揮発性レジスタは例外発生点の値に復元されます。ただし、JIT のコード生成は[現在これを活用していません](https://github.com/dotnet/runtime/pull/114630#issuecomment-2810210759)。

### ファンクレットからの戻り時のレジスタ

ファンクレットの実行が終了し、VM が（EH 句のネストがある場合はその外側のファンクレットまたは）関数に実行を戻す際、不揮発性レジスタは例外発生点で保持していた値に復元されます。揮発性レジスタは破壊されていることに注意してください。

ファンクレット内で行われたレジスタの値の変更は失われます。ファンクレットがメイン関数（または "try" リージョンを含むファンクレット）に変数の変更を通知したい場合、その変数の変更は共有されるメイン関数のスタックフレームに対して行う必要があります。これは根本的な制限ではありません。必要であれば、ランタイムを更新してファンクレット内で行われた不揮発性レジスタの変更を保持することが可能です。

ファンクレットは不揮発性レジスタを保持する必要はありません。

# EH 情報、GC 情報、およびホット＆コールドスプリッティング

::: tip 💡 初心者向け補足
ホット＆コールドスプリッティング (Hot & Cold Splitting) とは、JIT が頻繁に実行されるコード（ホットコード）とめったに実行されないコード（コールドコード、例えば例外ハンドラ）を分離する最適化手法です。ホットコードをまとめて配置することで、CPU キャッシュの局所性が向上し、パフォーマンスが改善されます。
:::

すべての GC 情報オフセットおよび EH 情報オフセットは、関数とファンクレット (funclet) をあたかも1つの大きなメソッド本体であるかのように扱います。したがって、すべてのオフセットはメインメソッドの先頭からの相対値です。ファンクレットは常にメイン関数コードのすべての後（末尾）にあると仮定されます。したがって、メイン関数にコールドコードがある場合、すべてのファンクレットもコールドでなければなりません。逆に言えば、ホットなファンクレットコードがある場合、メインメソッド全体がホットでなければなりません。

## EH 句の順序

EH 句は、try 開始/try 終了ペアの IL オフセットに基づいて、内側から外側へ、先頭から末尾への順序でソートされなければなりません。唯一の例外はクローンされた finally であり、これは常に末尾に配置されます。

## EH が GC 情報/報告に与える影響

メイン関数本体は、そのファンクレットの1つがスタック上にあるとき、**常に** スタック上に存在します。そのため、GC 情報は二重報告しないよう注意しなければなりません。JIT64 は、すべての名前付きローカル変数を親メソッドフレームに配置し、関数とファンクレット間で共有されるものはスタックにホーミングし、親関数のみがスタックローカル変数を報告する（ファンクレットはローカルレジスタを報告する場合がある）ことでこれを達成しました。JIT32 と RyuJIT（AMD64、ARM、ARM64 向け）は逆のアプローチを取ります。最も末端のファンクレットが、ファンクレットから生存している可能性のあるすべてのものを報告する責任を持ちます（フィルタの場合、元のメソッド本体に戻って再開する可能性があります）。これは GC ヘッダフラグ WantsReportOnlyLeaf（JIT32 と RyuJIT が設定し、JIT64 は設定しない）と、VM が特定のフレームに対してすでにファンクレットを検出したかどうかを追跡することで実現されます。JIT64 が完全に引退すれば、このフラグを GC 情報から削除できるはずです。

WantsReportOnlyLeaf モデルの VM 実装には、JIT が生成できるコードに影響を与える「コーナーケース」が1つあります。ネストされた例外処理を持つ以下の関数を考えてみましょう：

```cs
public void runtest() {
    try {
        try {
            throw new UserException3(ThreadId);	// 1
        }
        catch (UserException3 e){
            Console.WriteLine("Exception3 was caught");
            throw new UserException4(ThreadId);
        }
    }
    catch (UserException4 e) { // 2
        Console.WriteLine("Exception4 was caught");
    }
}
```

内側の "throw new UserException4" が実行されると、例外処理の第1パスで外側の catch ハンドラがこの例外を処理することが判明します。例外処理の第2パスでスタックフレームを "runtest" フレームまでアンワインドし、catch ハンドラを実行します。元の catch ハンドラ ("catch (UserException3 e)") がスタック上になくなってから、新しい catch ハンドラが実行されるまでの間に、時間的な空白が生じます。この間に GC が発生する可能性があります。この場合、VM は "runtest" 関数の GC ルートを適切に報告する必要があります。内側の catch はアンワインドされているため、そこを報告することはできません。スタック上にまだ残っている "// 1" で報告することも望ましくありません。なぜなら、それは実質的に実行を「遡る」ことになり、どのオブジェクト参照が生存しているかを正しく表していないためです。次に実行が行われる場所で生存しているオブジェクト参照を報告する必要があります。それが "// 2" の場所です。しかし、catch ファンクレットの最初の場所は非割り込み可能であるため、そこを報告することはできません。代わりに VM はそのハンドラ内の最初の割り込み可能ポイントを先読みし、JIT がその場所で報告する生存参照を報告します。この場所はハンドラプロローグの直後の最初の場所になります。この実装は JIT に対していくつかの影響を与えます。以下が要求されます：

1. EH 句を持つメソッドは完全に割り込み可能 (fully interruptible) でなければなりません。
2. すべての catch ファンクレットはプロローグの直後に割り込み可能ポイントを持たなければなりません。
3. catch ファンクレットの最初の割り込み可能ポイントは、スタック上の以下の生存オブジェクトを報告しなければなりません：
   - 親メソッドと共有されるオブジェクトのみ。つまり、catch ファンクレットでのみ生存し、親メソッドでは生存していない追加のスタックオブジェクトは含めません。
   - catch ファンクレットおよび後続の制御フローで参照されるすべての共有オブジェクトが生存として報告されなければなりません。

## フィルタの GC セマンティクス

フィルタ (filter) は EH 処理の第1パスで呼び出されるため、フォルトアドレス、フィルタハンドラ、またはその他の場所で実行が再開される可能性があります。VM はフィルタの呼び出し中および呼び出し後に GC の発生を許可しなければなりませんが、EH サブシステムがどこで再開するかがまだわかっていない段階であるため、フォルトアドレス**および**フィルタ内の両方ですべてを生存状態に保つ必要があります。これは3つの手段によって達成されます：(1) VM のスタックウォーカーと GCInfoDecoder がフィルタフレームとそれに対応する親フレームの両方を生存として報告する、(2) JIT がフィルタ内で生存しているすべてのスタックスロットをピン留め (pinned) としてエンコードする、(3) JIT がフィルタから生存アウト (live-out) するすべてのものを生存として報告する（場合によってはゼロ初期化する）。(1) のため、フィルタ内と try 本体の両方で生存しているスタック変数は二重報告される可能性が高いです。GC のマークフェーズでは二重報告は問題になりません。問題が生じるのはオブジェクトが再配置 (relocate) される場合のみです：同じ場所が2回報告されると、GC はその場所に格納されているアドレスを2回再配置しようとします。そのため、オブジェクトをピン留めして再配置を防止します。これが (2) を行う必要がある理由です。(3) は、フィルタが返った後、フィルタハンドラまたは同じフレーム内のいずれかの外側ハンドラを実行する前に、安全に GC を実行できるようにするために行われます。同じ理由から、制御はフィルタ領域の最終ブロックを介して終了しなければなりません（つまり、フィルタ領域はフィルタ領域を離れる命令で終了しなければならず、プログラムは他のパスからフィルタ領域を終了してはなりません）。

## 同じ try 領域をカバーする句

連続するいくつかの句が同じ `try` ブロックをカバーする場合があります。前の句と同じ領域をカバーする句は `COR_ILEXCEPTION_CLAUSE_SAMETRY` フラグでマークされます。例外 ex1 が別の例外 ex2 のハンドラの実行中にスローされ、例外 ex2 が ex1 のハンドラフレームをエスケープした場合、このフラグによりランタイムは ex1 を処理した句と同じ `try` ブロックをカバーする句をスキップできます。
このフラグは NativeAOT と CoreCLR の新しい例外処理メカニズムで使用されます。NativeAOT はエンコードされた句データにこのフラグを格納せず、代わりに同じ `try` ブロックを持つ句の間にダミー句を挿入します。CoreCLR は句データのランタイム表現の一部としてこのフラグを保持します。現在の CoreCLR の例外処理はそれを使用しませんが、開発中の[新しい例外処理メカニズム](https://github.com/dotnet/runtime/issues/77568)がそれを活用しています。

## GC 割り込み可能性と EH

VM は、スレッドが停止されるたびに、GC セーフポイントにあるか、現在のフレームが再開不可能（つまり、同じフレーム内でキャッチされることのない throw）であると仮定します。したがって、実質的に EH を持つすべてのメソッドは完全に割り込み可能でなければなりません（最低限、すべての try 本体が割り込み可能でなければなりません）。現在、GC 情報は同じメソッド内で部分的に割り込み可能な領域と完全に割り込み可能な領域を混在させることをサポートしているように見えますが、どの JIT もこれを使用していないため、自己責任でご使用ください。

デバッガは常に GC セーフポイントで停止したいため、デバッグ可能なコードはデバッガが安全に停止できる場所を最大化するために完全に割り込み可能であるべきです。JIT が完全に割り込み可能なコード内に非割り込み可能な領域を作成する場合、各シーケンスポイントが割り込み可能な命令で始まるようにすべきです。

AMD64/JIT64 のみ：JIT は必要に応じて割り込み可能な NOP を追加します。

## セキュリティオブジェクト

セキュリティオブジェクトは GC ポインタであり、そのように報告され、メソッドの存続期間中生存状態に保たれなければなりません。

## GS Cookie

GS Cookie は GC オブジェクトではありませんが、報告される必要があります。GC 情報でのエンコード/報告方法のため、ライフタイムは1つしか持てません。GS Cookie はスタックをポップすると無効になるため、エピローグはライブ範囲の一部にはなれません。ライブ範囲が1つしか取れないため、GS Cookie を持つメソッドではエピローグの後にコード（ファンクレットを除く）を配置することはできません。

## NOP とその他のパディング

### AMD64 パディング情報

アンワインドコールバックは、現在のフレームがリーフフレームなのかリターンアドレスなのかを判別できません。したがって、JIT は呼び出しのリターンアドレスが呼び出しと同じ領域内にあることを保証しなければなりません。具体的には、JIT は、呼び出しがそのまま try 本体の開始、try 本体の終了、またはメソッドの終了の直前に来る場合、その呼び出しの後に NOP（またはその他の命令）を追加しなければなりません。

OS はアンワインダに最適化があり、アンワインドの結果 PC がエピローグ内（またはエピローグの開始位置）にある場合、そのフレームは重要でないと仮定して再びアンワインドします。CLR はすべてのフレームを重要とみなすため、この二重アンワインド動作を望まず、JIT に呼び出しとエピローグの間に NOP（またはその他の命令）を配置することを要求します。

### ARM および ARM64 パディング情報

OS アンワインダは `RUNTIME_FUNCTION` の範囲を使用して、どの関数またはファンクレットからアンワインドするかを決定します。結果として、`IL_Throw` への呼び出し（bl オペコード）を最後の命令にすることはできません。したがって AMD64 と同様に、`bl IL_Throw` が関数またはファンクレットの最後のオペコード、ホットセクションの終了前の最後のオペコード、または（これは ARM に漏れ出た x86 の慣習かもしれませんが）「特殊 throw ブロック」の直前の最後のオペコードになる場合、JIT はオペコード（この場合はブレークポイント）を挿入しなければなりません。

# プロファイラーフック

::: tip 💡 初心者向け補足
プロファイラーフック (Profiler Hooks) は、プロファイリングツールが実行時にメソッドの入口・出口・テールコールを監視できるようにするコールバックの仕組みです。Java の JVMTI エージェントに似た概念で、パフォーマンス分析やコードカバレッジ計測などに使用されます。
:::

JIT に `CORJIT_FLG_PROF_ENTERLEAVE` が渡された場合、JIT はネイティブの入口/出口/テールコールプローブを挿入する必要があるかもしれません。確実に判断するために、JIT は GetProfilingHandle を呼び出す必要があります。この API は out パラメータとして、JIT が実際にプローブを挿入すべきかどうかを示す動的なブール値と、コールバックに渡すパラメータ（void\* 型）を返します。オプションで間接参照（NGEN で使用）もあります。このパラメータは常にすべてのコールアウトの第1引数です（したがって、通常の第1引数レジスタ `RCX`（AMD64）または `R0`（ARM、ARM64）に配置されます）。

プロローグの外側（GC 割り込み可能な場所）で、JIT は `CORINFO_HELP_PROF_FCN_ENTER` への呼び出しを挿入します。AMD64 の場合、Windows ではすべての引数レジスタが呼び出し元が割り当てたスタック位置にホーミングされ（varargs と同様）、Unix ではすべての引数レジスタが内部構造体に格納されます。ARM および ARM64 の場合、すべての引数はプリスピル (prespill) されます（これも varargs と同様）。

戻り値を計算して正しいレジスタに格納した後、エピローグコードの前（GS Cookie チェックの前を含む）に、JIT は `CORINFO_HELP_PROF_FCN_LEAVE` への呼び出しを挿入します。AMD64 の場合、この呼び出しはリターンレジスタを保存しなければなりません：Windows では `RAX` または `XMM0`、Unix では `RAX` と `RDX` または `XMM0` と `XMM1` です。ARM の場合、戻り値は `R0` から `R2` に移動され（`R0` にあった場合）、`R1`、`R2`、および `S0/D0` は呼び出し先によって保存されなければなりません（long は `R2`、`R1` の順 — レジスタの並び順が通常と異なることに注意、浮動小数点は `S0`、倍精度は `D0`、より小さい整数型は `R2`）。

TODO：ARM64 のプロファイルリーブ規約を記述する。

テールコールまたはジャンプコールの引数セットアップの前（ただし引数の副作用の後）に、JIT は `CORINFO_HELP_PROF_FCN_TAILCALL` への呼び出しを挿入します。自己再帰的なテールコールがループに変換された場合は呼び出されないことに注意してください。

ARM のテールコールの場合、JIT は実際には先に送信引数をロードし、プロファイラーコールアウトの直前に `R0` の引数を別の非揮発性レジスタにスピルし、呼び出しを行い（コールバックパラメータを `R0` で渡し）、その後 `R0` を復元します。

AMD64 の場合、すべてのプローブはデフォルトの引数規則に従って `RDX` で渡される第2パラメータを受け取ります。これは引数のホーム位置の開始アドレス（呼び出し元のスタックポインタの値に相当）です。

TODO：ARM64 のテールコール規約を記述する。

Linux/x86 では、プロファイリングフックは `__cdecl` 属性で宣言されます。cdecl（C declaration の略）では、サブルーチンの引数はスタック上で渡されます。整数値とメモリアドレスは EAX レジスタで返され、浮動小数点値は ST0 x87 レジスタで返されます。レジスタ EAX、ECX、EDX は呼び出し元保存 (caller-saved) であり、残りは呼び出し先保存 (callee-saved) です。x87 浮動小数点レジスタ ST0 から ST7 は、新しい関数を呼び出す際に空（ポップまたは解放）でなければなりません。また、関数の終了時には ST1 から ST7 は空でなければなりません。ST0 も戻り値の返却に使用しない場合は空でなければなりません。マネージドコードの戻り値は leave/tailcall プロファイリングフックの前に形成されるため、これらのフックで保存し、フックからの復帰時に復元する必要があります。プロファイリングフックのアセンブラ実装における命令 `ret` はパラメータなしでなければなりません。

JIT32 はプロファイラーフックがある場合、エピローグを1つだけ生成し（すべての return をそこにブランチさせ）ます。

# 同期メソッド

JIT32/RyuJIT はメソッドが同期化されている場合、エピローグを1つだけ生成し（すべての return をそこにブランチさせ）ます。`Compiler::fgAddSyncMethodEnterExit()` を参照してください。ユーザーコードは try/finally でラップされます。try 本体の外側/前で、コードはブール値を false に初期化します。`CORINFO_HELP_MON_ENTER` または `CORINFO_HELP_MON_ENTER_STATIC` が呼び出され、ロックオブジェクト（インスタンスメソッドの場合は `this` ポインタ、静的メソッドの場合は Type オブジェクト）とブール値のアドレスが渡されます。ロックが取得されると、ブール値が true に設定されます（Thread.Abort/EH/GC などがブール値とロックの取得状態が一致しないときにスレッドを中断できないという意味で「アトミック」な操作です）。JIT32/RyuJIT は finally 内の `CORINFO_HELP_MON_EXIT` / `CORINFO_HELP_MON_EXIT_STATIC` の呼び出し配置についてまったく同じロジックと引数に従います。

# Rejit

AMD64 でプロファイラーアタッチシナリオをサポートするために、JIT は生成されるすべてのメソッドがホットパッチ可能であることを保証するよう要求される場合があります（`CORJIT_FLG_PROF_REJIT_NOPS` を参照）。これを実現する方法は、コードの最初の5バイトが非割り込み可能であり、それらのバイト内にブランチターゲットがないこと（呼び出し/リターンを含む）を保証することです。これにより、VM は（GC のときと同様に）すべてのスレッドを停止し、安全にその5バイトをメソッドの新バージョン（おそらくプロファイラーによってインストルメントされたもの）へのブランチに置き換えることができます。JIT はこれらの2つの要件を達成するために NOP を追加するか、GC 情報で報告されるプロローグのサイズを増やします。

例外処理を持つ関数では、メイン関数のみが影響を受けます。ファンクレットのプロローグはホットパッチ可能にはされません。

# エディットアンドコンティニュー

::: tip 💡 初心者向け補足
エディットアンドコンティニュー (Edit and Continue, EnC) は、デバッグ中にアプリケーションを再起動することなくコードを変更できるデバッガ機能です。Java の HotSwap や、.NET のホットリロード (Hot Reload) に類似した概念です。開発者はブレークポイントで停止中にコードを編集し、そのまま実行を継続できます。
:::

エディットアンドコンティニュー (EnC) は最適化されていないコードの特殊な形態です。デバッガは、メソッドの状態（命令ポインタとローカル変数）を元のメソッドコードから編集後のメソッドコードに確実に再マッピングできなければなりません。これは JIT が行うメソッドのスタックレイアウトに制約を課します。主要な制約は、既存のローカル変数のアドレスが編集後も同じでなければならないことです。この制約が必要なのは、ローカル変数のアドレスがメソッドの状態に格納されている可能性があるためです。

現在の設計では、JIT はメソッドの以前のバージョンにアクセスできないため、最悪のケースを想定する必要があります。EnC は生成されるコードのパフォーマンスではなく、シンプルさのために設計されています。

EnC は現在 x86、x64、ARM64 でのみ有効ですが、他のプラットフォームで有効にされた場合も同じ原則が適用されます。

以下のセクションでは、従わなければならないさまざまな EnC コード規約について説明します。

## GCInfo の EnC フラグ

JIT は EnC コードの規約に従ったことを GC 情報に記録します。x64/ARM64 では、このフラグは EnC 編集間で保持されるスタックフレーム領域のサイズを記録すること（`GcInfoEncoder::SetSizeOfEditAndContinuePreservedArea`）によって暗示されます。x64 ではこの領域のサイズが `RSI` と `RDI` を含むように拡張され、ブロック初期化やブロックムーブに `rep stos` を使用できるようになります。ARM64 は EnC が有効な場合、FP と LR レジスタのみを保存し、他のカリー保存レジスタは使用しません。

EnC 遷移を正常に実行するために、ランタイムは遷移元と遷移先のスタックフレームのサイズを知る必要があります。x64 コードの場合、サイズはアンワインドコードから抽出できます。arm64 コードではフレームの設定方法によりアンワインドコードからこの値を取得できないため、ARM64 では GC 情報に EnC 目的で使用する固定スタックフレームのサイズも含まれます。

## ローカル変数の逆方向への割り当て

EnC 編集で新しいローカル変数が追加された場合に既存のローカル変数のアドレスを保持するために必要です。つまり、最初のローカル変数は最も高いスタックアドレスに割り当てられなければなりません。アラインメントの処理には特別な注意が必要です。メソッドフレームの合計サイズは、編集後に増加（ローカル変数の追加）することも減少（テンポラリの減少）することもあります。VM は新しく追加されたローカル変数をゼロクリアします。

## カリー保存レジスタの固定セット

これにより VM で異なるレジスタセットに対応する必要がなくなり、ローカル変数のアドレスの保持が容易になります。揮発性レジスタは十分にあるため、非揮発性レジスタの不足は最適化されていないコードの品質に大きな影響を与えません。
x64 では現在 RBP、RSI、RDI を保存し、ARM64 では FP と LR のみを保存します。

## EnC は EH を持つメソッドでサポートされます

ただし、EnC の再マッピングはファンクレット内ではサポートされません。ファンクレットのスタックレイアウトは EnC には関係ありません。

## Localloc

EnC コードで Localloc は許可されますが、メソッドが localloc 命令を実行した後は再マッピングが禁止されます。VM は上記の不変条件（x64 では `RSP == RBP`、ARM64 では `FP + 16 == SP + stack size`）を使用して、メソッドが localloc を実行したかどうかを検出します。

## セキュリティオブジェクト

x64/arm64 では JIT による特別な処理は不要です（x86 とは異なります）。セキュリティオブジェクトは必要に応じて再マッピング中に VM によってコピーされます。セキュリティオブジェクトの場所は GC 情報から見つけられます。

## 同期メソッド

JIT が同期メソッドのために作成する追加の状態（ロック取得フラグ）は再マッピング中に保持されなければなりません。JIT はこの状態を保持領域に格納し、GC 情報で報告される保持領域のサイズをそれに応じて増加させます。

## ジェネリクス

EnC はジェネリックメソッドの追加と編集、ジェネリック型のメソッド、および非ジェネリック型のジェネリックメソッドでサポートされています。

## 非同期メソッド

JIT はランタイム非同期メソッドで現在の `ExecutionContext` と `SynchronizationContext` を保存し、これらは再マッピング中に保持されなければなりません。新しい GC エンコーダはこの状態を EnC フレームヘッダサイズに含めます。JIT32 の場合、EE は `getMethodInfo` から `CORINFO_ASYNC_SAVE_CONTEXTS` が報告されたときにこの状態が存在することを期待します。

# ポータブルエントリポイント

動的コード生成を許可するプラットフォームでは、ランタイムは動的にロードされたメソッドの実行戦略を [`Precode`](./method-descriptor#precode) を割り当てることで抽象化します。`Precode` は実際のメソッドコードが取得されるまでの一時的なメソッドエントリポイントとして使用される小さなコードフラグメントです。`Precode` は通常の JIT コンパイルまたは AOT コンパイルされたコードを持たないメソッド（例えばスタブやインタープリタメソッド）の実行の一部としても使用されます。`Precode` により、ターゲットメソッドが使用する実行戦略に関係なく、ネイティブコードは同じネイティブコード呼び出し規約を使用できます。

動的コード生成を許可しないプラットフォーム（Wasm）では、ランタイムは動的にロードされたメソッドにポータブルエントリポイント (portable entrypoint) を割り当てることで実行戦略を抽象化します。`PortableEntryPoint` はターゲットメソッドの目的の実行戦略への効率的な遷移を可能にするデータ構造です。ランタイムがポータブルエントリポイントを使用するように構成されている場合、マネージド呼び出し規約は以下のように変更されます：

- 呼び出すネイティブコードはエントリポイントを逆参照することで取得されます

- エントリポイントアドレスは追加の最後の隠し引数として渡されます。この追加の隠し引数はすべてのメソッドのシグネチャに存在しなければなりません。JIT コンパイルまたは AOT コンパイルされたメソッドのコードでは使用されません。

ポータブルエントリポイントを使用した呼び出しの擬似コード：

> `(*(void**)pfn)(arg0, arg1, ..., argN, pfn)`

ポータブルエントリポイントは現在 Wasm のインタープリタでのみ使用されています。Native AOT は動的ロードをサポートしないため、Wasm の Native AOT ではポータブルエントリポイントは不要です。

# System V x86_64 サポート

::: tip 💡 初心者向け補足
System V は Linux や macOS で使用される標準的な ABI (Application Binary Interface) です。Windows は独自の ABI を使用しており、レジスタの使い方や呼び出し規約が異なります。たとえば、Windows AMD64 では最初の整数引数を RCX で渡しますが、System V では RDI を使います。この違いを理解することは、クロスプラットフォームの .NET ランタイム開発において重要です。
:::

このセクションは主に System V システム (Ubuntu Linux や Mac OS X など) における呼び出し規約に関するものです。
System V x86_64 ABI ドキュメントに記載されている一般的なルールに従いますが、以下に示すいくつかの例外があります。

1. 値渡しの構造体に対する隠し引数は、常に `this` パラメータの後に配置されます (存在する場合)。これは System V ABI との違いであり、内部 JIT 呼び出し規約にのみ影響します。PInvoke 呼び出しでは、この場合 `this` パラメータが存在しないため、隠し引数は常に最初のパラメータになります (`CallConvMemberFunction` の場合を除く)。
2. フィールドを持たないマネージド構造体は、常にスタック上で値渡しされます。
3. JIT は、ネイティブ OS ツールによるスタックアンワインドなどを支援するために、フレームレジスタフレーム (`RBP` をフレームレジスタとして使用) を積極的に生成します。
4. PInvoke、EH、およびジェネリクスサポートに関する他のすべての内部 VM 規約はそのまま維持されます。詳細については上記の関連セクションを参照してください。ただし、異なる呼び出し規約のため、System V では使用されるレジスタが異なることに注意してください。たとえば、整数引数レジスタは順に RDI、RSI、RDX、RCX、R8、R9 です。したがって、Windows AMD64 では最初の引数 (通常は `this` ポインタ) が RCX に入りますが、System V では RDI に入ります。
5. 明示的レイアウト (explicit layout) を持つ構造体は、常にスタック上で値渡しされます。
6. 以下の表は System V x86_64 ABI に基づくレジスタ使用法を説明しています。

```
| Register      | Usage                                   | Preserved across  |
|               |                                         | function calls    |
|---------------|-----------------------------------------|-------------------|
| %rax          | temporary register; with variable argu- | No                |
|               | ments passes information about the      |                   |
|               | number of SSE registers used;           |                   |
|               | 1st return argument                     |                   |
| %rbx          | callee-saved register; optionally used  | Yes               |
|               | as base pointer                         |                   |
| %rcx          | used to pass 4st integer argument to    | No                |
|               | to functions                            |                   |
| %rdx          | used to pass 3rd argument to functions  | No                |
|               | 2nd return register                     |                   |
| %rsp          | stack pointer                           | Yes               |
| %rbp          | callee-saved register; optionally used  | Yes               |
|               | as frame pointer                        |                   |
| %rsi          | used to pass 2nd argument to functions  | No                |
| %rdi          | used to pass 1st argument to functions  | No                |
| %r8           | used to pass 5th argument to functions  | No                |
| %r9           | used to pass 6th argument to functions  | No                |
| %r10          | temporary register, used for passing a  | No                |
|               | function's static chain pointer         |                   |
| %r11          | temporary register                      | No                |
| %r12-%r15     | callee-saved registers                  | Yes               |
| %xmm0-%xmm1   | used to pass and return floating point  | No                |
|               | arguments                               |                   |
| %xmm2-%xmm7   | used to pass floating point arguments   | No                |
| %xmm8-%xmm31  | temporary registers                     | No                |
```

# x86 の呼び出し規約の詳細

RyuJIT がサポートする他のアーキテクチャとは異なり、マネージド x86 呼び出し規約はデフォルトのネイティブ呼び出し規約とは異なります。これは Windows と Unix の x86 の両方に当てはまります。

標準的なマネージド呼び出し規約は、Windows x86 の fastcall 規約のバリエーションです。主に引数がスタックにプッシュされる順序が異なります。

レジスタで渡すことができる値は、マネージドおよびアンマネージドポインタ、オブジェクト参照、および組み込み整数型 (int8、unsigned int8、int16、unsigned int16、int32、unsigned int32、native int、native unsigned int)、および 4 バイト整数プリミティブ型フィールドを 1 つだけ持つ列挙型と値型のみです。列挙型はその基底型として渡されます。すべての浮動小数点値と 8 バイト整数値はスタック上で渡されます。戻り値の型がレジスタで渡すことができない値型の場合、呼び出し元は結果を保持するバッファを作成し、このバッファのアドレスを隠しパラメータとして渡す必要があります。

引数は左から右の順序で渡されます。`this` ポインタ (インスタンスメソッドおよび仮想メソッドの場合) から始まり、必要に応じてリターンバッファポインタが続き、その後にユーザー指定の引数値が続きます。レジスタに配置できる最初の引数は ECX に、次の引数は EDX に入り、残りはすべてスタック上で渡されます。これは、引数を右から左の順序でスタックにプッシュする x86 ネイティブ呼び出し規約とは対照的です。

戻り値は以下のように処理されます。

1. 浮動小数点値はハードウェア FP スタックの先頭に返されます。
2. 32 ビット以下の整数は EAX に返されます。
3. 64 ビット整数は、EAX に下位 32 ビット、EDX に上位 32 ビットを格納して渡されます。
4. その他のすべてのケースではリターンバッファ (return buffer) を使用する必要があり、それを通じて値が返されます。[リターンバッファ](#return-buffers)を参照してください。

# Windows における制御フローガード (CFG) サポート

::: tip 💡 初心者向け補足
制御フローガード (Control Flow Guard, CFG) は、攻撃者がプログラムの実行フローを乗っ取ることを防止するセキュリティ機能です。具体的には、間接呼び出し (関数ポインタ経由の呼び出しなど) の宛先が正当なものであるかを検証します。バッファオーバーフローなどの脆弱性を悪用して関数ポインタを書き換える攻撃に対する防御策として機能します。
:::

制御フローガード (CFG) は Windows で利用可能なセキュリティ緩和策です。
CFG が有効な場合、オペレーティングシステムは、あるアドレスが有効な間接呼び出しターゲットとみなされるかどうかを検証するために使用できるデータ構造を維持します。
このメカニズムは、それぞれ異なる特性を持つ 2 つの異なるヘルパー関数を通じて公開されます。

最初のメカニズムはバリデータ (validator) であり、ターゲットアドレスを引数として受け取り、そのアドレスが期待される間接呼び出しターゲットでない場合にフェイルファストします。そうでなければ、何もせずに返ります。
2 番目のメカニズムはディスパッチャ (dispatcher) であり、非標準レジスタでターゲットアドレスを受け取ります。アドレスの検証に成功すると、ターゲット関数に直接ジャンプします。
Windows はディスパッチャを ARM64 と x64 でのみ利用可能にしていますが、バリデータはすべてのプラットフォームで利用可能です。
ただし、JIT は ARM64 と x64 でのみ CFG をサポートしており、これらのプラットフォームでは CFG はデフォルトで無効になっています。
CFG 機能の想定される用途は、CFG が必要とされる制約のある環境で実行される NativeAOT シナリオです。

ヘルパーは標準的な JIT ヘルパー `CORINFO_HELP_VALIDATE_INDIRECT_CALL` および `CORINFO_HELP_DISPATCH_INDIRECT_CALL` として JIT に公開されます。

バリデータを使用するには、JIT は間接呼び出しをバリデータへの呼び出しとそれに続く検証済みアドレスへの呼び出しに展開します。
ディスパッチャの場合、JIT はターゲットを渡すように呼び出しを変換しますが、それ以外は通常通り呼び出しを設定します。

ここでの「間接呼び出し」とは、命令ストリーム内の即値アドレスへの呼び出しではないすべての呼び出しを指すことに注意してください。
たとえば、直接呼び出しであっても、ティアリング (tiering) やまだコンパイルされていない場合などの理由で、JIT コード生成時に間接呼び出し命令を発行することがあります。これらも CFG メカニズムで展開されます。

以下のセクションでは、JIT がこれらのヘルパーに期待する呼び出し規約について説明します。

## ARM64 の CFG の詳細

ARM64 では、`CORINFO_HELP_VALIDATE_INDIRECT_CALL` は呼び出しアドレスを `x15` で受け取ります。
通常のレジスタに加えて、すべての浮動小数点レジスタ、`x0`-`x8`、および `x15` を保持します。

`CORINFO_HELP_DISPATCH_INDIRECT_CALL` は呼び出しアドレスを `x9` で受け取ります。
JIT は分岐予測器の性能が低下するため、デフォルトではディスパッチヘルパーを使用しません。
そのため、すべての間接呼び出しをバリデーションヘルパーと手動呼び出しで展開します。

## x64 の CFG の詳細

x64 では、`CORINFO_HELP_VALIDATE_INDIRECT_CALL` は呼び出しアドレスを `rcx` で受け取ります。
通常のレジスタに加えて、すべての浮動小数点レジスタ、`rcx`、および `r10` も保持します。さらに、シャドウスタック空間を割り当てる必要はありません。

`CORINFO_HELP_DISPATCH_INDIRECT_CALL` は呼び出しアドレスを `rax` で受け取り、`r10` と `r11` を使用および破壊する権利を持ちます。
JIT はコードサイズの利点がより正確でない分岐予測を上回ると期待されるため、可能な限り x64 でディスパッチヘルパーを使用します。
ただし、ディスパッチャでの `r11` の使用は VSD 呼び出しと互換性がないため、JIT はバリデータと手動呼び出しにフォールバックする必要があることに注意してください。

# Memset/Memcpy に関する注意事項

一般的に、`memset` と `memcpy` はアトミック性 (atomicity) の保証を一切提供しません。つまり、`memset`/`memcpy` で変更されるメモリが他のスレッド (GC を含む) から観測可能でない場合、または[メモリモデル](https://github.com/dotnet/runtime/blob/main/docs/specs/Memory-model.md)に基づくアトミック性の要件がない場合にのみ使用すべきです。特にマネージドポインタを含むヒープを変更する場合は重要です。マネージドポインタはアトミックに更新する必要があります。たとえば、ポインタサイズの `mov` 命令を使用します (マネージドポインタは常にアライメントされています)。詳細は[アトミックメモリアクセス](https://github.com/dotnet/runtime/blob/main/docs/specs/Memory-model.md#Atomic-memory-accesses)を参照してください。「更新」とは「ゼロに設定する」ことを暗示しており、それ以外の場合はライトバリア (write barrier) が必要であることに注意してください。

例:

```cs
struct MyStruct
{
	long a;
	string b;
}

void Test1(ref MyStruct m)
{
	// ここでは memset を使用してはいけない
	m = default;
}

MyStruct Test2()
{
	// ここでは memset を使用できる
	return default;
}
```

# インタプリタ ABI の詳細

::: tip 💡 初心者向け補足
.NET ランタイムには JIT コンパイラの代替としてインタプリタ (interpreter) が含まれています。インタプリタは、WebAssembly のような JIT コンパイルが利用できない環境や、起動時間を短縮したい場合に使用されます。Java のバイトコードインタプリタと同様に、IL コードを直接解釈実行しますが、JIT コンパイルされたコードよりも実行速度は遅くなります。
:::

インタプリタのデータスタックは通常の「スレッド」スタックとは別に割り当てられ、上方向 (UP) に成長します。インタプリタの実行制御スタックは「スレッド」スタック上に割り当てられ、スレッドの Frame チェーンに配置される `InterpreterFrame` に対して単方向リンクリストで連結された一連の `InterpMethodContextFrame` 値として構成されます。`InterpMethodContextFrame` 構造体は常に降順に割り当てられるため、呼び出し先メソッドに関連する `InterpMethodContextFrame` は、その呼び出し元や含まれている `InterpreterFrame` よりも常にメモリ上の低いアドレスに配置されます。

メソッド内のベーススタックポインタは変化しませんが、インタプリタ内で関数が呼び出されると、渡された引数のセットに関連付けられたスタックポインタを持ちます。実質的に、引数渡しは呼び出し元関数の一時引数空間の一部を呼び出し先に与えることで行われます。

すべての命令と GC はスタックポインタからの相対アドレスで参照され、スタックポインタは移動しません。このため、localloc 命令の実装は実際にはヒープ上にメモリを割り当てる必要があり、localloc で割り当てられたメモリはデータスタックとは一切関連付けられません。

すべてのインタプリタ関数のスタックポインタは常に `INTERP_STACK_ALIGNMENT` 境界でアライメントされています。現在、これは 16 バイトのアライメント要件です。

スタック要素は常に少なくとも `INTERP_STACK_SLOT_SIZE` でアライメントされ、`INTERP_STACK_ALIGNMENT` を超えることはありません。現在の実装では `INTERP_STACK_SLOT_SIZE` を 8、`INTERP_STACK_ALIGNMENT` を 16 に設定しているため、スタック上のすべてのデータは 8 バイトまたは 16 バイトのアライメントになります。

4 バイト未満のプリミティブ型は、スタック上では常にゼロ拡張または符号拡張されて 4 バイトになります。

関数が非同期 (async) の場合、継続リターン (continuation return) を持ちます。このリターンはデータスタックを使用せず、`InterpreterFrame` の Continuation フィールドを設定することで行われます。サンク (thunk) は、JIT でコンパイルされたコードに入る/出る際にこの値を設定/リセットする役割を担います。

# Web Assembly ABI (R2R および JIT)

Web Assembly にコンパイルされたマネージドメソッド (以下「マネージドコード」) では、CLR は一般的に [Wasm Basic C ABI](https://github.com/WebAssembly/tool-conventions/blob/main/BasicCABI.md) に従います。

マネージドコードは C コードと同じリニアスタック (linear stack) を使用します。スタックは下方向に成長します。

## 受信引数 ABI

リニアスタックポインタ `$sp` はすべてのメソッドの最初の引数です。ネイティブからマネージドへの遷移時には、`$__stack_pointer` グローバルの値になります。このグローバルはマネージドコード内で現在の `$sp` に更新される場合があり、マネージドからネイティブへの境界では現在の `$sp` と同期している必要があります。メソッド内では、スタックポインタは常にスタックの底 (最低アドレス) を指します。一般的にこれはエントリ時のスタックポインタの値からの固定オフセットですが、動的割り当てが可能なメソッドでは例外です。

フレームポインタが使用される場合、スタックの「固定」部分の底を指し、正のオフセットのみを許可する Wasm アドレッシングモードの使用を容易にします。

構造体は一般的に参照渡し (by-reference) されます。ただし、単一のプリミティブフィールドを正確に含む場合 (またはそのような構造体を正確に含む構造体の場合) は例外です。リニアスタックが参照渡し構造体のバッキングストレージを提供します。

構造体は一般的に隠しバッファ (hidden buffer) を通じて返されます。そのアドレスは呼び出し元によって提供され、マネージド `this` の直後に渡されるか、`this` が存在しない場合は `$sp` 引数の後に渡されます。この場合、メソッドの戻り値は戻り値のアドレスです。ただし、構造体が Wasm スタック上で渡すことができる場合は、Wasm スタック上で返されます。

(未定: ベクトル型の ABI)

### プロローグ

プロローグはスタックポインタをインクリメントし、リニアスタックに格納された引数をホームし、リニアスタックのスロットを適切にゼロ初期化します。必要に応じてフレームポインタを確立します。

また、GC と EH で使用するためにフレームディスクリプタをスタックに保存します。EH または GC セーフポイントを持つメソッドでは、EH および GC 情報にインデックスを提供してメソッド内の情報を提供し、外部コードがマネージドスタックフレームをウォークできるようにする「仮想 IP」用のスロットがリニアスタックに予約されます。

### エピローグ

一般的にエピローグは空になります。Wasm にはカリーセーブレジスタ (callee-save register) の概念がなく、更新すべき他のグローバル状態もありません。

## 送信呼び出し ABI

直接マネージド呼び出しでは、Wasm はポータブルエントリポイント (Portable Entry Point) 機能を使用して、インタプリタコードとのスムーズな相互運用を実現します。これはすべてのマネージド呼び出しが間接的に行われ、ポータブルエントリポイントも最後の引数として渡されることを意味します。

呼び出しシーケンスは以下のようになります。

```
local.get sp
push arg 0
...
push arg N-1
load PortableEntryPointPtr   ;; ポータブルエントリポイントのアドレスをプッシュ (&pe)
dup
load CellIndex (from &pe)
call_indirect <tableIndex> <sigIndex>  (sig is: int32 (sp) arg0... argN-1 int32 (&pe))
```

最初はセルにターゲットメソッドが R2R コードを持つかインタプリタで実行する必要があるかを判定するコードが含まれます。メソッドに R2R コードがある場合、検証および必要に応じて修正されます。ターゲットが解決されると、セルは R2R コードがあればそれを直接参照するか、インタプリタを呼び出すためのサンクを参照するように更新できます。

仮想マネージド呼び出しのシーケンスは類似していますが、ポータブルエントリポイントは resolve ヘルパーを呼び出すことで取得されます。

```
local.get sp
push arg 0
...
push arg N-1
... push args for resolution ...
call resolve                     ;; ポータブルエントリポイントのアドレスをプッシュ (&pe)
dup
load CellIndex (from &pe)        ;; 呼び出すコードの Wasm 関数テーブルインデックスをプッシュ

call_indirect <tableIndex> <sigIndex>  (sig is: int32 (sp) arg0... argN-1 int32 (&pe))
```

`&pe` 引数はポータブルエントリポイントに渡す必要があるため、すべてのメソッドシグネチャは追加の最終引数を反映する必要があります (使用されなくても)。したがって、たとえば `int F(int x)` のようなマネージドメソッドは Wasm シグネチャ `(func (param int32 int32 int32) (result int32))` を持ちます。

代替として、`&pe` を Wasm グローバルを通じて渡すことも選択できます。

最適化として、vtable ベースの仮想マネージド呼び出しでは、resolve ヘルパーを呼び出す代わりに、適切な vtable スロットからポータブルエントリポイントを取得できます。

最適化として、呼び出し先も R2R でコンパイルされていることがわかっている場合、呼び出し元は呼び出し先を直接呼び出すことができます。R2R メソッドボディは実行時に無効化される可能性があるため、呼び出し先の R2R の検証は呼び出し元の R2R の検証時に行う必要があります。

ネイティブコードで実装された FCall は同じマネージド呼び出し規約に従います。FCall 実装マクロ (`FCIMPL`) は `$__stack_pointer` を再確立する小さなインラインアセンブリラッパーを生成するように変更されます。

## 呼び出しサイトにおける GC 参照

Wasm は Wasm スタックへの外部アクセスを許可しません。そのため、GC をトリガーする可能性のある呼び出しサイトの前に、呼び出し後も生存するすべての GC 参照 (および追跡されないすべての GC 参照、これらは実質的に常に生存) をリニアスタックに保存する必要があります。これらの GC 参照は GC にピン留め (pinned) として報告されるため、通常 Wasm ローカルに存在する場合でも、呼び出し後にそれらのローカルを更新する必要がありません。リニアスタック上の生存 GC スロットは、仮想 IP (これもリニアスタックに格納) と GC 情報 (フレームディスクリプタからアクセス可能、これもリニアスタック上) によって識別されます。

たとえば、`x(a, y(b)); ... a; ... b;` のようなコードがあり、`a` と `b` が最初に Wasm ローカルにある GC 参照であるとすると、このフラグメントは以下のようにコンパイルされます。

```
;; x への呼び出し用の sp
local.get sp

;; a をリニアメモリにスピル
local.get sp
local.get a
i32.store offset=(a's offset in gc area of stack)

;; x への呼び出し用の引数 a
local.get a

;; y への呼び出し用の sp
local.get sp

;; b をリニアメモリにスピル
local.get sp
local.get b
i32.store offset=(b's offset in gc area of stack)

;; y への呼び出し用の引数 b
local.get b

;; 生存 GC 参照を持つ y への呼び出し用に仮想 IP を更新
local.get sp
i32.const virtual-ip-for-call-to-y  (gc info : a and b slots live)
i32.store offset=(virtual-ip offset)

;; y の &pe とセルインデックスを取得し、y を呼び出す
load PortableEntryPointPtr for y
dup
load CellIndex (from &pe)
call_indirect <tableIndex> <sigIndex>  (sig is: int32 (sp) int32 int32 (&pe) : returns int32)

;; 生存 GC 参照を持つ x への呼び出し用に仮想 IP を更新 [最適化で省略可能]
local.get sp
i32.const virtual-ip-for-call-to-x (gc info : a and b slots live)
i32.store offset=(virtual-ip offset)

;; x の &pe とセルインデックスを取得し、x を呼び出す
load PortableEntryPointPtr for x
dup
load CellIndex (from &pe)
call_indirect <tableIndex> <sigIndex>  (sig is: int32 (sp) int32 int32 (&pe) : returns int32)
```

注意事項:

- 最適化として、GC/EH 情報が前回の更新から変更されていない場合、仮想 IP の更新を省略できます。
- ネストされた呼び出し結果を親呼び出しに伝えるために、Wasm スタックの代わりに Wasm ローカルを使用して、呼び出しのネストを解除することも考えられます。
- 最適化として、GC 参照のリニアスタックへの格納を最小限にします (たとえば、前回の更新から値が変更されていない場合)。
- 最適化として、一部の GC 参照を主にリニアスタック上で保持し、Wasm ローカルには保持しないようにすることも検討できます。

## 末尾呼び出し (Tail Call)

末尾呼び出しとの唯一の違いは、呼び出しで `return_call_indirect` を使用し、元の `sp` 値を呼び出し先に渡すことです。

```
local.get sp
i32.const <frameSize>
i32.add

push arg 0
...
push arg N-1
load PortableEntryPointPtr
dup
load CellIndex (from &pe)
return_call_indirect <tableIndex> <sigIndex>  (sig is: int32 (sp) arg0... argN-1 int32 (&pe))
```

間接マネージド呼び出しでも同様です。

## PInvoke

PInvoke はターゲットを呼び出す前に `$__stack_pointer` を再確立します。

## リバース PInvoke (Reverse PInvoke)

リバース PInvoke のプロローグはグローバル `$__stack_pointer` をロードし、マネージド `sp` として使用します。

リターン時に、グローバル `$__stack_pointer` はスタブエントリ時の値にリセットされます。

## 非同期 (Async)

未定

## インタプリタスタブ

マネージドコードからインタプリタへの呼び出しとインタプリタからマネージドコードへの呼び出しの両方にスタブが関与します。R2R では、これらはシグネチャごとに crossgen2 によって生成されます。

### インタプリタからマネージドへ

インタプリタからマネージドへのスタブはグローバル `$__stack_pointer` をロードし、次にインタプリタスタックからメソッド引数をロードし、最後にマネージドコードで無視される最終 `&pe` 引数のために `int32.const 0` をロードし (Wasm グローバルを通じて渡す場合はこの最後の部分は省略可能)、そしてマネージドメソッドを呼び出します。

リターン時に、グローバル `$__stack_pointer` はスタブエントリ時の値にリセットされます。

### マネージドからインタプリタへ

このスタブには現在のマネージド `sp` が渡され、それをグローバル `$__stack_pointer` に格納する必要があります。インタプリタスタック (上記参照) は新しい `InterpMethodContextFrame` フレームで拡張され、引数は Wasm ローカルからフレームに移動されます。`&pe` 引数は適切な IL メソッドボディでインタプリタを呼び出すために使用されます。
