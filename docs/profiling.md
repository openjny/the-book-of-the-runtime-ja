# プロファイリング

::: info 原文
この章の原文は [Profiling](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/profiling.md) です。
:::

## はじめに

プロファイリングとは、共通言語ランタイム (CLR) 上で実行されるプログラムの実行を監視することを意味します。この章では、ランタイムが提供するプロファイリング情報にアクセスするためのインターフェースについて詳しく説明します。

「プロファイリング API」と呼ばれていますが、この機能は従来のプロファイリングツールだけでなく、コードカバレッジユーティリティや高度なデバッグ支援ツールなど、より広範な診断ツールに適しています。

::: tip 💡 初心者向け補足
プロファイリングとは、プログラムの実行中にパフォーマンスのボトルネック（どの関数に時間がかかっているか、メモリがどのように使われているか）を特定するための技術です。Visual Studio の「診断ツール」や dotnet-trace などのツールが、この API を利用しています。
:::

## プロファイリング API の目標

- CLR 上で実行されるプログラムのパフォーマンスを分析するために既存のプロファイラーが必要とする情報を公開する
  - ランタイムの起動・シャットダウンイベント
  - AppDomain の作成・シャットダウンイベント
  - アセンブリのロード・アンロードイベント
  - JIT コンパイル・コードピッチングイベント
  - クラスのロード・アンロードイベント
  - スレッドの生成・消滅・同期
  - 関数の開始・終了イベント
  - 例外
  - GC ヒープとガベージコレクション活動の情報
- 任意の（非マネージド）COM 互換言語から呼び出し可能であること
- CPU とメモリ消費の面で効率的であること
- サンプリングプロファイラーと非サンプリングプロファイラーの両方に有用であること

::: tip 💡 初心者向け補足
**サンプリングプロファイラー**は一定間隔（例：5ミリ秒ごと）でプログラムの状態を調べます。オーバーヘッドが小さい反面、短時間の処理を見逃す可能性があります。**非サンプリングプロファイラー**はイベント発生時に同期的に通知を受けます。正確ですがオーバーヘッドが大きくなります。
:::

## プロファイリング API の概要

プロファイリング API は、プロファイラー DLL がプロファイル対象プログラムと同じプロセスにロードされる形で使用されます。

### 主要なインターフェース

- **`ICorProfilerCallback` / `ICorProfilerCallback2`** - プロファイラーが実装するコールバックインターフェース。ランタイムがイベント発生時にこのインターフェースのメソッドを呼び出す。
- **`ICorProfilerInfo`** - ランタイムが実装する情報インターフェース。プロファイラーがプロファイル対象アプリケーションの状態についてより多くの情報を取得するために呼び出す。

### プロファイラーの接続

CLR は初期化時に2つの環境変数をチェックします：

1. **`CORECLR_ENABLE_PROFILING`** - 非ゼロ値に設定されている場合にプロファイラーに接続
2. **`CORECLR_PROFILER`** - 接続するプロファイラーの CLSID または ProgID

両方のチェックが通過すると、CLR はプロファイラーのインスタンスを作成し、`ICorProfilerCallback::Initialize` メソッドを呼び出します。プロファイラーは `ICorProfilerInfo::SetEventMask` を呼び出して、関心のあるイベントカテゴリを指定します。

## プロファイリング API の主要概念

### ID

ランタイム通知は報告されたクラス、スレッド、AppDomain などの ID を提供します。これらの ID は不透明なハンドルとして扱われるべきです。

- **ClassID** - クラスを表す。ジェネリッククラスの場合、完全にインスタンス化された型を表す
- **FunctionID** - 関数のネイティブコードを表す。ジェネリック関数では複数のネイティブコードインスタンス化が存在する可能性がある
- **ObjectID** - GC ヒープ上のオブジェクトを表す。GC ごとに変化する可能性がある
- **ThreadID** - マネージドスレッドを表す

### コールバックの戻り値

プロファイラーは CLR がトリガーする各通知に対して HRESULT でステータスを返します。

### 通知スレッド

ほとんどの場合、通知はイベントを生成したスレッドと同じスレッドで実行されます。コールバックはシリアル化されないため、プロファイラー開発者はスレッドセーフなデータ構造を作成し、必要に応じてロックを行う必要があります。

::: tip 💡 初心者向け補足
プロファイラーを開発する際は、複数のスレッドから同時にコールバックが呼ばれる可能性があることに注意が必要です。例えば、あるスレッドで JIT コンパイルが完了する前に、別のスレッドから関数実行の通知が届くことがあります。
:::

## プロファイリングの主要機能

### JIT コンパイル通知

JIT がメソッドをコンパイルする際に通知を受けることができます。プロファイラーは IL コードストリームを変更して再コンパイルを要求することも可能で、特定のルーチンに動的に計測コードを追加できます。

### 関数の開始/終了フック

`FunctionEnter` と `FunctionLeave` 通知により、各関数の実行時間を計測できます。

### GC 通知

ガベージコレクションの開始・終了、オブジェクトの移動などの通知を受けることができます。

### 例外通知

例外のスロー、キャッチ、finally ブロックの実行などの通知を受けることができます。
