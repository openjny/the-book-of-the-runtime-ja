# プロファイリング

::: info 原文
この章の原文は [Profiling](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/profiling.md) です。
:::

## はじめに

プロファイリングとは、共通言語ランタイム (CLR) 上で実行されるプログラムの実行を監視することを意味します。この章では、ランタイムが提供するプロファイリング情報にアクセスするためのインターフェースについて詳しく説明します。

「プロファイリング API」と呼ばれていますが、この機能は従来のプロファイリングツールだけでなく、コードカバレッジユーティリティや高度なデバッグ支援ツールなど、より広範な診断ツールクラスに適しています。従来のプロファイリングツールは、プログラムの実行を計測すること、つまり各関数に費やされた時間やプログラムの経時的なメモリ使用量に焦点を当てています。しかし、プロファイリング API は実際にはより広範な診断ツールを対象としています。

これらすべての用途に共通しているのは、すべてが診断的な性質を持っているということです。つまり、ツールはプログラムの実行を監視するために書かれます。プロファイリング API はプログラム自身によって使用されるべきではなく、プログラムの実行の正確性はプロファイラーがアクティブであることに依存したり、影響を受けたりしてはなりません。

::: tip 💡 初心者向け補足
プロファイリングとは、プログラムの実行中にパフォーマンスのボトルネック（どの関数に時間がかかっているか、メモリがどのように使われているか）を特定するための技術です。Visual Studio の「診断ツール」や dotnet-trace などのツールが、この API を利用しています。Java では JFR (Java Flight Recorder) や VisualVM が類似の役割を果たします。
:::

CLR プログラムのプロファイリングには、従来のコンパイル済みマシンコードのプロファイリングよりも多くのサポートが必要です。これは、CLR にはアプリケーションドメイン (Application Domain)、ガベージコレクション (Garbage Collection)、マネージド例外処理 (Managed Exception Handling)、JIT コンパイル（中間言語 (Intermediate Language) からネイティブマシンコードへの変換）といった概念があり、既存の従来のプロファイリングメカニズムではこれらを識別して有用な情報を提供できないためです。プロファイリング API は、CLR およびプロファイル対象プログラムのパフォーマンスへの影響を最小限に抑える効率的な方法で、この欠落している情報を提供します。

実行時にルーチンを JIT コンパイルすることは良い機会を提供します。API を使用すると、プロファイラーはルーチンのメモリ内 IL コードストリームを変更し、新たに JIT コンパイルし直すことを要求できます。このようにして、プロファイラーはより深い調査が必要な特定のルーチンに対して、動的にインストルメンテーション (instrumentation) コードを追加できます。このアプローチは従来のシナリオでも可能ですが、CLR ではこれがはるかに容易です。

## プロファイリング API の目標

- CLR 上で実行されるプログラムのパフォーマンスを判断・分析するために、既存のプロファイラーが必要とする情報を公開する。具体的には：
  - 共通言語ランタイムの起動・シャットダウンイベント
  - アプリケーションドメインの作成・シャットダウンイベント
  - アセンブリのロード・アンロードイベント
  - モジュールのロード・アンロードイベント
  - COM VTable の作成・破棄イベント
  - JIT コンパイル・コードピッチング (code pitching) イベント
  - クラスのロード・アンロードイベント
  - スレッドの生成・消滅・同期
  - 関数の開始 (Entry) ・終了 (Exit) イベント
  - 例外
  - マネージド実行とアンマネージド実行間の遷移
  - 異なるランタイム _コンテキスト_ 間の遷移
  - ランタイムサスペンション (suspension) についての情報
  - ランタイムメモリヒープおよびガベージコレクション活動についての情報

- 任意の（非マネージド）COM 互換言語から呼び出し可能であること
- CPU とメモリ消費の面で効率的であること — プロファイリングの行為がプロファイル対象プログラムに大きな変化を与え、結果が誤解を招くようであってはならない
- _サンプリング (sampling)_ プロファイラーと _非サンプリング (non-sampling)_ プロファイラーの両方に有用であること。（_サンプリング_ プロファイラーは、一定のクロックティック — 例えば 5 ミリ秒間隔 — でプロファイル対象を検査する。_非サンプリング_ プロファイラーは、イベントを引き起こしたスレッドと同期的にイベントの通知を受ける。）

::: tip 💡 初心者向け補足
**サンプリングプロファイラー**は一定間隔（例：5ミリ秒ごと）でプログラムの状態を調べます。オーバーヘッドが小さい反面、短時間の処理を見逃す可能性があります。**非サンプリングプロファイラー**はイベント発生時に同期的に通知を受けます。正確ですがオーバーヘッドが大きくなります。
:::

## プロファイリング API の非目標

- プロファイリング API はアンマネージドコードのプロファイリングを**サポートしません**。アンマネージドコードのプロファイリングには既存のメカニズムを使用する必要があります。CLR プロファイリング API はマネージドコードに対してのみ動作します。ただし、プロファイラーはマネージド/アンマネージド遷移イベントを提供して、マネージドコードとアンマネージドコード間の境界を判断できるようにします。
- プロファイリング API は、アスペクト指向プログラミング (Aspect-Oriented Programming) などの目的で自身のコードを変更するアプリケーションの作成を**サポートしません**。
- プロファイリング API は、境界チェック (bounds checking) に必要な情報を**提供しません**。CLR はすべてのマネージドコードに対する境界チェックの組み込みサポートを提供しています。

CLR コードプロファイラーインターフェースは、以下の理由からリモートプロファイリングをサポートしません：

- プロファイリング結果が過度に影響を受けないように、これらのインターフェースを使用する実行時間を最小化する必要があります。これは特に実行パフォーマンスを監視する場合に重要です。ただし、メモリ使用量の監視やスタックフレーム・オブジェクトなどに関するランタイム情報を取得する目的でインターフェースが使用される場合は制約となりません。
- コードプロファイラーは、プロファイル対象アプリケーションが実行されるローカルマシン上のランタイムに、1 つ以上のコールバック (callback) インターフェースを登録する必要があります。これにより、リモートコードプロファイラーの作成能力が制限されます。

## プロファイリング API – 概要

CLR 内のプロファイリング API を使用すると、実行中のアプリケーションの実行状況とメモリ使用量を監視できます。通常、この API はコードプロファイラーパッケージの作成に使用されます。以降のセクションでは、プロファイラーを _あらゆる_ マネージドアプリケーションの実行を監視するために構築されたパッケージとして説明します。

プロファイリング API は、プロファイル対象プログラムと同じプロセスにロードされるプロファイラー DLL によって使用されます。プロファイラー DLL はコールバックインターフェース (`ICorProfilerCallback2`) を実装します。ランタイムはそのインターフェースのメソッドを呼び出して、プロファイル対象プロセス内のイベントをプロファイラーに通知します。プロファイラーは `ICorProfilerInfo` のメソッドを使用してランタイムにコールバックし、プロファイル対象アプリケーションの状態に関する情報を取得できます。

プロファイラーソリューションのデータ収集部分のみがプロファイル対象アプリケーションとインプロセスで実行されるべきであることに注意してください。UI とデータ分析は別のプロセスで行うべきです。

![プロファイリングプロセスの概要](./images/profiling-overview.png)

`ICorProfilerCallback` および `ICorProfilerCallback2` インターフェースは、`ClassLoadStarted`、`ClassLoadFinished`、`JITCompilationStarted` のような名前のメソッドで構成されています。CLR がクラスのロード/アンロード、関数のコンパイルなどを行うたびに、プロファイラーの `ICorProfilerCallback` / `ICorProfilerCallback2` インターフェースの対応するメソッドを呼び出します（他のすべての通知についても同様です。詳細は後述します）。

例えば、プロファイラーは `FunctionEnter` と `FunctionLeave` の 2 つの通知を通じてコードパフォーマンスを測定できます。各通知にタイムスタンプを記録し、結果を蓄積してから、アプリケーションの実行中に最も CPU 時間やウォールクロック時間 (wall-clock time) を消費した関数のリストを出力するだけです。

`ICorProfilerCallback` / `ICorProfilerCallback2` インターフェースは「通知 (notifications) API」と考えることができます。

プロファイリングに関係するもう一つのインターフェースは `ICorProfilerInfo` です。プロファイラーは必要に応じてこれを呼び出し、分析を支援するための追加情報を取得します。例えば、CLR が `FunctionEnter` を呼び出すたびに FunctionId の値を提供します。プロファイラーは `ICorProfilerInfo::GetFunctionInfo` を呼び出すことで、その FunctionId についての詳細情報（関数の親クラス、名前など）を見つけることができます。

::: tip 💡 初心者向け補足
`ICorProfilerCallback` と `ICorProfilerInfo` の関係は、オブザーバーパターン (Observer Pattern) に似ています。`ICorProfilerCallback` はランタイムからプロファイラーへの「プッシュ型」通知で、`ICorProfilerInfo` はプロファイラーからランタイムへの「プル型」問い合わせです。Java の JVMTI (JVM Tool Interface) にも類似の設計があります。
:::

ここまでの説明は、アプリケーションとプロファイラーが実行されているときに何が起こるかを記述しています。しかし、アプリケーションの開始時にこの 2 つはどのように接続されるのでしょうか？ CLR は各プロセスの初期化時に接続を行います。プロファイラーに接続するかどうか、およびどのプロファイラーに接続するかは、以下の 2 つの環境変数の値に基づいて順番にチェックされます：

- **CORECLR_ENABLE_PROFILING** – この環境変数が存在し、非ゼロ値に設定されている場合にのみプロファイラーに接続する。
- **CORECLR_PROFILER** – この CLSID または ProgID のプロファイラーに接続する（事前にレジストリに登録されている必要がある）。CORECLR_PROFILER 環境変数は文字列として定義される：
  - `set CORECLR_PROFILER={32E2F4DA-1BEA-47ea-88F9-C5DAF691C94A}` または
  - `set CORECLR_PROFILER="MyProfiler"`
- プロファイラークラスは `ICorProfilerCallback` / `ICorProfilerCallback2` を実装するクラスです。プロファイラーは `ICorProfilerCallback2` を実装することが必須であり、実装していない場合はロードされません。

上記の両方のチェックが通過すると、CLR は `CoCreateInstance` と同様の方法でプロファイラーのインスタンスを作成します。プロファイラーは `CoCreateInstance` の直接呼び出しを通じてロードされるのではなく、スレッディングモデルの設定を必要とする `CoInitialize` の呼び出しを回避するためです。その後、プロファイラーの `ICorProfilerCallback::Initialize` メソッドを呼び出します。このメソッドのシグネチャは以下のとおりです：

```cpp
HRESULT Initialize(IUnknown *pICorProfilerInfoUnk)
```

プロファイラーは `pICorProfilerInfoUnk` に対して QueryInterface を行い、`ICorProfilerInfo` インターフェースポインタを取得して保存し、後でプロファイリング中に追加情報を呼び出せるようにする必要があります。その後、`ICorProfilerInfo::SetEventMask` を呼び出して、関心のある通知カテゴリを指定します。例えば：

```cpp
ICorProfilerInfo* pInfo;

pICorProfilerInfoUnk->QueryInterface(IID_ICorProfilerInfo, (void**)&pInfo);

pInfo->SetEventMask(COR_PRF_MONITOR_ENTERLEAVE | COR_PRF_MONITOR_GC)
```

このマスクは、関数の Enter/Leave 通知とガベージコレクション通知にのみ関心のあるプロファイラーで使用されます。プロファイラーは単に戻り値を返すだけで、実行が開始されます！

このように通知マスクを設定することで、プロファイラーは受信する通知を制限できます。これは明らかに、よりシンプルな、または特殊な目的のプロファイラーの構築を容易にします。また、プロファイラーが単に「捨てる」だけの通知を送信するための無駄な CPU 時間を削減します（詳細は後述）。

1 つの環境内では、一度に 1 つのプロファイラーのみがプロセスをプロファイリングできることに注意してください。異なる環境では、各環境に 2 つの異なるプロファイラーを登録し、それぞれが別のプロセスをプロファイリングすることが可能です。

特定のプロファイラーイベントは**不変 (IMMUTABLE)** です。つまり、`ICorProfilerCallback::Initialize` コールバックで設定された後は、`ICorProfilerInfo::SetEventMask()` を使用してオフにすることはできません。不変イベントを変更しようとすると、SetEventMask は失敗した HRESULT を返します。

プロファイラーはインプロセス COM サーバー (inproc COM server)、つまりプロファイル対象プロセスと同じアドレス空間にマッピングされる DLL として実装する必要があります。他の種類の COM サーバーはサポートされていません。プロファイラーが例えばリモートコンピューターからアプリケーションを監視したい場合は、各マシンに「コレクタエージェント (collector agent)」を実装し、結果をバッチ処理して中央データ収集マシンに送信する必要があります。

## プロファイリング API – 繰り返し登場する概念

このセクションでは、各メソッドの説明で繰り返し述べる代わりに、プロファイリング API 全体を通じて適用されるいくつかの概念を簡潔に説明します。

### ID

ランタイム通知は、報告されたクラス、スレッド、AppDomain などの ID を提供します。これらの ID はランタイムに対して追加の情報を問い合わせるために使用できます。これらの ID は単にその項目を記述するメモリ内のブロックのアドレスですが、どのプロファイラーでも不透明なハンドル (opaque handle) として扱うべきです。無効な ID がプロファイリング API 関数への呼び出しで使用された場合、結果は未定義です。最も可能性が高いのは、アクセス違反 (access violation) になることです。使用される ID が完全に有効であることを保証する責任はユーザーにあります。プロファイリング API はいかなる種類の検証も実行しません。それはオーバーヘッドを生じさせ、実行速度を著しく低下させるためです。

#### 一意性 (Uniqueness)

ProcessID はプロセスの存続期間中、システム全体で一意です。他のすべての ID はその ID の存続期間中、プロセス全体で一意です。

#### 階層と包含関係 (Hierarchy & Containment)

ID はプロセス内の階層を反映した階層構造に配置されています。プロセスは AppDomain を含み、AppDomain はアセンブリを含み、アセンブリはモジュールを含み、モジュールはクラスを含み、クラスは関数を含みます。スレッドはプロセス内に含まれ、AppDomain 間を移動できます。オブジェクトはほとんどが AppDomain 内に含まれます（ごく少数のオブジェクトは同時に複数の AppDomain のメンバーである場合があります）。コンテキスト (Context) はプロセス内に含まれます。

#### 存続期間と安定性 (Lifetime & Stability)

ある ID が消滅すると、その中に含まれるすべての ID も消滅します。

- **ProcessID** – Initialize の呼び出しから Shutdown の戻り値まで有効かつ安定。
- **AppDomainID** – AppDomainCreationFinished の呼び出しから AppDomainShutdownStarted の戻り値まで有効かつ安定。
- **AssemblyID, ModuleID, ClassID** – その ID に対する LoadFinished の呼び出しから UnloadStarted の戻り値まで有効かつ安定。
- **FunctionID** – JITCompilationFinished または JITCachedFunctionSearchFinished の呼び出しから、含まれる ClassID の消滅まで有効かつ安定。
- **ThreadID** – ThreadCreated の呼び出しから ThreadDestroyed の戻り値まで有効かつ安定。
- **ObjectID** – ObjectAllocated の呼び出し以降有効。各ガベージコレクションで変化または消滅する可能性がある。
- **GCHandleID** – HandleCreated の呼び出しから HandleDestroyed の戻り値まで有効。

加えて、プロファイリング API 関数から返された任意の ID は、返された時点で有効です。

#### AppDomain アフィニティ (App-Domain Affinity)

プロセス内の各ユーザー作成 AppDomain に対して AppDomainID があり、さらに「デフォルト」ドメインと、ドメインニュートラル (domain-neutral) なアセンブリを保持するための特別な擬似ドメインがあります。

Assembly、Module、Class、Function、および GCHandleID は AppDomain アフィニティを持ちます。つまり、アセンブリが複数の AppDomain にロードされた場合、そのアセンブリ（およびその中に含まれるすべてのモジュール、クラス、関数）はそれぞれ異なる ID を持ち、各 ID に対する操作は関連付けられた AppDomain 内でのみ有効です。ドメインニュートラルなアセンブリは、上記で述べた特別な擬似ドメインに表示されます。

#### 特記事項 (Special Notes)

ObjectID を除くすべての ID は不透明な値として扱うべきです。ほとんどの ID はかなり自明ですが、いくつかはより詳しく説明する価値があります。

**ClassID** はクラスを表します。ジェネリッククラスの場合、完全にインスタンス化された型を表します。`List<int>`、`List<char>`、`List<object>`、`List<string>` はそれぞれ固有の ClassID を持ちます。`List<T>` はインスタンス化されていない型であり、ClassID を持ちません。`Dictionary<string,V>` は部分的にインスタンス化された型であり、ClassID を持ちません。

**FunctionID** は関数のネイティブコードを表します。ジェネリック関数（またはジェネリッククラスの関数）の場合、特定の関数に対して複数のネイティブコードのインスタンス化 (instantiation) が存在する可能性があり、したがって複数の FunctionID が存在する可能性があります。ネイティブコードのインスタンス化は異なる型間で共有される場合があります。例えば、`List<string>` と `List<object>` はすべてのコードを共有するため、FunctionID は複数の ClassID に「属する」場合があります。

**ObjectID** はガベージコレクション対象オブジェクトを表します。ObjectID は、プロファイラーが ObjectID を受信した時点でのオブジェクトの現在のアドレスであり、各ガベージコレクションで変化する可能性があります。したがって、ObjectID の値は受信した時点から次のガベージコレクションが開始されるまでの間のみ有効です。CLR はプロファイラーがオブジェクトを追跡する内部マップを更新できる通知も提供するため、プロファイラーはガベージコレクション間で有効な ObjectID を維持できます。

**GCHandleID** は GC のハンドルテーブル (handle table) 内のエントリを表します。GCHandleID は ObjectID とは異なり、不透明な値です。GC ハンドルは一部の状況ではランタイム自体によって作成されるか、ユーザーコードで `System.Runtime.InteropServices.GCHandle` 構造体を使用して作成できます（GCHandle 構造体はハンドルを表すだけであり、ハンドルは GCHandle 構造体内に「存在」するわけではないことに注意してください）。

**ThreadID** はマネージドスレッドを表します。ホストがファイバーモード (fiber mode) での実行をサポートしている場合、マネージドスレッドは検査する時点に応じて異なる OS スレッド上に存在する可能性があります（**注:** ファイバーモードアプリケーションのプロファイリングはサポートされていません）。

### コールバックの戻り値 (Callback Return Values)

プロファイラーは、CLR がトリガーする各通知に対して HRESULT でステータスを返します。そのステータスは `S_OK` または `E_FAIL` の値を持つことができます。現在、ランタイムは `ObjectReferences` を除くすべてのコールバックでこのステータス値を無視します。

### 呼び出し元確保バッファ (Caller-Allocated Buffers)

呼び出し元確保バッファを取る `ICorProfilerInfo` 関数は、通常以下のシグネチャに準拠します：

```
HRESULT GetBuffer( [in] /* Some query information */,
   [in] ULONG32 cBuffer,
   [out] ULONG32 *pcBuffer,
   [out, size_is(cBuffer), length_is(*pcMap)] /* TYPE */ buffer[] );
```

これらの関数は常に以下のように動作します：

- `cBuffer` はバッファに割り当てられた要素数です。
- `*pcBuffer` は利用可能な要素の総数に設定されます。
- `buffer` は可能な限り多くの要素で埋められます。

要素が返された場合、戻り値は `S_OK` になります。バッファが十分な大きさであったかどうかを確認するのは呼び出し元の責任です。

`buffer` が NULL の場合、`cBuffer` は 0 でなければなりません。関数は `S_OK` を返し、`*pcBuffer` を利用可能な要素の総数に設定します。

### オプションの出力パラメータ (Optional Out Parameters)

関数が 1 つの `[out]` パラメータしか持たない場合を除き、API のすべての `[out]` パラメータはオプションです。プロファイラーは関心のない `[out]` パラメータに対して単に NULL を渡します。プロファイラーは関連する `[in]` パラメータにも一貫した値を渡す必要があります。例えば、NULL の `[out]` パラメータがデータで埋められるバッファの場合、そのサイズを指定する `[in]` パラメータは 0 でなければなりません。

### 通知スレッド (Notification Thread)

ほとんどの場合、通知はイベントを生成したスレッドと同じスレッドで実行されます。そのような通知（例えば `FunctionEnter` や `FunctionLeave`）は明示的な ThreadID を提供する必要がありません。また、プロファイラーは、影響を受けるスレッドの ThreadID に基づくグローバルストレージへのインデックス付けと比較して、スレッドローカルストレージ (Thread-Local Storage, TLS) を使用して分析ブロックの保存と更新を行うことを選択できます。

各通知は、どのスレッドが呼び出しを行うかを文書化しています。イベントを生成したスレッドか、ランタイム内の何らかのユーティリティスレッド（例：ガベージコレクタ）のいずれかです。異なるスレッドによって呼び出される可能性があるコールバックについては、ユーザーは `ICorProfilerInfo::GetCurrentThreadID` を呼び出して、イベントを生成したスレッドを特定できます。

これらのコールバックはシリアル化されないことに注意してください。プロファイラー開発者は、スレッドセーフなデータ構造を作成し、複数のスレッドからの並行アクセスを防ぐために必要に応じてプロファイラーコードをロックすることで、防御的なコードを書く必要があります。したがって、特定のケースでは異常なコールバックシーケンスを受信する可能性があります。例えば、マネージドアプリケーションが同一のコードを実行する 2 つのスレッドを生成しているとします。この場合、あるスレッドからある関数の `JITCompilationStarted` イベントを受信し、対応する `JITCompilationFinished` コールバックを受信する前に、もう一方のスレッドがすでに `FunctionEnter` コールバックを送信している可能性があります。したがって、まだ完全に JIT コンパイルされていないように見える関数の `FunctionEnter` コールバックを受信することになります！

::: tip 💡 初心者向け補足
プロファイラーを開発する際は、複数のスレッドから同時にコールバックが呼ばれる可能性があることに注意が必要です。例えば、あるスレッドで JIT コンパイルが完了する前に、別のスレッドから関数実行の通知が届くことがあります。これはバグではなく、マルチスレッド環境での正常な動作です。
:::

### GC セーフコールアウト (GC-Safe Callouts)

CLR が `ICorProfilerCallback` の特定の関数を呼び出すとき、プロファイラーがその呼び出しから制御を返すまで、ランタイムはガベージコレクションを実行できません。これは、プロファイリングサービスがガベージコレクションに安全な状態にスタックを構築できない場合があるためです。代わりに、そのコールバックの周囲でガベージコレクションが無効化されます。これらのケースでは、プロファイラーはできるだけ早く制御を返すように注意する必要があります。これが適用されるコールバックは以下のとおりです：

- FunctionEnter, FunctionLeave, FunctionTailCall
- ExceptionOSHandlerEnter, ExceptionOSHandlerLeave
- ExceptionUnwindFunctionEnter, ExceptionUnwindFunctionLeave
- ExceptionUnwindFinallyEnter, ExceptionUnwindFinallyLeave
- ExceptionCatcherEnter, ExceptionCatcherLeave
- ExceptionCLRCatcherFound, ExceptionCLRCatcherExecute
- COMClassicVTableCreated, COMClassicVTableDestroyed

さらに、以下のコールバックはプロファイラーのブロックを許可する場合とそうでない場合があります。これは `fIsSafeToBlock` 引数を通じて呼び出しごとに示されます。このセットには以下が含まれます：

- JITCompilationStarted, JITCompilationFinished

プロファイラーがブロック _する_ 場合、ガベージコレクションが遅延されることに注意してください。これは、プロファイラーコード自体がマネージドヒープにスペースを割り当てようとしない限り無害です。マネージドヒープへの割り当てはデッドロック (deadlock) を引き起こす可能性があります。

::: tip 💡 初心者向け補足
GC セーフコールアウトは、プロファイラーがランタイムのガベージコレクションとデッドロックしないための設計上の制約です。プロファイラーのコールバック内でマネージドヒープにメモリを割り当てようとすると、GC が必要 → しかし GC はコールバック完了まで待機 → デッドロック、という状況に陥る可能性があります。
:::

### COM の使用 (Using COM)

プロファイリング API インターフェースは COM インターフェースとして定義されていますが、ランタイムは実際にはそれらを使用するために COM を初期化しません。これは、マネージドアプリケーションが望ましいスレッディングモデルを指定する機会を得る前に、`CoInitialize` を介してスレッディングモデルを設定する必要を避けるためです。同様に、プロファイラー自体も `CoInitialize` を呼び出すべきではありません。プロファイル対象アプリケーションと互換性のないスレッディングモデルを選択し、アプリケーションを壊す可能性があるためです。

### コールバックとスタック深度 (Callbacks and Stack Depth)

プロファイラーコールバックは、スタックが極めて制約された状況で発行される場合があり、プロファイラーコールバック内でのスタックオーバーフロー (stack overflow) は即座のプロセス終了につながります。プロファイラーはコールバックへのレスポンスで可能な限り少ないスタックを使用するよう注意すべきです。プロファイラーがスタックオーバーフローに対して堅牢なプロセスに対して使用されることを想定している場合、プロファイラー自体もスタックオーバーフローのトリガーを避けるべきです。

### NT サービスのプロファイリング方法 (How to profile a NT Service)

プロファイリングは環境変数を通じて有効化され、NT サービスはオペレーティングシステムのブート時に起動されるため、これらの環境変数はその時点で存在し、必要な値に設定されている必要があります。したがって、NT サービスのプロファイリングを行うには、適切な環境変数を事前にシステム全体で設定する必要があります：

マイコンピュータ → プロパティ → 詳細設定 → 環境変数 → システム環境変数

**CORECLR_ENABLE_PROFILING** と **CORECLR_PROFILER の両方を設定する必要があり**、プロファイラー DLL が登録されていることをユーザーが確認する必要があります。その後、NT サービスがこれらの変更を取得するために、ターゲットマシンを再起動する必要があります。これによりシステム全体でのプロファイリングが有効になることに注意してください。そのため、以降に実行されるすべてのマネージドアプリケーションがプロファイルされることを防ぐために、再起動後にそれらのシステム環境変数を削除する必要があります。

## プロファイリング API – 高レベルの説明

### ローダーコールバック (Loader Callbacks)

ローダーコールバックは、AppDomain、アセンブリ、モジュール、およびクラスのロードに対して発行されるコールバックです。

CLR がアセンブリのロードを通知し、その後にそのアセンブリに対する 1 つ以上のモジュールのロードが続くと期待するかもしれません。しかし、実際に何が起こるかはローダーの実装内のいくつかの要因に依存します。プロファイラーが依存できるのは以下の点です：

- 同じ ID に対して、Started コールバックは Finished コールバックよりも先に配信される。
- Started と Finished コールバックは同じスレッド上で配信される。

ローダーコールバックは Started/Finished ペアで構成されていますが、ローダー内部の操作に正確に時間を帰属させるために使用することはできません。

### コールスタック (Call stacks)

プロファイリング API は、コールスタック (call stack) を取得するための 2 つの方法を提供します。コールスタックをまばらに収集するのに適したスナップショットメソッド (snapshot method) と、あらゆる瞬間にコールスタックを追跡するのに適したシャドウスタックメソッド (shadow-stack method) です。

#### スタックスナップショット (Stack Snapshot)

スタックスナップショットは、ある瞬間におけるスレッドのスタックのトレースです。プロファイリング API はスタック上のマネージド関数のトレースをサポートしていますが、アンマネージド関数のトレースはプロファイラー自身のスタックウォーカー (stack walker) に委ねています。

#### シャドウスタック (Shadow Stack)

上記のスナップショットメソッドを頻繁に使用すると、すぐにパフォーマンスの問題になる可能性があります。スタックトレースを頻繁に取得する必要がある場合、プロファイラーは代わりに `FunctionEnter`、`FunctionLeave`、`FunctionTailCall`、および `Exception*` コールバックを使用して「シャドウスタック (shadow stack)」を構築すべきです。シャドウスタックは常に最新であり、スタックスナップショットが必要な時にすぐにストレージにコピーできます。

シャドウスタックは、関数の引数、戻り値、およびジェネリックインスタンス化 (generic instantiation) に関する情報を取得できます。この情報はシャドウスタックを通じてのみ利用可能です。なぜなら、関数のエントリ時には容易に利用できますが、関数の実行の後半では最適化によって除去されている可能性があるためです。

::: tip 💡 初心者向け補足
シャドウスタックは、プロファイラーが独自に管理する仮想的なコールスタックです。関数の Enter/Leave イベントごとにスタックを自前で管理することで、いつでも現在のコールスタックを高速に参照できます。毎回スレッドのスタックを走査する（スナップショットメソッド）よりもはるかに効率的です。
:::

### ガベージコレクション (Garbage Collection)

プロファイラーが `COR_PRF_MONITOR_GC` フラグを指定すると、`ICorProfilerCallback::ObjectAllocated` イベントを除くすべての GC イベントがプロファイラーでトリガーされます。ObjectAllocated イベントは、パフォーマンス上の理由から別のフラグによって明示的に制御されます。`COR_PRF_MONITOR_GC` が有効になると、コンカレント (Concurrent) ガベージコレクションがオフになることに注意してください。

プロファイラーは `GarbageCollectionStarted` / `Finished` コールバックを使用して、GC が実行中であること、およびどの世代 (generation) が対象であるかを識別できます。

#### 移動されたオブジェクトの追跡 (Tracking Moved Objects)

ガベージコレクションは「デッド」オブジェクトが占有するメモリを回収し、その解放されたスペースをコンパクション (compaction) します。その結果、生存オブジェクトはヒープ内で移動されます。この影響により、以前の通知で渡された _ObjectID_ の値が変更されます（オブジェクト自体の内部状態は変更されません（他のオブジェクトへの参照は除く）。変更されるのはメモリ上の位置、したがって _ObjectID_ だけです）。`MovedReferences` 通知により、プロファイラーは _ObjectID_ で情報を追跡する内部テーブルを更新できます。この名前はやや誤解を招きます。移動されなかったオブジェクトに対しても発行されるためです。

ヒープ内のオブジェクト数は数千から数百万に上る可能性があります。このような大量のオブジェクトに対して、各オブジェクトの前後の ID を提供することで移動を通知するのは現実的ではありません。しかし、ガベージコレクタは連続する生存オブジェクトの塊を「ひとまとめ」に移動する傾向があります。つまり、それらはヒープ内の新しい位置に移動しますが、依然として連続しています。この通知は、これらの連続するオブジェクトの塊の「前 (before)」と「後 (after)」の _ObjectID_ を報告します（以下の例を参照）。

言い換えると、_ObjectID_ の値が以下の範囲内にある場合：

_oldObjectIDRangeStart[i] <= ObjectID < oldObjectIDRangeStart[i] + cObjectIDRangeLength[i]_

ここで _0 <= i < cMovedObjectIDRanges_ のとき、_ObjectID_ の値は以下に変更されています：

_ObjectID - oldObjectIDRangeStart[i] + newObjectIDRangeStart[i]_

これらのコールバックはすべてランタイムがサスペンド (suspend) されている間に行われるため、ランタイムが再開して別の GC が発生するまで、_ObjectID_ の値は変更されません。

**例:** 以下の図は、ガベージコレクション前の 10 個のオブジェクトを示しています。これらは開始アドレス（_ObjectID_ に相当）08、09、10、12、13、15、16、17、18、19 に位置しています。_ObjectID_ 09、13、19 はデッド（シェーディングで表示）であり、ガベージコレクション中にそのスペースが回収されます。

![ガベージコレクション](./images/profiling-gc.png)

「後」の図は、デッドオブジェクトが占めていたスペースがどのように回収されて生存オブジェクトが保持されるかを示しています。生存オブジェクトはヒープ内の新しい位置に移動されました。その結果、それらの _ObjectID_ はすべて変更されます。これらの変更を記述する最も単純な方法は、前後の _ObjectID_ のテーブルです：

|     | oldObjectIDRangeStart[] | newObjectIDRangeStart[] |
| :-: | :---------------------: | :---------------------: |
|  0  |           08            |           07            |
|  1  |           09            |                         |
|  2  |           10            |           08            |
|  3  |           12            |           10            |
|  3  |           13            |                         |
|  4  |           15            |           11            |
|  5  |           16            |           12            |
|  6  |           17            |           13            |
|  7  |           18            |           14            |
|  8  |           19            |                         |

これは機能しますが、明らかに、連続する塊の開始位置とサイズを指定することで情報をコンパクトにできます：

|     | oldObjectIDRangeStart[] | newObjectIDRangeStart[] | cObjectIDRangeLength[] |
| :-: | :---------------------: | :---------------------: | :--------------------: |
|  0  |           08            |           07            |           1            |
|  1  |           10            |           08            |           3            |
|  2  |           15            |           11            |           4            |

これはまさに `MovedReferences` が情報を報告する方法に対応しています。`MovedReferencesCallback` は、オブジェクトが実際にヒープ内で再配置される前に、オブジェクトの新しいレイアウトを報告していることに注意してください。したがって、古い _ObjectID_ は `ICorProfilerInfo` インターフェースへの呼び出しにおいてまだ有効です（新しい _ObjectID_ は有効ではありません）。

#### すべての削除されたオブジェクトの検出 (Detecting All Deleted Objects)

`MovedReferences` は、オブジェクトが移動したかどうかに関わらず、コンパクション GC を生き残ったすべてのオブジェクトを報告します。報告されなかったものは生き残っていません。ただし、すべての GC がコンパクションを行うわけではありません。

プロファイラーは `ICorProfilerInfo2::GetGenerationBounds` を呼び出して、GC ヒープセグメントの境界を取得できます。得られた `COR_PRF_GC_GENERATION_RANGE` 構造体の `rangeLength` フィールドを使用して、コンパクションされた世代における生存オブジェクトの範囲を特定できます。

`GarbageCollectionStarted` コールバックは、現在の GC でどの世代が収集されているかを示します。収集されていない世代にあるすべてのオブジェクトは GC を生き残ります。

非コンパクション GC（オブジェクトがまったく移動しない GC）の場合、どのオブジェクトが GC を生き残ったかを示すために `SurvivingReferences` コールバックが配信されます。

単一の GC が、ある世代に対してはコンパクションを行い、別の世代に対しては非コンパクションである場合があることに注意してください。特定の世代は、特定の GC に対して `SurvivingReferences` コールバックか `MovedReferences` コールバックのいずれかを受信しますが、両方を受信することはありません。

#### 備考 (Remarks)

アプリケーションは、ランタイムがヒープに関する情報をコードプロファイラーに渡し終わるまで、ガベージコレクションの後に一時停止されます。メソッド `ICorProfilerInfo::GetClassFromObject` を使用して、オブジェクトがインスタンスであるクラスの _ClassID_ を取得できます。メソッド `ICorProfilerInfo::GetTokenFromClass` を使用して、クラスに関するメタデータ情報を取得できます。

`RootReferences2` により、プロファイラーは特殊なハンドルを介して保持されているオブジェクトを識別できます。`GetGenerationBounds` によって提供される世代境界情報と `GarbageCollectionStarted` によって提供される収集対象世代情報を組み合わせることで、プロファイラーは収集されなかった世代に存在するオブジェクトを識別できます。

### オブジェクトインスペクション (Object Inspection)

`FunctionEnter2` / `Leave2` コールバックは、メモリの領域として関数の引数と戻り値に関する情報を提供します。引数は指定されたメモリ領域内に左から右に格納されます。プロファイラーは関数のメタデータシグネチャを使用して引数を解釈できます。以下のように解釈されます：

| **ELEMENT_TYPE**                                            | **表現方法**                                                                             |
| ----------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| プリミティブ (ELEMENT_TYPE <= R8, I, U)                     | プリミティブ値                                                                           |
| 値型 (VALUETYPE)                                            | 型に依存                                                                                 |
| 参照型 (CLASS, STRING, OBJECT, ARRAY, GENERICINST, SZARRAY) | ObjectID (GC ヒープへのポインタ)                                                         |
| BYREF                                                       | マネージドポインタ (ObjectID ではないが、スタックまたは GC ヒープを指している場合がある) |
| PTR                                                         | アンマネージドポインタ (GC による移動不可)                                               |
| FNPTR                                                       | ポインタサイズの不透明な値                                                               |
| TYPEDBYREF                                                  | マネージドポインタの後にポインタサイズの不透明な値                                       |

ObjectID とマネージドポインタ (managed pointer) の違いは以下のとおりです：

- ObjectID は GC ヒープまたはフローズンオブジェクトヒープ (frozen object heap) のみを指す。マネージドポインタはスタックも指す可能性がある。
- ObjectID は常にオブジェクトの先頭を指す。マネージドポインタはオブジェクトのフィールドの 1 つを指す場合がある。
- マネージドポインタは ObjectID を期待する関数に渡すことができない。

#### 複合型のインスペクション (Inspecting Complex Types)

参照型または非プリミティブ値型のインスペクションには、いくつかの高度なテクニックが必要です。

値型および文字列・配列以外の参照型の場合、`GetClassLayout` が各フィールドのオフセットを提供します。プロファイラーはメタデータを使用してフィールドの型を判断し、再帰的に評価できます（`GetClassLayout` はクラス自身で定義されたフィールドのみを返すことに注意してください。親クラスで定義されたフィールドは含まれません）。

ボックス化 (boxing) された値型の場合、`GetBoxClassLayout` がボックス内の値型のオフセットを提供します。値型自体のレイアウトは変更されないため、プロファイラーがボックス内の値型を見つけたら、`GetClassLayout` を使用してそのレイアウトを理解できます。

文字列の場合、`GetStringClassLayout` が文字列オブジェクト内の重要なデータのオフセットを提供します。

配列はやや特殊であり、型ごとではなくすべての配列オブジェクトに対して関数を呼び出す必要があります（これは、オフセットで記述するには配列のフォーマットが多すぎるためです）。`GetArrayObjectInfo` がこの解釈を行うために提供されています。

#### 静的フィールドのインスペクション (Inspecting Static Fields)

`GetThreadStaticAddress`、`GetAppDomainStaticAddress`、`GetContextStaticAddress`、および `GetRVAStaticAddress` は、静的フィールドの場所に関する情報を提供します。その場所のメモリを見て、以下のように解釈します：

- 参照型：ObjectID
- 値型：実際の値を含むボックスの ObjectID
- プリミティブ型：プリミティブ値

静的フィールドには 4 つの種類があります。以下のテーブルでは、それらの内容と識別方法を説明します。

| **静的型** | **定義**                                                                       | **メタデータでの識別方法**                         |
| ---------- | ------------------------------------------------------------------------------ | -------------------------------------------------- |
| AppDomain  | 基本的な静的フィールド — 各 AppDomain で異なる値を持つ。                       | カスタム属性が付与されていない静的フィールド       |
| Thread     | マネージド TLS — 各スレッドおよび各 AppDomain で一意の値を持つ静的フィールド。 | System.ThreadStaticAttribute を持つ静的フィールド  |
| RVA        | モジュールのデータセクションにホームを持つプロセススコープの静的フィールド。   | hasRVA フラグを持つ静的フィールド                  |
| Context    | 各 COM+ コンテキスト (Context) で異なる値を持つ静的フィールド。                | System.ContextStaticAttribute を持つ静的フィールド |

### 例外 (Exceptions)

例外の通知は、すべての通知の中で記述および理解が最も困難です。これは、例外処理 (exception handling) に固有の複雑性のためです。以下で説明される例外通知のセットは、洗練されたプロファイラーが必要とするすべての情報を提供するように設計されています。これにより、プロファイル対象プロセスのすべてのスレッドについて、あらゆる瞬間に、どのパス（第 1 パスまたは第 2 パス）、どのフレーム、どのフィルター (filter)、どの finally ブロックが実行されているかを常に追跡できます。例外通知は _ThreadID_ を提供しませんが、プロファイラーは常に `ICorProfilerInfo::GetCurrentThreadID` を呼び出して、どのマネージドスレッドが例外をスローしているかを特定できます。

![例外コールバックシーケンス](./images/profiling-exception-callback-sequence.png)

上の図は、例外イベントを監視する際にコードプロファイラーがさまざまなコールバックをどのように受信するかを示しています。各スレッドは「通常の実行 (Normal Execution)」から始まります。スレッドが大きな灰色のボックス内の状態にあるとき、例外システム (exception system) がスレッドを制御しています。スレッドがこれらの状態のいずれかにある間に発生する例外に関連しないコールバック（例：`ObjectAllocated`）は、例外システム自体に帰属させることができます。スレッドが大きな灰色のボックスの外側の状態にあるときは、任意のマネージドコードを実行しています。

#### ネストされた例外 (Nested Exceptions)

例外処理の途中でマネージドコードに遷移したスレッドは、別の例外をスローする可能性があります。これにより、完全に新しい例外処理パスが開始されます（上図の「New EH Pass」ボックス）。そのような「ネストされた」例外が元の例外のフィルター/finally/catch をエスケープすると、元の例外に影響を与えることがあります：

- ネストされた例外がフィルター内で発生し、フィルターをエスケープした場合、フィルターは「false」を返したとみなされ、第 1 パスが継続します。
- ネストされた例外が finally 内で発生し、finally をエスケープした場合、元の例外の処理は再開されません。
- ネストされた例外が catch 内で発生し、catch をエスケープした場合、元の例外の処理は再開されません。

#### アンマネージドハンドラー (Unmanaged Handlers)

例外がアンマネージドコードで処理される場合があります。この場合、プロファイラーはアンワインドフェーズ (unwind phase) を見ますが、catch ハンドラーの通知は受信しません。実行はアンマネージドコード内で正常に再開されます。アンマネージドを認識するプロファイラーはこれを検出できますが、マネージドのみのプロファイラーは以下を含む（これらに限定されない）さまざまなことを検出する可能性があります：

- アンマネージドコードがマネージドコードを呼び出すか、マネージドコードに戻るときの `UnmanagedToManagedTransition` コールバック。
- スレッドの終了（アンマネージドコードがスレッドのルートにあった場合）。
- アプリケーションの終了（アンマネージドコードがアプリを終了させた場合）。

#### CLR ハンドラー (CLR Handlers)

CLR 自体が例外を処理する場合があります。この場合、プロファイラーはアンワインドフェーズを見ますが、catch ハンドラーの通知は受信しません。マネージドコードまたはアンマネージドコード内で正常に実行が再開される場合があります。

#### 未処理の例外 (Unhandled Exceptions)

デフォルトでは、未処理の例外 (unhandled exception) はプロセスの終了につながります。アプリケーションがレガシー例外ポリシー (legacy exception policy) にロックバックしている場合、特定の種類のスレッドでの未処理の例外はスレッドの終了のみにつながる場合があります。

### コード生成 (Code Generation)

#### IL からネイティブコードへ (Getting from IL to Native Code)

.NET アセンブリの IL は、2 つの方法のいずれかでネイティブコードにコンパイルされます。実行時に JIT コンパイルされるか、NGEN.exe（CoreCLR では CrossGen.exe）というツールによって「ネイティブイメージ (native image)」にコンパイルされます。JIT コンパイラと NGEN の両方に、コード生成を制御する多くのフラグがあります。

アセンブリがロードされる時点で、CLR はまずそのアセンブリのネイティブイメージを探します。適切なコード生成フラグのセットを持つネイティブイメージが見つからない場合、CLR は実行中に必要に応じてアセンブリ内の関数を JIT コンパイルします。ネイティブイメージが見つかってロードされた場合でも、CLR はアセンブリ内の一部の関数を JIT コンパイルすることがあります。

::: tip 💡 初心者向け補足
ネイティブイメージ (Native Image) は、事前にコンパイルされたネイティブコードを含む DLL です。JIT コンパイルのオーバーヘッドを削減し、アプリケーションの起動時間を短縮します。Java の AOT (Ahead-of-Time) コンパイルの概念に似ています。.NET ではかつて NGEN が使用されていましたが、現在は ReadyToRun (R2R) 形式が主流です。
:::

#### コード生成に対するプロファイラーの制御 (Profiler Control over Code-Generation)

プロファイラーは、以下のようにコード生成を制御できます：

| **フラグ**                       | **効果**                                                                                                                                       |
| -------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| COR_PRF_USE_PROFILE_IMAGES       | ネイティブイメージ検索をプロファイラー拡張イメージ (ngen /profile) に向ける。JIT コードには効果なし。                                          |
| COR_PRF_DISABLE_INLINING         | ネイティブイメージ検索には効果なし。JIT 時にインライン化 (inlining) を無効にする。他のすべての最適化は有効なまま。                             |
| COR_PRF_DISABLE_OPTIMIZATIONS    | ネイティブイメージ検索には効果なし。JIT 時にインライン化を含むすべての最適化を無効にする。                                                     |
| COR_PRF_MONITOR_ENTERLEAVE       | ネイティブイメージ検索をプロファイラー拡張イメージ (ngen /profile) に向ける。JIT 時に生成コードに Enter/Leave フックを挿入する。               |
| COR_PRF_MONITOR_CODE_TRANSITIONS | ネイティブイメージ検索をプロファイラー拡張イメージ (ngen /profile) に向ける。JIT 時にマネージド/アンマネージド遷移ポイントにフックを挿入する。 |

#### プロファイラーとネイティブイメージ (Profilers and Native Images)

NGEN.exe がネイティブイメージを作成するとき、CLR が実行時に行うはずだった作業の多く（例えば、クラスのロードやメソッドのコンパイル）を行います。その結果、NGEN 時に作業が行われた場合、実行時に特定のプロファイラーコールバックが受信されないことがあります：

- JITCompilation\*
- ClassLoad\*, ClassUnload\*

この状況に対処するために、プロファイラー拡張ネイティブイメージを要求してプロセスに干渉することを望まないプロファイラーは、FunctionID や ClassID が出現するたびに、必要なデータを遅延的 (lazily) に収集する準備をしておくべきです。

#### プロファイラー拡張ネイティブイメージ (Profiler-Enhanced Native Images)

NGEN /profile でネイティブイメージを作成すると、イメージのプロファイリングを容易にする一連のコード生成フラグが有効になります：

- Enter/Leave フックがコードに挿入される。
- マネージド/アンマネージド遷移フックがコードに挿入される。
- ネイティブイメージ内の各関数が初めて呼び出された時に `JITCachedFunctionSearch` 通知が提供される。
- ネイティブイメージ内の各クラスが初めて使用された時に `ClassLoad` 通知が提供される。

プロファイラー拡張ネイティブイメージは通常のネイティブイメージとは大きく異なるため、プロファイラーは追加の干渉 (perturbation) が許容できる場合にのみ使用すべきです。

## プロファイリングにおけるセキュリティの問題 (Security Issues in Profiling)

プロファイラー DLL は、実質的に CLR の実行エンジン (execution engine) 自体の一部として動作するアンマネージド DLL です。その結果、プロファイラー DLL のコードはマネージドコードアクセスセキュリティ (Code Access Security, CAS) の制約を受けず、プロファイル対象アプリケーションを実行しているユーザーに対して OS が課す制限のみが適用されます。

## マネージドコードとアンマネージドコードのプロファイラー内での組み合わせ (Combining Managed and Unmanaged Code in a Code Profiler)

CLR プロファイリング API を詳しく検討すると、マネージドコンポーネントとアンマネージドコンポーネントを持ち、COM Interop や PInvoke 呼び出しを通じて相互に呼び出すプロファイラーを書けるという印象を受けるかもしれません。

これは設計上は可能ですが、CLR プロファイリング API はこれをサポートしていません。CLR プロファイラーは純粋にアンマネージドであることが想定されています。CLR プロファイラーからマネージドコードとアンマネージドコードを組み合わせようとすると、クラッシュ、ハング (hang)、デッドロック (deadlock) を引き起こす可能性があります。マネージド部分のプロファイラーがアンマネージドコンポーネントにイベントを「発火 (fire)」し、それが続いてプロファイラーのマネージド部分に呼び出すことになるため、危険は明白です。

CLR プロファイラーがマネージドコードを安全に呼び出せる唯一の方法は、メソッドの MSIL 本体を置き換えることです。プロファイラーは関数の JIT コンパイルが完了する前に、メソッドの MSIL 本体にマネージド呼び出しを挿入し、JIT にコンパイルさせます。この手法は、マネージドコードの選択的なインストルメンテーション (selective instrumentation) に使用でき、JIT に関する統計やタイミングの収集にも使用できます。

あるいは、コードプロファイラーは、すべてのマネージド関数の MSIL 本体にネイティブ「フック (hook)」を挿入し、アンマネージドコードに呼び出すこともできます。この手法はインストルメンテーションとカバレッジ (coverage) に使用できます。例えば、コードプロファイラーは、ブロックが実行されたことを保証するために、すべての MSIL ブロックの後にインストルメンテーションフックを挿入できます。メソッドの MSIL 本体の変更は非常に繊細な操作であり、考慮すべき多くの要因があります。

::: tip 💡 初心者向け補足
プロファイラーを純粋にアンマネージドコード（C/C++ など）で書くべき理由は、マネージドコードを含めると循環的な依存関係が発生するためです。例えば、プロファイラーのマネージドコードが GC イベントを発生させ、そのイベントがプロファイラーのコールバックを呼び出し...というループが発生してデッドロックに至ります。MSIL の書き換えによるインストルメンテーションは、Java のバイトコードインストルメンテーション (`java.lang.instrument`) と概念的に似ています。
:::

## アンマネージドコードのプロファイリング (Profiling Unmanaged Code)

ランタイムプロファイリングインターフェースには、アンマネージドコードのプロファイリングのための最小限のサポートがあります。以下の機能が提供されています：

- スタックチェーン (stack chain) の列挙。これにより、コードプロファイラーはマネージドコードとアンマネージドコードの境界を判断できます。
- スタックチェーンがマネージドコードに対応するかネイティブコードに対応するかの判定。

これらのメソッドは、CLR デバッグ API のインプロセスサブセット (in-process subset) を通じて利用できます。これらは CorDebug.IDL で定義され、DebugRef.doc で説明されています。詳細については両方を参照してください。

## サンプリングプロファイラー (Sampling Profilers)

### ハイジャック (Hijacking)

一部のサンプリングプロファイラーは、サンプル時にスレッドをハイジャック (hijack) して、サンプルの作業を強制的に行わせることで動作します。これは非常にトリッキーな実践であり、推奨しません。このセクションの残りの部分は、主にこの方法を取ることを思いとどまらせるためのものです。

#### ハイジャックのタイミング (Timing of Hijacks)

ハイジャックを行うプロファイラーは、ランタイムのサスペンションイベント (`COR_PRF_MONITOR_SUSPENDS`) を追跡する必要があります。プロファイラーは、`RuntimeThreadSuspended` コールバックから戻ると、ランタイムがそのスレッドをハイジャックすると仮定すべきです。プロファイラーは、自身のハイジャックがランタイムのハイジャックと競合しないようにする必要があります。そのために、プロファイラーは以下を保証する必要があります：

1. プロファイラーは `RuntimeThreadSuspended` と `RuntimeThreadResumed` の間でスレッドのハイジャックを試みない。
2. プロファイラーが `RuntimeThreadSuspended` コールバックが発行される前にハイジャックを開始していた場合、ハイジャックが完了するまでコールバックから戻らない。

これは簡単な同期 (synchronization) で実現できます。

#### ランタイムの初期化 (Initializing the Runtime)

プロファイラーが `ICorProfilerInfo` 関数を呼び出す独自のスレッドを持っている場合、スレッドのサスペンションを行う前に、そのような関数を 1 回呼び出しておく必要があります。これは、ランタイムにはスレッドごとの状態 (per-thread state) があり、デッドロックの可能性を避けるために、他のすべてのスレッドが実行中の状態で初期化する必要があるためです。
