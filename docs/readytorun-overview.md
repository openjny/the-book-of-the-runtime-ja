# ReadyToRun 概要

::: info 原文
この章の原文は [ReadyToRun Overview](https://github.com/dotnet/runtime/blob/main/docs/design/coreclr/botr/readytorun-overview.md) です。
:::

## 動機

.NET ランタイムが登場してから、マネージドコードコンポーネントの配布とデプロイに使用できるファイル形式は CLI ファイル形式の1つだけでした。この形式ではすべての実行がマシン非依存の中間言語 (IL) として表現され、コードの実行前にネイティブコードにコンパイルされる必要があります。

::: tip 💡 初心者向け補足
通常、C# のコードは IL（中間言語）にコンパイルされ、実行時に JIT コンパイラがネイティブコードに変換します。これには起動時間がかかります。ReadyToRun は、あらかじめネイティブコードを含んだファイル形式で、起動を高速化する技術です。`dotnet publish` で `-p:PublishReadyToRun=true` オプションを指定すると利用できます。
:::

効率的で直接実行可能なファイル形式がないことは、アンマネージドコードと比較して大きな問題となってきました：

- ネイティブコード生成には比較的長い時間がかかり、電力を消費する
- セキュリティ/改ざん防止のために、実行されるネイティブコードを検証する強い要望がある
- 既存のネイティブコード生成戦略は脆弱なコードを生成し、ランタイムやフレームワークが更新されるとすべてのネイティブコードが無効化される

## 問題の制約

.NET ランタイムには以前からネイティブコードストーリー (NGEN) がありましたが、ここで提案されているものは NGEN とはアーキテクチャ的に異なります。NGEN は基本的にキャッシュ（オプションであり、アプリのパフォーマンスにのみ影響）であるため、イメージの脆弱性は問題になりませんでした。

**ReadyToRun のネイティブファイル形式は、ランタイムやフレームワークの更新にもかかわらずファイルが動作し続けるという強い保証を提供します。**

::: tip 💡 初心者向け補足
NGEN（以前の AOT 技術）では、ランタイムが更新されるとコンパイル済みのネイティブイメージが無効になり、再コンパイルが必要でした。ReadyToRun はバージョン耐性を持つよう設計されており、ランタイムが更新されても以前のコンパイル済みコードが引き続き動作します。
:::

## ソリューションの概要

CLI ファイル形式を出発点として、以下の方法で拡張します：

1. 既存の CLI 形式にネイティブヘッダーを追加し、直接実行に必要な追加情報を含める
2. すべての機能を即座にサポート（完全な CLI を含むファイルの場合）
3. 最も重要なデータのみを追加し、それ以外は CLI 形式の処理パスを使用

追加情報の最も重要な部分：

- **ネイティブコード**: メソッドのネイティブコードと外部参照方法
- **GC 情報**: 各メソッドの GC ポインタ情報
- **例外処理テーブル**: 例外ハンドラーの検索用
- **IP マップ**: 命令ポインタから GC/EH 情報への対応テーブル
- **メタデータリンクテーブル**: メタデータとネイティブ構造を結びつけるテーブル

## バージョン互換性の定義

CIL と同じ互換性ルールを持つことが理想ですが、すべてのケースで効率的に行うことは困難です。最も難しい問題は値型（構造体）とジェネリックメソッドに関するものです。

**値型の互換性ルール**: 公開値型のフィールド（プライベートを含む）の数や型を変更することは破壊的変更です。ただし、非公開（internal）の構造体で、公開値型のフィールドネストから到達できない場合はこの制限は適用されません。

以下の変更は許可されます：

1. 参照クラスへのインスタンスフィールドと静的フィールドの追加
2. 値クラスへの静的フィールドの追加
3. 仮想、インスタンス、静的メソッドの追加
4. 既存メソッドの変更（セマンティクスが互換である場合）
5. 新しいクラスの追加

## バージョンバブル

**バージョンバブル**とは、セットとして更新されることを前提とした DLL のセットです。バージョニングの観点からは、この DLL のセットは単一のモジュールとして扱われます。バージョンバブル内ではインライン化やその他のクロスモジュール最適化が許可されます。

::: tip 💡 初心者向け補足
例えば、アプリケーションの DLL A と DLL B が常にセットで配布される場合、それらを「バージョンバブル」として定義できます。バブル内では、DLL A のメソッドを DLL B にインライン化するなどの最適化が可能です。一方、バブルの境界を越える場合は、バージョン耐性のためにこのような最適化は制限されます。
:::

**重要な原則**: バージョンバブルをまたがないメソッドや型のコードは、パフォーマンスペナルティを受けません。

## バージョン耐性のあるネイティブコード生成

### インスタンスフィールドアクセス

バージョンバブル内の場合、フィールドオフセットはコンパイル時に既知の定数としてコードに埋め込めます：

```
MOV RAX, [RCX + iField_Offset]
```

バージョンバブルをまたぐ場合、基底クラスのサイズが変更される可能性があるため、動的な値を使用します：

```
MOV TMP, [SIZE_OF_BASECLASS]
MOV EAX, [RCX + TMP + subfield_OffsetInSubClass]
```

### JIT の選択的使用

バージョン耐性に関連するコード品質のペナルティを回避するために、JIT コンパイラの選択的使用も可能です。例えば、バージョンバブルをまたぐインライン化候補がある場合、該当メソッドをランタイムコンパイル対象として属性で指定することで、JIT が自由に最適化を適用できます。

::: tip 💡 初心者向け補足
ReadyToRun は「事前コンパイル」と「JIT コンパイル」のハイブリッドアプローチを取ることができます。ほとんどのコードは事前コンパイルされますが、パフォーマンスが重要な一部のメソッドは JIT に任せることで、バージョン耐性と最高のパフォーマンスの両方を実現できます。
:::
